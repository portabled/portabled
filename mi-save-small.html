<!doctype html>
<html style="overflow: hidden; color: black; width: 1366px; height: 677px; background: black;"><head><title>mini shell </title>

<script data-legit="mi">
  // ONERROR
  window.__boot_times = window.__boot_times || {};
window.__boot_times.onerror_start = +new Date();

window.onerror = function onerror() {

  var msg = [];
  for (var i = 0; i < arguments.length; i++) {
    var a = arguments[i];
    if (a && (typeof a === 'object')) {

      if (a.stack) {
        msg.push(a.stack);
      }
      else {
        var msg1 = [];
        for (var k in a) {
          var r = a[k];
          if (typeof r === 'function' || (typeof r === 'object' && !r)) continue;
          msg1.push(k+':'+r);
        }
        msg.push(msg1.join(', '));
      }
    }
    else {
      msg.push(a===null ? 'null' : a);
    }

  }

  alert(msg.join('\n'));

}
//# sourceURL=boot/onerror.js
</script>


<script data-legit="mi">
  // EARLYBOOT
  earlyBoot(window);

  	function base(window) {
    return {
        getText: getText,
        setText: setText,
        elem: elem,
        on: on, off: off,
        createFrame: createFrame,
        apply: apply
    };
    function apply() {
        window.getText = getText;
        window.setText = setText;
        window.elem = elem;
        window.on = on;
        window.off = off;
        window.createFrame = createFrame;
    }
    function getText(obj) {
        if (typeof obj === 'function') {
            var result = /\/\*(\*(?!\/)|[^*])*\*\//m.exec(obj + '')[0];
            if (result)
                result = result.slice(2, result.length - 2);
            return result;
        }
        else if (/^SCRIPT$/i.test(obj.tagName)) {
            if ('text' in obj)
                return obj.text;
            else
                return obj.innerHTML;
        }
        else if (/^STYLE$/i.test(obj.tagName)) {
            if ('text' in obj)
                return obj.text;
            else if (obj.styleSheet)
                return obj.styleSheet.cssText;
            else
                return obj.innerHTML;
        }
        else if ('textContent' in obj) {
            return obj.textContent;
        }
        else if (/^INPUT$/i.test(obj.tagName)) {
            return obj.value;
        }
        else {
            var result = obj.innerText;
            if (result) {
                // IE fixes
                result = result.replace(/\<BR\s*\>/g, '\n').replace(/\r\n/g, '\n');
            }
            return result || '';
        }
    }
    function setText(obj, text) {
        if (/^SCRIPT$/i.test(obj.tagName)) {
            if ('text' in obj)
                obj.text = text;
            else
                obj.innerHTML = text;
        }
        else if (/^STYLE$/i.test(obj.tagName)) {
            if ('text' in obj) {
                obj.text = text;
            }
            else if ('styleSheet' in obj) {
                if (!obj.styleSheet && !obj.type)
                    obj.type = 'text/css';
                obj.styleSheet.cssText = text;
            }
            else if ('textContent' in obj) {
                obj.textContent = text;
            }
            else {
                obj.innerHTML = text;
            }
        }
        else if ('textContent' in obj) {
            if ('type' in obj && !obj.type)
                obj.type = 'text/css';
            obj.textContent = text;
        }
        else if (/^INPUT$/i.test(obj.tagName)) {
            obj.value = text;
        }
        else {
            obj.innerText = text;
        }
    }
    function on(obj, eventName, handler) {
        if (obj.addEventListener) {
            obj.addEventListener(eventName, handler, false);
        }
        else if (obj.attachEvent) {
            obj.attachEvent('on' + eventName, handler);
        }
        else {
            obj['on' + eventName] = function (e) { return handler(e || window.event); };
        }
    }
    ;
    function off(obj, eventName, handler) {
        if (obj.removeEventListener) {
            obj.removeEventListener(eventName, handler, false);
        }
        else if (obj.detachEvent) {
            obj.detachEvent('on' + eventName, handler);
        }
        else {
            if (obj['on' + eventName])
                obj['on' + eventName] = null;
        }
    }
    ;
    function elem(tag, style, parent) {
        var e = tag.tagName ? tag : window.document.createElement(tag);
        if (!parent && style && style.tagName) {
            parent = style;
            style = null;
        }
        if (style) {
            if (typeof style === 'string') {
                setText(e, style);
            }
            else {
                for (var k in style)
                    if (style.hasOwnProperty(k)) {
                        if (k === 'text') {
                            setText(e, style[k]);
                        }
                        else if (k === 'className') {
                            e.className = style[k];
                        }
                        else if (!(e.style && k in e.style) && k in e) {
                            e[k] = style[k];
                        }
                        else {
                            if (style[k] && typeof style[k] === 'object' && typeof style[k].length === 'number') {
                                // array: iterate and apply values
                                var applyValues = style[k];
                                for (var i = 0; i < applyValues.length; i++) {
                                    try {
                                        e.style[k] = applyValues[i];
                                    }
                                    catch (errApplyValues) { }
                                }
                            }
                            else {
                                // not array
                                try {
                                    e.style[k] = style[k];
                                }
                                catch (err) {
                                    try {
                                        if (typeof console !== 'undefined' && typeof console.error === 'function')
                                            console.error(e.tagName + '.style.' + k + '=' + style[k] + ': ' + err.message);
                                    }
                                    catch (whatevs) {
                                        alert(e.tagName + '.style.' + k + '=' + style[k] + ': ' + err.message);
                                    }
                                }
                            }
                        }
                    }
            }
        }
        if (parent) {
            try {
                parent.appendChild(e);
            }
            catch (error) {
                throw new Error(error.message + ' adding ' + e.tagName + ' to ' + parent.tagName);
            }
        }
        return e;
    }
    function createFrame() {
        var ifr = elem('iframe', {
            position: 'absolute',
            left: 0, top: 0,
            width: '100%', height: '100%',
            border: 'none',
            src: 'about:blank'
        }, window.document.body);
        var ifrwin = ifr.contentWindow || ifr.window;
        var ifrdoc = ifrwin.document;
        if (ifrdoc.open)
            ifrdoc.open();
        ifrdoc.write('<!' + 'doctype html' + '>' +
            '<' + 'html' + '>' +
            '<' + 'head' + '><' + 'style' + '>' +
            'body,html{margin:0;padding:0;border:none;height:100%;border:none;}' +
            '*,*:before,*:after{box-sizing:inherit;}' +
            'html{box-sizing:border-box;}' +
            '</' + 'style' + '>\n' +
            '<' + 'body' + '>' +
            '<' + 'script' + '>window.__eval_export_=function(code) { return eval(code); }</' + 'script' + '>' +
            // it's important to have body before any long scripts (especialy external),
            // so IFRAME is immediately ready
            '<' + 'body' + '>' +
            '</' + 'html' + '>');
        if (ifrdoc.close)
            ifrdoc.close();
        var ifrwin_eval = ifrwin.__eval_export_;
        try {
            delete ifrwin.__eval_export_;
        }
        catch (weirdIEFailure) {
        }
        ifrdoc.body.innerHTML = '';
        if (window.onerror) {
            ifrwin.onerror = delegate_onerror;
        }
        return {
            document: ifrdoc,
            global: ifrwin,
            iframe: ifr,
            evalFN: ifrwin_eval
        };
        function delegate_onerror() {
            window.onerror.apply(window, arguments);
        }
    }
}
function earlyBoot(window) {
    base(window).apply();
    window.__boot_times.earlyBootStart = (+new Date());
    document.write('<' + 'style' + ' data-legit=mi>' +
        '*{display:none;background:black;color:black;}' +
        'html,body{display:block;background:black;color:black;}' +
        '</' + 'style' + '>' +
        (document.body ? '' : '<body>'));
    elem(document.body, {
        height: '100%',
        margin: 0,
        padding: 0,
        overflow: 'hidden',
        background: 'black', color: 'black'
    });
    elem(document.body.parentElement, {
        overflow: 'hidden',
        background: 'black', color: 'black'
    });
    var allStyleElements = document.getElementsByTagName('style');
    var addedStyle = allStyleElements[allStyleElements.length - 1];
    var bootFrame = createFrame();
    bootFrame.iframe.style.zIndex = 2000;
    bootFrame.iframe.style.display = 'block';
    base(bootFrame.global).apply();
    var bootUI = window.bootUI;
    var bootAPI = bootUI(bootFrame.document, bootFrame.global, { elem: bootFrame.global.elem });
    bootFrame.api = bootAPI;
    bootFrame.earlyStartTime = window.__boot_times.onerror_start;
    bootFrame.bootStartTime = window.__boot_times.earlyBootStart;
    var uniqueKey = deriveUniqueKey(location);
    var shellLoaderInstance = null;
    var shellLoadInterval = setInterval(function () {
        if (window.shellLoader === 'undefined')
            return;
        if (!shellLoadInterval)
            return; // protect against old Opera's super-async habits
        shellLoaderInstance = shellLoaderInstance ? shellLoaderInstance.continueLoading() : window.shellLoader ? window.shellLoader(uniqueKey, document, bootFrame) : null;
    }, 1);
    window.onload = function () {
        clearInterval(shellLoadInterval);
        shellLoadInterval = 0;
        removeSpyElements();
        bootFrame.iframe.style.zIndex = 1000;
        if (addedStyle.parentElement)
            addedStyle.parentElement.removeChild(addedStyle);
        bootFrame.iframe.style.display = '';
        (shellLoaderInstance || window.shellLoader(uniqueKey, document, bootFrame)).finishLoading();
    };
    function deriveUniqueKey(locationSeed) {
        var key = (locationSeed + '').split('?')[0].split('#')[0].toLowerCase();
        var posIndexTrail = key.search(/\/index\.html$/);
        if (posIndexTrail > 0)
            key = key.slice(0, posIndexTrail);
        if (key.charAt(0) === '/')
            key = key.slice(1);
        if (key.slice(-1) === '/')
            key = key.slice(0, key.length - 1);
        return smallHash(key) + '-' + smallHash(key.slice(1) + 'a');
        function smallHash(key) {
            for (var h = 0, i = 0; i < key.length; i++) {
                h = Math.pow(31, h + 31 / key.charCodeAt(i));
                h -= h | 0;
            }
            return (h * 2000000000) | 0;
        }
    }
    function removeSpyElements() {
        removeElements('iframe', function (ifr) { return ifr !== bootFrame.iframe; });
        removeElements('style', function (sty) { return sty.getAttribute('data-legit') !== 'mi'; });
        removeElements('script', function (sty) { return sty.getAttribute('data-legit') !== 'mi'; });
        function removeElements(tagName, predicateToRemove) {
            var list = document.getElementsByTagName(tagName);
            for (var i = 0; i < list.length; i++) {
                var elem = list[i] || list.item(i);
                if (predicateToRemove(elem)) {
                    elem.parentElement.removeChild(elem);
                    i--;
                }
            }
        }
    }
}
function bootUI(document, window, base) {
    base.elem(document.body, {
        background: 'black',
        color: 'silver',
        border: 'none',
        overflow: 'hidden',
        fontFamily: 'FixedSys, System, Terminal, Arial, Helvetica, Roboto, Droid Sans, Sans Serif',
        fontWeight: 'bold'
    });
    var monitorBack = base.elem('div', {
        position: 'relative',
        width: '100%', height: '100%',
        padding: '3em',
        background: '#101010',
        opacity: 0,
        transition: 'all 0.1s ease-in',
        webkitTransition: 'all 0.1s ease-in',
        mozTransition: 'all 0.1s ease-in',
        oTransition: 'all 0.1s ease-in',
        msTransition: 'all 0.1s ease-in'
    }, document.body);
    var hostHeight = Math.max(document.body.offsetHeight, document.body.parentElement.offsetHeight);
    var hostWidth = Math.max(document.body.offsetWidth, document.body.parentElement.offsetWidth);
    var totalWidth = Math.min((hostHeight - 40) * 640 / 350, hostWidth - 10);
    var totalHeight = totalWidth * 350 / 640;
    shake(lazerAppear);
    function shake(callback) {
        var shakeStart = Date.now();
        var shakeTotal = 700;
        var shakeAni = setInterval(function () {
            var passed = Date.now() - shakeStart;
            var phase = passed / shakeTotal;
            if (phase > 1) {
                monitorBack.parentElement.removeChild(monitorBack);
                clearInterval(shakeAni);
                if (callback)
                    callback();
                return;
            }
            if (phase < 0.1) {
                monitorBack.style.opacity = phase * 10;
                monitorBack.style.width = (100 - phase) + '%';
                monitorBack.style.height = (100 - phase) + '%';
            }
            else {
                var fadePhase = (Math.sin((phase - 0.1) * 8) + 1) / 2;
                monitorBack.style.opacity = fadePhase * 0.5;
                var shakePhase = Math.sin((phase - 0.1) * 5);
                monitorBack.style.top = shakePhase * 100 + 'px';
            }
        }, 1);
    }
    var lazer;
    var lazerAni;
    var bootBar;
    function lazerAppear() {
        console.log('ani: lazerAppear');
        var lazerStart = Date.now();
        var lazerTotal = 1000;
        lazer = elem('div', {
            position: 'absolute',
            background: 'orange',
            top: totalHeight / 2 + 'px',
            left: totalWidth / 2 + 'px',
            width: '1px',
            height: '1px',
            filter: 'blur(10px)',
            webkitFilter: 'blur(10px)',
            mozFilter: 'blur(10px)',
            oFilter: 'blur(10px)',
            msFilter: 'DXImageTransform.Microsoft.Blur(PixelRadius=\'10\')',
            transition: 'all 0.1s ease-in',
            webkitTransition: 'all 0.1s ease-in',
            mozTransition: 'all 0.1s ease-in',
            oTransition: 'all 0.1s ease-in',
            msTransition: 'all 0.1s ease-in'
        }, document.body);
        lazerAni = setInterval(function () {
            var lazerPhase = (Date.now() - lazerStart) / lazerTotal;
            console.log('ani: lazerPhase ' + lazerPhase);
            if (lazerPhase > 1) {
                clearInterval(lazerAni);
                if (lazer) {
                    lazer.style.opacity = 1;
                }
                console.log('ani: create bootBar');
                bootBar = base.elem('div', {
                    position: 'absolute',
                    top: (totalHeight / 2 - totalHeight / 140) + 'px',
                    background: 'white', color: 'white',
                    height: totalHeight / 70 + 'px',
                    width: totalWidth * 0.3 + 'px',
                    left: totalWidth * 0.48 + 'px',
                    filter: 'blur(10px)',
                    webkitFilter: 'blur(5px)',
                    mozFilter: 'blur(5px)',
                    oFilter: 'blur(5px)',
                    msFilter: 'DXImageTransform.Microsoft.Blur(PixelRadius=\'5\')',
                    fontSize: '10%',
                    innerHTML: '&nbsp;',
                    transition: 'all 0.6s ease-in',
                    webkitTransition: 'all 0.6s ease-in',
                    mozTransition: 'all 0.6s ease-in',
                    oTransition: 'all 0.6s ease-in',
                    msTransition: 'all 0.6s ease-in'
                }, document.body);
                return;
            }
            if (lazerPhase < 0.5) {
                var appearPhase = lazerPhase * 2;
                console.log('ani: appearPhase ' + appearPhase);
                var bigDiameter = Math.min(totalHeight, totalWidth) / 20;
                var diameter = bigDiameter * appearPhase;
                lazer.style.width = diameter + 'px';
                lazer.style.left = (totalWidth - diameter) / 2 + 'px';
                lazer.style.height = diameter + 'px';
                lazer.style.top = (totalHeight - diameter) / 2 + 'px';
            }
            else {
                var widenPhase = (lazerPhase - 0.5) * 2;
                console.log('ani: widenPhase ' + widenPhase);
                var bigDiameter = Math.min(totalHeight, totalWidth) / 20;
                var height = bigDiameter - (bigDiameter * 0.7) * widenPhase;
                lazer.style.height = height + 'px';
                lazer.style.top = (totalHeight - height) / 2 + 'px';
                var width = bigDiameter + (totalWidth * 0.95 - bigDiameter) * widenPhase;
                lazer.style.width = width + 'px';
                lazer.style.left = (totalWidth - width) / 2 + 'px';
            }
        }, 1);
    }
    function lazerStop() {
        if (lazer && lazerAni) {
            clearInterval(lazerAni);
            lazer.parentElement.removeChild(lazer);
            lazer = null;
            lazerAni = 0;
        }
    }
    var _ratio;
    var _splash;
    var _splashStartRatio;
    return {
        drive: function (drive) {
            try {
                var dt = drive.read('/splash.img');
                if (dt) {
                    _splash = document.createElement('img');
                    _splash.width = 640;
                    _splash.height = 350;
                    _splash.src = dt;
                    elem(_splash, {
                        position: 'absolute',
                        top: totalWidth / 2 + 'px',
                        left: totalHeight / 4 + 'px',
                        height: '1px',
                        width: totalWidth / 2 + 'px',
                        opacity: 0.1,
                        filter: 'blur(10px)',
                        webkitFilter: 'blur(10px)',
                        mozFilter: 'blur(10px)',
                        oFilter: 'blur(10px)',
                        msFilter: 'DXImageTransform.Microsoft.Blur(PixelRadius=\'10\')',
                        transition: 'all 0.6s ease-in',
                        webkitTransition: 'all 0.6s ease-in',
                        mozTransition: 'all 0.6s ease-in',
                        oTransition: 'all 0.6s ease-in',
                        msTransition: 'all 0.6s ease-in'
                    }, document.body);
                    _splashStartRatio = _ratio || 0;
                }
            }
            catch (errorLoadImage) {
            }
        },
        title: function (t, ratio) {
            _ratio = ratio;
            // setText(smallTitle,t);
            if (typeof console !== 'undefined' && typeof console.log === 'function')
                console.log(t);
            if (ratio) {
                if (bootBar) {
                    console.log('ani: bootBar there ' + ratio);
                    var width = totalWidth * ratio * 0.8;
                    bootBar.style.left = (((totalWidth - width) / 2) | 0) + 'px';
                    bootBar.style.width = width + 'px';
                }
                else {
                    console.log('ani: bootBar not there ' + ratio);
                }
                if (_splash) {
                    var canvPhase = (ratio - (_splashStartRatio || 0)) / (1 - _splashStartRatio || 0);
                    var width = totalWidth * 0.499 + canvPhase * totalWidth / 2;
                    var height = canvPhase * totalHeight * 0.999;
                    _splash.style.top = (totalHeight - height) / 2 + 'px';
                    _splash.style.height = height + 'px';
                    _splash.style.left = (totalWidth - width) / 2 + 'px';
                    _splash.style.width = width + 'px';
                    _splash.style.opacity = canvPhase;
                    var blurRadius = (1 - canvPhase) * 10 + 2;
                    _splash.style.filter = 'blur(' + blurRadius + 'px)';
                    _splash.style.webkitFilter = 'blur(' + blurRadius + 'px)';
                    _splash.style.mozFilter = 'blur(' + blurRadius + 'px)';
                    _splash.style.oFilter = 'blur(' + blurRadius + 'px)';
                    _splash.style.msFilter = 'DXImageTransform.Microsoft.Blur(PixelRadius=\'' + blurRadius + '\')';
                }
            }
        },
        loaded: function () {
            //setText(smallTitle, 'Loaded.');
        }
    };
}


    function bootUI(document, window, base) {

  base.elem(document.body, {
    background: 'rgb(3,11,61)',
    color: 'cyan',
    border: 'none',
    overflow: 'hidden',
    fontFamily: 'Segoe UI Light, Segoe UI, Ubuntu Light, Ubuntu, Toronto, Helvetica, Roboto, Droid Sans, Sans Serif'
  });

  base.elem('div', {
    innerHTML:
    	'<table style="width:100%;filter:blur(2.5px);-webkit-filter:blur(2.5px);-ms-filter: DXImageTransform.Microsoft.Blur(PixelRadius=\'2.5\');" width=100%><tr><td style="width:50%;" width=50% valign=top>'+
    	'<div style="color: white">'+
        '<div style="background: darkcyan; width: 33%; margin-top:0.5em;padding-left:0.5em;">######</div>'+
        '<div style="margin-left:0.5em;">'+
          '##### <br>'+
          '###'+
        '</div>'+
        '<div style="margin-left:0.5em;">'+
          '******* <br>'+
          '*********** <br>'+
          '*********** <br>'+
          '************ <br>'+
          '************* <br>'+
          '**************** ** <br>'+
          '*************** <br>'+
          '************' +
        '</div>'+
      '</div>'+
    	'</td><td style="width:50%; padding: 0.5em;" width=50% valign=top>'+
    	'<div style="color: white">'+
    	'-- <br>'+
    	'#### <br>'+
    	'####### <br>'+
    	'#### <br>'+
    	'#### <br>'+
    	'#### #### <br>' +
    	'######## <br>' +
    	'##### <br>'+
    	'####### <br>' +
    	'#######' +
    	'</div>'+
    	'***** ** <br>'+
    	'**** **** <br>'+
    	'*********' +
    	'</td></tr></table>'
  }, document.body);


  var progressContainer = base.elem('div', {
    position: 'absolute',
    left: 0, top: 0,
    padding: '3em'
  }, document.body);

  var header = base.elem('h2', {
    text: 'Mini portabled shell',
    color: 'white',
    fontWeight: '100',
    fontSize: '500%',
    marginBottom: 0, paddingBottom: 0,
    textShadow: '1px 1px 3px black'
  }, progressContainer);

  var smallTitle = base.elem('div', {
    fontStyle: 'italic',
    paddingLeft: '1em',
    textShadow: '1px 1px 3px black',
    text: 'Loading...',
    opacity: 0.8
  }, progressContainer);

  var bootBar = base.elem('div', {
    marginTop: '2em',
    background: 'gold', color: 'gold',
    height: '2px',
    width: '3%',
    fontSize: '10%',
    innerHTML: '&nbsp;'
  }, progressContainer);

  var darkBottom = base.elem('div', {
    position: 'absolute',
    bottom: 0,
    width: '100%',
    height: '3em',
    background: 'black'
  }, document.body);

  return {
    title: function(t, ratio) {
      setText(smallTitle,t);
      if (typeof console !== 'undefined' && typeof console.log === 'function')
        console.log(t);
      if (ratio) {
        bootBar.style.width = (ratio*100) + '%';
      }
    },
    loaded: function() {
      setText(smallTitle, 'Loaded.');
    }
  };
}
//# sourceURL=/boot/base.js
</script></head><body background="black" style="height: 677px; margin: 0px; padding: 0px; overflow: hidden; color: black; width: 1366px; background: black;">


<script data-legit="mi">

  // LOADER
//declare var showCommanderInContext;
function shellLoader(uniqueKey, document, boot) {
    var driveMount = persistence.bootMount(uniqueKey, document);
    return continueLoading();
    function continueLoading() {
        driveMount = driveMount.continueLoading();
        boot.api.title('Loading files: ' + progressText('dom'), 0.05 + 0.8 * driveMount.loadedSize / driveMount.totalSize);
        return { continueLoading: continueLoading, finishLoading: finishLoading };
    }
    var timings;
    var prevStage;
    var prevStageStart;
    var prevTimeText;
    function progressText(stage) {
        var fileText = driveMount.loadedFileCount + ' (' + driveMount.totalSize + ' total)';
        var now = +new Date();
        if (!prevStage) {
            timings = [
                { stage: 'boot ui', time: boot.bootStartTime - boot.earlyStartTime }
            ];
            prevTimeText = ' boot UI ' + (boot.bootStartTime - boot.earlyStartTime) + 'ms init ' + (now - boot.bootStartTime) + 'ms';
            prevStageStart = boot.bootStartTime;
            prevStage = stage;
            return fileText + prevTimeText;
        }
        else if (prevStage !== stage) {
            timings.push({
                stage: prevStage,
                time: now - prevStageStart
            });
            prevTimeText += ' ' + prevStage + ' ' + (now - prevStageStart) + 'ms';
            prevStageStart = now;
            prevStage = stage;
            return fileText + prevTimeText;
        }
        else {
            return fileText + prevTimeText + ' ' + prevStage + ' ' + (now - prevStageStart) + 'ms';
        }
    }
    function finishLoading() {
        boot.api.title('Loading modifications: ' + progressText('local'), 0.85);
        driveMount.finishLoading(function (drive) {
            if (typeof boot.api.drive === 'function') {
                boot.api.drive(drive);
            }
            boot.api.title('Loading application: ' + progressText('ui-init'), 0.9);
            var uiframe = createFrame();
            uiframe.iframe.style.opacity = '0';
            uiframe.iframe.style.filter = 'alpha(opacity=0)';
            var uiframeBase = window.base(uiframe.global);
            uiframeBase.apply();
            var wasResized = false;
            var resizeHandlers = [];
            on(window, 'scroll', global_resize_detect);
            on(window, 'resize', global_resize_detect);
            on(document.body, 'resize', global_resize_detect);
            on(document.body, 'scroll', global_resize_detect);
            if (document.documentElement)
                on(document.documentElement, 'resize', global_resize_detect);
            if (document.documentElement)
                on(document.documentElement, 'scroll', global_resize_detect);
            on(uiframe.document.body, 'touchstart', global_resize_detect);
            on(uiframe.document.body, 'touchmove', global_resize_detect);
            on(uiframe.document.body, 'touchend', global_resize_detect);
            on(uiframe.document.body, 'pointerdown', global_resize_detect);
            on(uiframe.document.body, 'pointerup', global_resize_detect);
            on(uiframe.document.body, 'pointerout', global_resize_detect);
            on(uiframe.document.body, 'keydown', global_resize_detect);
            on(uiframe.document.body, 'keyup', global_resize_detect);
            uiframe.global.require = shell_require;
            boot.api.title('Loaded: ' + progressText('ui'), 0.95);
            global_resize_delayed();
            // TODO: do this concurrently with drive loading
            try {
                var indexHTML = drive.read('/shell/index.html');
                if (indexHTML) {
                    uiframe.document.write(indexHTML);
                }
                var files = drive.files();
                var shellScripts = [];
                for (var i = 0; i < files.length; i++) {
                    if (!/^\/shell\//.test(files[i]))
                        continue;
                    var content = drive.read(files[i]);
                    if (/\.js$/.test(files[i])) {
                        uiframe.document.write('<' + 'script' + '>' + content + ' //# sourceURL=' + files[i] + '</' + 'script' + '>');
                    }
                    else if (/\.css$/.test(files[i])) {
                        uiframe.document.write('<' + 'style' + ' type="text/css">' + content + ' //# sourceURL=' + files[i] + '</' + 'style' + '>');
                    }
                }
            }
            catch (error) {
                alert('Shell initialisation failed ' + error.message + '\n' + error.stack + '\n' + error);
            }
            if (uiframe.document.close)
                uiframe.document.close();
            checkShellCompleteOrWait();
            function checkShellCompleteOrWait() {
                var glo = uiframe.global;
                if (glo.shell && glo.shell.start) {
                    glo.shell.start(shellComplete);
                }
                else {
                    setTimeout(checkShellCompleteOrWait, 10);
                }
            }
            function shellComplete() {
                var msg = 'Completed: ' + progressText('ui');
                boot.api.title(msg, 0.99);
                var start = new Date().valueOf();
                var fadeintTime = Math.min(500, ((+new Date()) - boot.bootStartTime) * 0.9);
                var animateFadeIn = setInterval(function () {
                    var passed = new Date().valueOf() - start;
                    var opacity = Math.min(passed, fadeintTime) / fadeintTime;
                    boot.iframe.style.opacity = (1 - opacity).toString();
                    if (uiframe.iframe.style.filter)
                        boot.iframe.style.filter = 'alpha(opacity=' + ((opacity * 100) | 0) + ')';
                    uiframe.iframe.style.opacity = '1';
                    uiframe.iframe.style.filter = 'alpha(opacity=100)';
                    if (passed >= fadeintTime) {
                        clearInterval(animateFadeIn);
                        if (boot.iframe.parentElement)
                            boot.iframe.parentElement.removeChild(boot.iframe);
                    }
                }, 20);
                return msg;
            }
            function shell_require(moduleName) {
                switch (moduleName) {
                    case 'nowindow': return window;
                    case 'noui': return uiframe;
                    case 'nodrive': return drive;
                    case 'uniqueKey': return uniqueKey;
                    case 'resize': return { on: onresize, off: offresize };
                    case 'timings': return timings;
                }
                throw new Error('Module ' + moduleName + ' is not supported.');
            }
            function onresize(handler) {
                if (typeof handler !== 'function')
                    return;
                resizeHandlers.push(handler);
            }
            function offresize(handler) {
                if (typeof handler !== 'function')
                    return;
                for (var i = 0; i < resizeHandlers.length; i++) {
                    if (resizeHandlers[i] === handler) {
                        resizeHandlers.splice(i, 1);
                    }
                }
            }
            function global_resize_detect() {
                if (wasResized)
                    return;
                wasResized = true;
                if (typeof requestAnimationFrame === 'function') {
                    requestAnimationFrame(global_resize_delayed);
                }
                else {
                    setTimeout(global_resize_delayed, 5);
                }
            }
            var lastMetrics = null;
            var lastScroll = null;
            function global_resize_delayed() {
                var scrollPos = getScroll();
                if (!lastScroll || (scrollPos.x !== lastScroll.x || scrollPos.y !== lastScroll.y)) {
                    lastScroll = scrollPos;
                    uiframe.iframe.style.left = scrollPos.x + 'px';
                    uiframe.iframe.style.top = scrollPos.y + 'px';
                }
                wasResized = false;
                var metrics = getMetrics();
                if (!lastMetrics || (metrics.windowWidth !== lastMetrics.windowWidth
                    && metrics.windowHeight !== lastMetrics.windowHeight)) {
                    lastMetrics = metrics;
                    var w = metrics.windowWidth + 'px';
                    var h = metrics.windowHeight + 'px';
                    if (boot && boot.iframe) {
                        boot.iframe.style.width = w;
                        boot.iframe.style.height = h;
                    }
                    if (uiframe) {
                        uiframe.iframe.style.width = w;
                        uiframe.iframe.style.height = h;
                    }
                    document.body.style.width = w;
                    document.body.style.height = h;
                    if (document.body.parentElement) {
                        document.body.parentElement.style.width = w;
                        document.body.parentElement.style.height = h;
                    }
                    for (var i = 0; i < resizeHandlers.length; i++) {
                        var f = resizeHandlers[i];
                        if (f)
                            f(metrics);
                    }
                }
            }
            function getScroll() {
                var x = window.scrollX || window.pageXOffset || document.body.scrollLeft || (document.body.parentElement ? document.body.parentElement.scrollLeft : 0) || 0;
                var y = window.scrollY || window.pageYOffset || document.body.scrollTop || (document.body.parentElement ? document.body.parentElement.scrollTop : 0) || 0;
                return { x: x, y: y };
            }
            function getMetrics() {
                var metrics = {
                    windowWidth: window.innerWidth || (document.body.parentElement ? document.body.parentElement.clientWidth : 0) || document.body.clientWidth,
                    windowHeight: window.innerHeight || (document.body.parentElement ? document.body.parentElement.clientHeight : 0) || document.body.clientHeight
                };
                return metrics;
            }
        });
    }
    function createFrame() {
        var ifr = elem('iframe', {
            position: 'absolute',
            left: 0, top: 0,
            width: '100%', height: '100%',
            border: 'none',
            src: 'about:blank'
        }, window.document.body);
        var ifrwin = ifr.contentWindow || ifr.window;
        var ifrdoc = ifrwin.document;
        ifrdoc.write('<!' + 'doctype html' + '>' +
            '<' + 'html' + '>' +
            '<' + 'head' + '><' + 'style' + '>' +
            'body,html{margin:0;padding:0;border:none;height:100%;border:none;background:black;}' +
            '*,*:before,*:after{box-sizing:inherit;}' +
            'html{box-sizing:border-box;}' +
            '</' + 'style' + '>\n' +
            '</' + 'head' + '>' +
            '<' + 'body' + '>');
        return {
            document: ifrdoc,
            global: ifrwin,
            iframe: ifr
        };
    }
}
var persistence;
(function (persistence) {
    function getIndexedDB() {
        try {
            return typeof indexedDB === 'undefined' || typeof indexedDB.open !== 'function' ? null : indexedDB;
        }
        catch (error) {
            return null;
        }
    }
    var attached;
    (function (attached) {
        var indexedDB;
        (function (indexedDB) {
            indexedDB.name = 'indexedDB';
            function detect(uniqueKey, callback) {
                try {
                    detectCore(uniqueKey, callback);
                }
                catch (error) {
                    callback(null);
                }
            }
            indexedDB.detect = detect;
            function detectCore(uniqueKey, callback) {
                var indexedDBInstance = getIndexedDB();
                if (!indexedDBInstance) {
                    callback(null);
                    return;
                }
                var dbName = uniqueKey || 'portabled';
                var openRequest = indexedDBInstance.open(dbName, 1);
                openRequest.onerror = function (errorEvent) { return callback(null); };
                openRequest.onupgradeneeded = createDBAndTables;
                openRequest.onsuccess = function (event) {
                    var db = openRequest.result;
                    try {
                        var transaction = db.transaction(['files', 'metadata']);
                        // files mentioned here, but not really used to detect
                        // broken multi-store transaction implementation in Safari
                        transaction.onerror = function (errorEvent) { return callback(null); };
                        var metadataStore = transaction.objectStore('metadata');
                        var filesStore = transaction.objectStore('files');
                        var editedUTCRequest = metadataStore.get('editedUTC');
                    }
                    catch (getStoreError) {
                        callback(null);
                        return;
                    }
                    if (!editedUTCRequest) {
                        callback(null);
                        return;
                    }
                    editedUTCRequest.onerror = function (errorEvent) {
                        var detached = new IndexedDBDetached(db, null);
                        callback(detached);
                    };
                    editedUTCRequest.onsuccess = function (event) {
                        var result = editedUTCRequest.result;
                        var detached = new IndexedDBDetached(db, result && typeof result.value === 'number' ? result.value : null);
                        callback(detached);
                    };
                };
                function createDBAndTables() {
                    var db = openRequest.result;
                    var filesStore = db.createObjectStore('files', { keyPath: 'path' });
                    var metadataStore = db.createObjectStore('metadata', { keyPath: 'property' });
                }
            }
            var IndexedDBDetached = (function () {
                function IndexedDBDetached(_db, timestamp) {
                    this._db = _db;
                    this.timestamp = timestamp;
                }
                IndexedDBDetached.prototype.applyTo = function (mainDrive, callback) {
                    var _this = this;
                    var transaction = this._db.transaction(['files', 'metadata'], 'readwrite');
                    var metadataStore = transaction.objectStore('metadata');
                    var filesStore = transaction.objectStore('files');
                    var countRequest = filesStore.count();
                    countRequest.onerror = function (errorEvent) {
                        console.error('Could not count files store.');
                        callback(null);
                    };
                    countRequest.onsuccess = function (event) {
                        var storeCount = countRequest.result;
                        var cursorRequest = filesStore.openCursor();
                        cursorRequest.onerror = function (errorEvent) { return callback(null); };
                        // to cleanup any files which content is the same on the main drive
                        var deleteList = [];
                        var anyLeft = false;
                        var processedCount = 0;
                        cursorRequest.onsuccess = function (event) {
                            var cursor = cursorRequest.result;
                            if (!cursor) {
                                // cleaning up files whose content is duplicating the main drive
                                if (anyLeft) {
                                    for (var i = 0; i < deleteList.length; i++) {
                                        filesStore['delete'](deleteList[i]);
                                    }
                                }
                                else {
                                    filesStore.clear();
                                    metadataStore.clear();
                                }
                                callback(new IndexedDBShadow(_this._db, _this.timestamp));
                                return;
                            }
                            if (callback.progress)
                                callback.progress(processedCount, storeCount);
                            processedCount++;
                            var result = cursor.value;
                            if (result && result.path) {
                                var existingContent = mainDrive.read(result.path);
                                if (existingContent === result.content) {
                                    deleteList.push(result.path);
                                }
                                else {
                                    mainDrive.timestamp = _this.timestamp;
                                    mainDrive.write(result.path, result.content);
                                    anyLeft = true;
                                }
                            }
                            cursor['continue']();
                        }; // cursorRequest.onsuccess
                    }; // countRequest.onsuccess
                };
                IndexedDBDetached.prototype.purge = function (callback) {
                    var transaction = this._db.transaction(['files', 'metadata'], 'readwrite');
                    var filesStore = transaction.objectStore('files');
                    filesStore.clear();
                    var metadataStore = transaction.objectStore('metadata');
                    metadataStore.clear();
                    callback(new IndexedDBShadow(this._db, -1));
                };
                return IndexedDBDetached;
            })();
            var IndexedDBShadow = (function () {
                function IndexedDBShadow(_db, timestamp) {
                    this._db = _db;
                    this.timestamp = timestamp;
                }
                IndexedDBShadow.prototype.write = function (file, content) {
                    var transaction = this._db.transaction(['files', 'metadata'], 'readwrite');
                    var filesStore = transaction.objectStore('files');
                    var metadataStore = transaction.objectStore('metadata');
                    // no file deletion here: we need to keep account of deletions too!
                    var fileData = {
                        path: file,
                        content: content,
                        state: null
                    };
                    var putFile = filesStore.put(fileData);
                    var md = {
                        property: 'editedUTC',
                        value: Date.now()
                    };
                    metadataStore.put(md);
                };
                return IndexedDBShadow;
            })();
        })(indexedDB = attached.indexedDB || (attached.indexedDB = {}));
    })(attached = persistence.attached || (persistence.attached = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function getLocalStorage() {
        return typeof localStorage === 'undefined' || typeof localStorage.length !== 'number' ? null : localStorage;
    }
    // is it OK&
    var attached;
    (function (attached) {
        var localStorage;
        (function (localStorage) {
            localStorage.name = 'localStorage';
            function detect(uniqueKey, callback) {
                var localStorageInstance = getLocalStorage();
                if (!localStorageInstance) {
                    callback(null);
                    return;
                }
                var access = new LocalStorageAccess(localStorageInstance, uniqueKey);
                var dt = new LocalStorageDetached(access);
                callback(dt);
            }
            localStorage.detect = detect;
            var LocalStorageAccess = (function () {
                function LocalStorageAccess(_localStorage, _prefix) {
                    this._localStorage = _localStorage;
                    this._prefix = _prefix;
                    this._cache = {};
                }
                LocalStorageAccess.prototype.get = function (key) {
                    var k = this._expandKey(key);
                    var r = this._localStorage.getItem(k);
                    return r;
                };
                LocalStorageAccess.prototype.set = function (key, value) {
                    var k = this._expandKey(key);
                    return this._localStorage.setItem(k, value);
                };
                LocalStorageAccess.prototype.remove = function (key) {
                    var k = this._expandKey(key);
                    return this._localStorage.removeItem(k);
                };
                LocalStorageAccess.prototype.keys = function () {
                    var result = [];
                    var len = this._localStorage.length;
                    for (var i = 0; i < len; i++) {
                        var str = this._localStorage.key(i);
                        if (str.length > this._prefix.length && str.slice(0, this._prefix.length) === this._prefix)
                            result.push(str.slice(this._prefix.length));
                    }
                    return result;
                };
                LocalStorageAccess.prototype._expandKey = function (key) {
                    var k;
                    if (!key) {
                        k = this._prefix;
                    }
                    else {
                        k = this._cache[key];
                        if (!k)
                            this._cache[key] = k = this._prefix + key;
                    }
                    return k;
                };
                return LocalStorageAccess;
            })();
            var LocalStorageDetached = (function () {
                function LocalStorageDetached(_access) {
                    this._access = _access;
                    this.timestamp = 0;
                    var timestampStr = this._access.get('*timestamp');
                    if (timestampStr && timestampStr.charAt(0) >= '0' && timestampStr.charAt(0) <= '9') {
                        try {
                            this.timestamp = parseInt(timestampStr);
                        }
                        catch (parseError) {
                        }
                    }
                }
                LocalStorageDetached.prototype.applyTo = function (mainDrive, callback) {
                    var keys = this._access.keys();
                    for (var i = 0; i < keys.length; i++) {
                        var k = keys[i];
                        if (k.charAt(0) === '/') {
                            var value = this._access.get(k);
                            mainDrive.write(k, value);
                        }
                    }
                    var shadow = new LocalStorageShadow(this._access, mainDrive.timestamp);
                    callback(shadow);
                };
                LocalStorageDetached.prototype.purge = function (callback) {
                    var keys = this._access.keys();
                    for (var i = 0; i < keys.length; i++) {
                        var k = keys[i];
                        if (k.charAt(0) === '/') {
                            var value = this._access.remove(k);
                        }
                    }
                    var shadow = new LocalStorageShadow(this._access, this.timestamp);
                    callback(shadow);
                };
                return LocalStorageDetached;
            })();
            var LocalStorageShadow = (function () {
                function LocalStorageShadow(_access, timestamp) {
                    this._access = _access;
                    this.timestamp = timestamp;
                }
                LocalStorageShadow.prototype.write = function (file, content) {
                    this._access.set(file, content);
                    this._access.set('*timestamp', this.timestamp);
                };
                return LocalStorageShadow;
            })();
        })(localStorage = attached.localStorage || (attached.localStorage = {}));
    })(attached = persistence.attached || (persistence.attached = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function getOpenDatabase() {
        return typeof openDatabase !== 'function' ? null : openDatabase;
    }
    var attached;
    (function (attached) {
        var webSQL;
        (function (webSQL) {
            webSQL.name = 'webSQL';
            function detect(uniqueKey, callback) {
                var openDatabaseInstance = getOpenDatabase();
                if (!openDatabaseInstance) {
                    callback(null);
                    return;
                }
                var dbName = uniqueKey || 'portabled';
                var db = openDatabase(dbName, 1, 'Portabled virtual filesystem data', 1024 * 1024); // size
                // upgradeCallback?
                db.readTransaction(function (transaction) {
                    transaction.executeSql('SELECT value from "*metadata" WHERE name=\'editedUTC\'', [], function (transaction, result) {
                        var editedValue = null;
                        if (result.rows && result.rows.length === 1) {
                            var editedValueStr = result.rows.item(0).value;
                            if (typeof editedValueStr === 'string') {
                                try {
                                    editedValue = parseInt(editedValueStr);
                                }
                                catch (error) {
                                }
                            }
                            else if (typeof editedValueStr === 'number') {
                                editedValue = editedValueStr;
                            }
                        }
                        callback(new WebSQLDetached(db, editedValue || 0, true));
                    }, function (transaction, sqlError) {
                        // no data
                        callback(new WebSQLDetached(db, 0, false));
                    });
                }, function (sqlError) {
                    // failed to load
                    callback(null);
                });
            }
            webSQL.detect = detect;
            var WebSQLDetached = (function () {
                function WebSQLDetached(_db, timestamp, _metadataTableIsValid) {
                    this._db = _db;
                    this.timestamp = timestamp;
                    this._metadataTableIsValid = _metadataTableIsValid;
                }
                WebSQLDetached.prototype.applyTo = function (mainDrive, callback) {
                    var _this = this;
                    this._db.readTransaction(function (transaction) { return listAllTables(transaction, function (tables) {
                        var ftab = getFilenamesFromTables(tables);
                        _this._applyToWithFiles(transaction, ftab, mainDrive, callback);
                    }, function (sqlError) {
                        reportSQLError('Failed to list tables for the webSQL database.', sqlError);
                        callback(new WebSQLShadow(_this._db, _this.timestamp, _this._metadataTableIsValid));
                    }); }, function (sqlError) {
                        reportSQLError('Failed to open read transaction for the webSQL database.', sqlError);
                        callback(new WebSQLShadow(_this._db, _this.timestamp, _this._metadataTableIsValid));
                    });
                };
                WebSQLDetached.prototype.purge = function (callback) {
                    var _this = this;
                    this._db.transaction(function (transaction) { return listAllTables(transaction, function (tables) {
                        _this._purgeWithTables(transaction, tables, callback);
                    }, function (sqlError) {
                        reportSQLError('Failed to list tables for the webSQL database.', sqlError);
                        callback(new WebSQLShadow(_this._db, 0, false));
                    }); }, function (sqlError) {
                        reportSQLError('Failed to open read-write transaction for the webSQL database.', sqlError);
                        callback(new WebSQLShadow(_this._db, 0, false));
                    });
                };
                WebSQLDetached.prototype._applyToWithFiles = function (transaction, ftab, mainDrive, callback) {
                    var _this = this;
                    if (!ftab.length) {
                        callback(new WebSQLShadow(this._db, this.timestamp, this._metadataTableIsValid));
                        return;
                    }
                    var reportedFileCount = 0;
                    var completeOne = function () {
                        reportedFileCount++;
                        if (reportedFileCount === ftab.length) {
                            callback(new WebSQLShadow(_this._db, _this.timestamp, _this._metadataTableIsValid));
                        }
                    };
                    var applyFile = function (file, table) {
                        transaction.executeSql('SELECT * FROM "' + table + '"', [], function (transaction, result) {
                            if (result.rows.length) {
                                var row = result.rows.item(0);
                                if (row.value === null)
                                    mainDrive.write(file, null);
                                else if (typeof row.value === 'string')
                                    mainDrive.write(file, fromSqlText(row.value));
                            }
                            completeOne();
                        }, function (sqlError) {
                            completeOne();
                        });
                    };
                    for (var i = 0; i < ftab.length; i++) {
                        applyFile(ftab[i].file, ftab[i].table);
                    }
                };
                WebSQLDetached.prototype._purgeWithTables = function (transaction, tables, callback) {
                    var _this = this;
                    if (!tables.length) {
                        callback(new WebSQLShadow(this._db, 0, false));
                        return;
                    }
                    var droppedCount = 0;
                    var completeOne = function () {
                        droppedCount++;
                        if (droppedCount === tables.length) {
                            callback(new WebSQLShadow(_this._db, 0, false));
                        }
                    };
                    for (var i = 0; i < tables.length; i++) {
                        transaction.executeSql('DROP TABLE "' + tables[i] + '"', [], function (transaction, result) {
                            completeOne();
                        }, function (transaction, sqlError) {
                            reportSQLError('Failed to drop table for the webSQL database.', sqlError);
                            completeOne();
                        });
                    }
                };
                return WebSQLDetached;
            })();
            var WebSQLShadow = (function () {
                function WebSQLShadow(_db, timestamp, _metadataTableIsValid) {
                    var _this = this;
                    this._db = _db;
                    this.timestamp = timestamp;
                    this._metadataTableIsValid = _metadataTableIsValid;
                    this._cachedUpdateStatementsByFile = {};
                    this._closures = {
                        updateMetadata: function (transaction) { return _this._updateMetadata(transaction); }
                    };
                }
                WebSQLShadow.prototype.write = function (file, content) {
                    if (content || typeof content === 'string') {
                        this._updateCore(file, content);
                    }
                    else {
                        this._dropFileTable(file);
                    }
                };
                WebSQLShadow.prototype._updateCore = function (file, content) {
                    var _this = this;
                    var updateSQL = this._cachedUpdateStatementsByFile[file];
                    if (!updateSQL) {
                        var tableName = mangleDatabaseObjectName(file);
                        updateSQL = this._createUpdateStatement(file, tableName);
                    }
                    this._db.transaction(function (transaction) {
                        transaction.executeSql(updateSQL, ['content', content], _this._closures.updateMetadata, function (transaction, sqlError) { return _this._createTableAndUpdate(transaction, file, tableName, updateSQL, content); });
                    }, function (sqlError) {
                        reportSQLError('Transaction failure updating file "' + file + '".', sqlError);
                    });
                };
                WebSQLShadow.prototype._createTableAndUpdate = function (transaction, file, tableName, updateSQL, content) {
                    var _this = this;
                    if (!tableName)
                        tableName = mangleDatabaseObjectName(file);
                    transaction.executeSql('CREATE TABLE "' + tableName + '" (name PRIMARY KEY, value)', [], function (transaction, result) {
                        transaction.executeSql(updateSQL, ['content', content], _this._closures.updateMetadata, function (transaction, sqlError) {
                            reportSQLError('Failed to update table "' + tableName + '" for file "' + file + '" after creation.', sqlError);
                        });
                    }, function (transaction, sqlError) {
                        reportSQLError('Failed to create a table "' + tableName + '" for file "' + file + '".', sqlError);
                    });
                };
                WebSQLShadow.prototype._dropFileTable = function (file) {
                    var _this = this;
                    var tableName = mangleDatabaseObjectName(file);
                    this._db.transaction(function (transaction) {
                        transaction.executeSql('DROP TABLE "' + tableName + '"', [], _this._closures.updateMetadata, function (transaction, sqlError) {
                            reportSQLError('Failed to drop table "' + tableName + '" for file "' + file + '".', sqlError);
                        });
                    }, function (sqlError) {
                        reportSQLError('Transaction failure dropping table "' + tableName + '" for file "' + file + '".', sqlError);
                    });
                };
                WebSQLShadow.prototype._updateMetadata = function (transaction) {
                    var updateMetadataSQL = 'INSERT OR REPLACE INTO "*metadata" VALUES (?,?)';
                    transaction.executeSql(updateMetadataSQL, ['editedUTC', this.timestamp], function (transaction, result) { }, function (transaction, error) {
                        transaction.executeSql('CREATE TABLE "*metadata" (name PRIMARY KEY, value)', [], function (transaction, result) {
                            transaction.executeSql(updateMetadataSQL, [], function () { }, function () { });
                        }, function (transaction, sqlError) {
                            reportSQLError('Failed to update metadata table after creation.', sqlError);
                        });
                    });
                };
                WebSQLShadow.prototype._createUpdateStatement = function (file, tableName) {
                    return this._cachedUpdateStatementsByFile[file] =
                        'INSERT OR REPLACE INTO "' + tableName + '" VALUES (?,?)';
                };
                return WebSQLShadow;
            })();
            function mangleDatabaseObjectName(name) {
                // no need to polyfill btoa, if webSQL exists
                if (name.toLowerCase() === name)
                    return name;
                else
                    return '=' + btoa(name);
            }
            function unmangleDatabaseObjectName(name) {
                if (!name || name.charAt(0) === '*')
                    return null;
                if (name.charAt(0) !== '=')
                    return name;
                try {
                    return atob(name.slice(1));
                }
                catch (error) {
                    return name;
                }
            }
            function listAllTables(transaction, callback, errorCallback) {
                transaction.executeSql('SELECT tbl_name  from sqlite_master WHERE type=\'table\'', [], function (transaction, result) {
                    var tables = [];
                    for (var i = 0; i < result.rows.length; i++) {
                        var row = result.rows.item(i);
                        var table = row.tbl_name;
                        if (!table || (table[0] !== '*' && table.charAt(0) !== '=' && table.charAt(0) !== '/'))
                            continue;
                        tables.push(row.tbl_name);
                    }
                    callback(tables);
                }, function (transaction, sqlError) { return errorCallback(sqlError); });
            }
            webSQL.listAllTables = listAllTables;
            function getFilenamesFromTables(tables) {
                var filenames = [];
                for (var i = 0; i < tables.length; i++) {
                    var file = unmangleDatabaseObjectName(tables[i]);
                    if (file)
                        filenames.push({ table: tables[i], file: file });
                }
                return filenames;
            }
            function toSqlText(text) {
                if (text.indexOf('\u00FF') < 0 && text.indexOf('\u0000') < 0)
                    return text;
                return text.replace(/\u00FF/g, '\u00FFf').replace(/\u0000/g, '\u00FF0');
            }
            function fromSqlText(sqlText) {
                if (sqlText.indexOf('\u00FF') < 0 && sqlText.indexOf('\u0000') < 0)
                    return sqlText;
                return sqlText.replace(/\u00FFf/g, '\u00FF').replace(/\u00FF0/g, '\u0000');
            }
            function reportSQLError(message, sqlError) {
                if (typeof console !== 'undefined' && typeof console.error === 'function') {
                    if (sqlError)
                        console.error(message, sqlError);
                    else
                        console.error(sqlError);
                }
            }
        })(webSQL = attached.webSQL || (attached.webSQL = {}));
    })(attached = persistence.attached || (persistence.attached = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function bestEncode(content, escapePath) {
        if (content.length > 1024 * 16) {
        }
        if (typeof content !== 'string')
            return { content: encodeArrayOrSimilarAsJSON(content), encoding: 'json' };
        var needsEscaping;
        if (escapePath) {
            // zero-char, newlines, leading/trailing spaces, quote and apostrophe
            needsEscaping = /\u0000|\r|\n|^\s|\s$|\"|\'/.test(content);
        }
        else {
            needsEscaping = /\u0000|\r/.test(content);
        }
        if (needsEscaping) {
            // ZERO character is officially unsafe in HTML,
            // CR is contentious in IE (which converts any CR or LF into CRLF)
            return { content: encodeUnusualStringAsJSON(content), encoding: 'json' };
        }
        else {
            return { content: content, encoding: 'LF' };
        }
    }
    persistence.bestEncode = bestEncode;
    function encodeUnusualStringAsJSON(content) {
        if (typeof JSON !== 'undefined' && typeof JSON.stringify === 'function') {
            var simpleJSON = JSON.stringify(content);
            var sanitizedJSON = simpleJSON.
                replace(/\u0000/g, '\\u0000').
                replace(/\r/g, '\\r').
                replace(/\n/g, '\\n');
            return sanitizedJSON;
        }
        else {
            var result = content.replace(/\"\u0000|\u0001|\u0002|\u0003|\u0004|\u0005|\u0006|\u0007|\u0008|\u0009|\u00010|\u00011|\u00012|\u00013|\u00014|\u00015|\u0016|\u0017|\u0018|\u0019|\u0020|\u0021|\u0022|\u0023|\u0024|\u0025|\u0026|\u0027|\u0028|\u0029|\u0030|\u0031/g, function (chr) {
                return chr === '\t' ? '\\t' :
                    chr === '\r' ? '\\r' :
                        chr === '\n' ? '\\n' :
                            chr === '\"' ? '\\"' :
                                chr < '\u0010' ? '\\u000' + chr.charCodeAt(0).toString(16) :
                                    '\\u00' + chr.charCodeAt(0).toString(16);
            });
            return result;
        }
    }
    function encodeArrayOrSimilarAsJSON(content) {
        var type = content instanceof Array ? null : content.constructor.name || content.type;
        if (typeof JSON !== 'undefined' && typeof JSON.stringify === 'function') {
            if (type) {
                var wrapped = { type: type, content: content };
                var wrappedJSON = JSON.stringify(wrapped);
                return wrappedJSON;
            }
            else {
                var contentJSON = JSON.stringify(content);
                return contentJSON;
            }
        }
        else {
            var jsonArr = [];
            if (type) {
                jsonArr.push('{"type": "');
                jsonArr.push(content.type || content.prototype.constructor.name);
                jsonArr.push('", "content": [');
            }
            else {
                jsonArr.push('[');
            }
            for (var i = 0; i < content.length; i++) {
                if (i)
                    jsonArr.push(',');
                jsonArr.push(content[i]);
            }
            if (type)
                jsonArr.push(']}');
            else
                jsonArr.push(']');
            return jsonArr.join('');
        }
    }
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    // TODO: pass in progress callback
    function bootMount(uniqueKey, document) {
        var continueParse;
        var ondomdriveloaded;
        var domDriveLoaded;
        var storedFinishCallback;
        persistence.mountDrive(function (callback) {
            if (domDriveLoaded)
                callback(domDriveLoaded);
            else
                ondomdriveloaded = callback;
        }, uniqueKey, [persistence.attached.indexedDB, persistence.attached.webSQL, persistence.attached.localStorage], function (mountedDrive) {
            storedFinishCallback(mountedDrive);
        });
        return continueLoading();
        function continueLoading() {
            continueDOMLoading();
            // TODO: record progress
            return {
                continueLoading: continueLoading,
                finishLoading: finishLoading,
                loadedFileCount: continueParse.loadedFileCount,
                loadedSize: continueParse.loadedSize,
                totalSize: continueParse.totalSize
            };
        }
        function finishLoading(finishCallback) {
            storedFinishCallback = finishCallback;
            continueDOMLoading();
            domDriveLoaded = continueParse.finishParsing();
            if (ondomdriveloaded) {
                ondomdriveloaded(domDriveLoaded);
            }
        }
        function continueDOMLoading() {
            continueParse = continueParse ? continueParse.continueParsing() : persistence.dom.parseDOMStorage(document);
        }
    }
    persistence.bootMount = bootMount;
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        var CommentHeader = (function () {
            function CommentHeader(node) {
                this.node = node;
                var headerLine;
                var content;
                if (typeof node.substringData === 'function'
                    && typeof node.length === 'number') {
                    var chunkSize = 128;
                    if (node.length >= chunkSize) {
                        // TODO: cut chunks off the start and look for newlines
                        var headerChunks = [];
                        while (headerChunks.length * chunkSize < node.length) {
                            var nextChunk = node.substringData(headerChunks.length * chunkSize, chunkSize);
                            var posEOL = nextChunk.search(/\r|\n/);
                            if (posEOL < 0) {
                                headerChunks.push(nextChunk);
                                continue;
                            }
                            this.header = headerChunks.join('') + nextChunk.slice(0, posEOL);
                            this.contentOffset = this.header.length + 1; // if header is separated by a single CR or LF
                            if (posEOL === nextChunk.length - 1) {
                                if (nextChunk.charAt(nextChunk.length - 1) === '\r'
                                    && node.substringData((headerChunks.length + 1) * chunkSize, 1) === '\n')
                                    this.contentOffset++;
                            }
                            else if (nextChunk.slice(posEOL, posEOL + 2) === '\r\n') {
                                this.contentOffset++;
                            }
                            this.contentLength = node.length - this.contentOffset;
                            return;
                        }
                        this.header = headerChunks.join('');
                        this.contentOffset = this.header.length;
                        this.contentLength = node.length - content.length;
                        return;
                    }
                }
                var wholeCommentText = node.nodeValue;
                var posEOL = wholeCommentText.search(/\r|\n/);
                if (posEOL < 0) {
                    this.header = wholeCommentText;
                    this.contentOffset = wholeCommentText.length;
                    this.contentLength = wholeCommentText.length - this.contentOffset;
                    return;
                }
                this.contentOffset = wholeCommentText.slice(posEOL, posEOL + 2) === '\r\n' ?
                    posEOL + 2 :
                    posEOL + 1; // ends with singular CR or LF
                this.header = wholeCommentText.slice(0, posEOL),
                    this.contentLength = wholeCommentText.length - this.contentOffset;
            }
            return CommentHeader;
        })();
        dom.CommentHeader = CommentHeader;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        var DOMDrive = (function () {
            function DOMDrive(_totals, files, _document) {
                this._totals = _totals;
                this._document = _document;
                this._byPath = {};
                this.timestamp = this._totals ? this._totals.timestamp : 0;
                for (var i = 0; i < files.length; i++) {
                    this._byPath[files[i].path] = files[i];
                }
            }
            DOMDrive.prototype.files = function () {
                if (typeof Object.keys === 'string') {
                    var result = Object.keys(this._byPath);
                }
                else {
                    var result = [];
                    for (var k in this._byPath)
                        if (this._byPath.hasOwnProperty(k)) {
                            result.push(k);
                        }
                }
                result.sort();
                return result;
            };
            DOMDrive.prototype.read = function (file) {
                var file = persistence.normalizePath(file);
                var f = this._byPath[file];
                if (!f)
                    return null;
                else
                    return f.read();
            };
            DOMDrive.prototype.write = function (file, content) {
                var totalDelta = 0;
                var file = persistence.normalizePath(file);
                var f = this._byPath[file];
                if (content === null) {
                    // removal
                    if (f) {
                        totalDelta -= f.contentLength;
                        f.node.parentElement.removeChild(f.node);
                        delete this._byPath[file];
                    }
                }
                else {
                    // addition
                    if (f) {
                        var lengthBefore = f.contentLength;
                        f.write(content);
                        totalDelta += f.contentLength - lengthBefore;
                    }
                    else {
                        var comment = document.createComment('');
                        var f = new dom.DOMFile(comment, file, null, 0, 0);
                        f.write(content);
                        this._document.body.appendChild(f.node);
                        this._byPath[file] = f;
                        totalDelta += f.contentLength;
                    }
                }
                this._totals.timestamp = this.timestamp;
                this._totals.updateNode();
            };
            return DOMDrive;
        })();
        dom.DOMDrive = DOMDrive;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        var DOMFile = (function () {
            function DOMFile(node, path, _encoding, _contentOffset, contentLength) {
                this.node = node;
                this.path = path;
                this._encoding = _encoding;
                this._contentOffset = _contentOffset;
                this.contentLength = contentLength;
                this._encodedPath = null;
            }
            DOMFile.tryParse = function (cmheader) {
                //    /file/path/continue
                //    "/file/path/continue"
                //    /file/path/continue   [encoding]
                var parseFmt = /^\s*((\/|\"\/)(\s|\S)*[^\]])\s*(\[((\s|\S)*)\])?\s*$/;
                var parsed = parseFmt.exec(cmheader.header);
                if (!parsed)
                    return null; // does not match the format
                var filePath = parsed[1];
                var encodingName = parsed[5];
                if (filePath.charAt(0) === '"') {
                    if (filePath.charAt(filePath.length - 1) !== '"')
                        return null; // unpaired leading quote
                    try {
                        if (typeof JSON !== 'undefined' && typeof JSON.parse === 'function')
                            filePath = JSON.parse(filePath);
                        else
                            filePath = eval(filePath); // security doesn't seem to be compromised, input is coming from the same file
                    }
                    catch (parseError) {
                        return null; // quoted path but wrong format (JSON expected)
                    }
                }
                else {
                    if (encodingName) {
                        // regex above won't strip trailing whitespace from filePath if encoding is specified
                        // (because whitespace matches 'non-bracket' class too)
                        filePath = filePath.slice(0, filePath.search(/\S(\s*)$/) + 1);
                    }
                }
                var encoding = persistence.encodings[encodingName || 'LF'];
                // invalid encoding considered a bogus comment, skipped
                if (encoding)
                    return new DOMFile(cmheader.node, filePath, encoding, cmheader.contentOffset, cmheader.contentLength);
                return null;
            };
            DOMFile.prototype.read = function () {
                // proper HTML5 has substringData to read only a chunk
                // (that saves on string memory allocations
                // comparing to fetching the whole text including the file name)
                var contentText = typeof this.node.substringData === 'function' ?
                    this.node.substringData(this._contentOffset, 1000000000) :
                    this.node.nodeValue.slice(this._contentOffset);
                // XML end-comment is escaped when stored in DOM,
                // unescape it back
                var restoredText = contentText.
                    replace(/\-\-\*(\**)\>/g, '--$1>').
                    replace(/\<\*(\**)\!/g, '<$1!');
                // decode
                var decodedText = this._encoding(restoredText);
                // update just in case it's been off
                this.contentLength = decodedText.length;
                return decodedText;
            };
            DOMFile.prototype.write = function (content) {
                var encoded = persistence.bestEncode(content);
                var protectedText = encoded.content.
                    replace(/\-\-(\**)\>/g, '--*$1>').
                    replace(/\<(\**)\!/g, '<*$1!');
                if (!this._encodedPath) {
                    // most cases path is path,
                    // but if anything is weird, it's going to be quoted
                    // (actually encoded with JSON format)
                    var encp = persistence.bestEncode(this.path, true /*escapePath*/);
                    this._encodedPath = encp.content;
                }
                var leadText = ' ' + this._encodedPath + (encoded.encoding === 'LF' ? '' : ' [' + encoded.encoding + ']') + '\n';
                this.node.nodeValue = leadText + encoded.content;
                this._encoding = persistence.encodings[encoded.encoding || 'LF'];
                this._contentOffset = leadText.length;
                this.contentLength = content.length;
            };
            return DOMFile;
        })();
        dom.DOMFile = DOMFile;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        var monthsPrettyCase = ('Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec').split('|');
        var monthsUpperCase = ('Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec').toUpperCase().split('|');
        var DOMTotals = (function () {
            function DOMTotals(timestamp, totalSize, _node) {
                this.timestamp = timestamp;
                this.totalSize = totalSize;
                this._node = _node;
            }
            DOMTotals.tryParse = function (cmheader) {
                // TODO: preserve unknowns when parsing
                var parts = cmheader.header.split(',');
                var anythingParsed = false;
                var totalSize = 0;
                var timestamp = 0;
                for (var i = 0; i < parts.length; i++) {
                    // total 234Kb
                    // total 23
                    // total 6Mb
                    var totalFmt = /^\s*total\s+(\d*)\s*([KkMm])?b?\s*$/;
                    var totalMatch = totalFmt.exec(parts[i]);
                    if (totalMatch) {
                        try {
                            var total = parseInt(totalMatch[1]);
                            if ((totalMatch[2] + '').toUpperCase() === 'K')
                                total *= 1024;
                            else if ((totalMatch[2] + '').toUpperCase() === 'M')
                                total *= 1024 * 1024;
                            totalSize = total;
                            anythingParsed = true;
                        }
                        catch (totalParseError) { }
                        continue;
                    }
                    var savedFmt = /^\s*saved\s+(\d+)\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+)\s+(\d+)\:(\d+)(\:(\d+(\.(\d+))?))\s*(GMT\s*[\-\+]?\d+\:?\d*)?\s*$/i;
                    var savedMatch = savedFmt.exec(parts[i]);
                    if (savedMatch) {
                        // 25 Apr 2015 22:52:01.231
                        try {
                            var savedDay = parseInt(savedMatch[1]);
                            var savedMonth = monthsUpperCase.indexOf(savedMatch[2].toUpperCase());
                            var savedYear = parseInt(savedMatch[3]);
                            if (savedYear < 100)
                                savedYear += 2000; // no 19xx notation anymore :-(
                            var savedHour = parseInt(savedMatch[4]);
                            var savedMinute = parseInt(savedMatch[5]);
                            var savedSecond = savedMatch[7] ? parseFloat(savedMatch[7]) : 0;
                            timestamp = new Date(savedYear, savedMonth, savedDay, savedHour, savedMinute, savedSecond | 0).valueOf();
                            timestamp += (savedSecond - (savedSecond | 0)) * 1000; // milliseconds
                            var savedGMTStr = savedMatch[10];
                            if (savedGMTStr) {
                                var gmtColonPos = savedGMTStr.indexOf(':');
                                if (gmtColonPos > 0) {
                                    var gmtH = parseInt(savedGMTStr.slice(0, gmtColonPos));
                                    timestamp += gmtH * 60 /*min*/ * 60 /*sec*/ * 1000 /*msec*/;
                                    var gmtM = parseInt(savedGMTStr.slice(gmtColonPos + 1));
                                    timestamp += gmtM * 60 /*sec*/ * 1000 /*msec*/;
                                }
                            }
                            anythingParsed = true;
                        }
                        catch (savedParseError) { }
                    }
                }
                if (anythingParsed)
                    return new DOMTotals(timestamp, totalSize, cmheader.node);
                else
                    return null;
            };
            DOMTotals.prototype.updateNode = function () {
                // TODO: update the node content
                // total 4Kb, saved 25 Apr 2015 22:52:01.231
                var newTotals = 'total ' + (this.totalSize < 1024 * 9 ? this.totalSize + '' :
                    this.totalSize < 1024 * 1024 * 9 ? ((this.totalSize / 1024) | 0) + 'Kb' :
                        ((this.totalSize / (1024 * 1024)) | 0) + 'Mb') + ', ' +
                    'saved ';
                var saveDate = new Date(this.timestamp);
                newTotals +=
                    saveDate.getDate() + ' ' +
                        monthsPrettyCase[saveDate.getMonth()] + ' ' +
                        saveDate.getFullYear() + ' ' +
                        num2(saveDate.getHours()) + ':' +
                        num2(saveDate.getMinutes()) + ':' +
                        num2(saveDate.getSeconds()) + '.' +
                        this.timestamp.toString().slice(-3);
                var saveDateLocalStr = saveDate.toString();
                var gmtMatch = (/(GMT\s*[\-\+]\d+(\:\d+)?)/i).exec(saveDateLocalStr);
                if (gmtMatch)
                    newTotals += ' ' + gmtMatch[1];
                this._node.nodeValue = newTotals;
                function num2(n) {
                    return n <= 9 ? '0' + n : '' + n;
                }
            };
            return DOMTotals;
        })();
        dom.DOMTotals = DOMTotals;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        function parseDOMStorage(document) {
            var loadedFiles = [];
            var loadedTotals;
            var lastNode;
            var loadedSize = 0;
            return continueParsing();
            function continueParsing() {
                continueParsingDOM(false);
                return {
                    continueParsing: continueParsing,
                    finishParsing: finishParsing,
                    loadedSize: loadedSize,
                    totalSize: loadedTotals ? loadedTotals.totalSize : 0,
                    loadedFileCount: loadedFiles.length
                };
            }
            function finishParsing() {
                continueParsingDOM(true);
                if (loadedTotals) {
                    loadedTotals.totalSize = loadedSize;
                    loadedTotals.updateNode();
                }
                var drive = new dom.DOMDrive(loadedTotals, loadedFiles, document);
                return drive;
            }
            function continueParsingDOM(finish) {
                if (document.body) {
                    if (!lastNode)
                        lastNode = document.body.firstChild;
                    while (true) {
                        if (!lastNode)
                            return;
                        else if (!finish && lastNode == document.body.lastChild)
                            return;
                        if (lastNode.nodeType === 8) {
                            processNode(lastNode);
                        }
                        lastNode = lastNode.nextSibling;
                    }
                }
            }
            function processNode(node) {
                var cmheader = new dom.CommentHeader(node);
                var file = dom.DOMFile.tryParse(cmheader);
                if (file) {
                    loadedFiles.push(file);
                    loadedSize += file.contentLength;
                    return true;
                }
                var totals = dom.DOMTotals.tryParse(cmheader);
                if (totals)
                    loadedTotals = totals;
            }
        }
        dom.parseDOMStorage = parseDOMStorage;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function CR(text) {
            return text.
                replace(/\r\n|\n/g, '\r');
        }
        encodings.CR = CR;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function CRLF(text) {
            return text.
                replace(/\r|\n/g, '\r\n');
        }
        encodings.CRLF = CRLF;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function LF(text) {
            return text.
                replace(/\r\n|\r/g, '\n');
        }
        encodings.LF = LF;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function base64(text) {
            // TODO: convert from base64 to text
            // TODO: invent a prefix to signify binary data
            throw new Error('Base64 encoding is not implemented yet.');
        }
        encodings.base64 = base64;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function eval(text) {
            return (0, window['eval'])(text);
        }
        encodings.eval = eval;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function json(text) {
            var result = typeof JSON === 'undefined' ? encodings.eval(text) : JSON.parse(text);
            if (result && typeof result !== 'string' && result.type) {
                var ctor = window[result.type];
                result = new ctor(result);
            }
            return result;
        }
        encodings.json = json;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function mountDrive(loadDOMDrive, uniqueKey, optionalModules, callback) {
        var driveIndex = 0;
        loadNextOptional();
        function loadNextOptional() {
            while (driveIndex < optionalModules.length &&
                (!optionalModules[driveIndex] || typeof optionalModules[driveIndex].detect !== 'function')) {
                driveIndex++;
            }
            if (driveIndex >= optionalModules.length) {
                loadDOMDrive(function (dom) { return callback(new MountedDrive(dom, null)); });
                return;
            }
            var op = optionalModules[driveIndex];
            op.detect(uniqueKey, function (detached) {
                if (!detached) {
                    driveIndex++;
                    loadNextOptional();
                    return;
                }
                loadDOMDrive(function (dom) {
                    if (detached.timestamp > dom.timestamp) {
                        var callbackWithShadow = function (loadedDrive) {
                            dom.timestamp = detached.timestamp;
                            callback(new MountedDrive(dom, loadedDrive));
                        };
                        if (callback.progress)
                            callbackWithShadow.progress = callback.progress;
                        loadDOMDrive(function (dom) { return detached.applyTo(dom, callbackWithShadow); });
                    }
                    else {
                        var callbackWithShadow = function (loadedDrive) {
                            callback(new MountedDrive(dom, loadedDrive));
                        };
                        if (callback.progress)
                            callbackWithShadow.progress = callback.progress;
                        detached.purge(callbackWithShadow);
                    }
                });
            });
        }
    }
    persistence.mountDrive = mountDrive;
    var MountedDrive = (function () {
        function MountedDrive(_dom, _shadow) {
            this._dom = _dom;
            this._shadow = _shadow;
            this.updateTime = true;
            this.timestamp = 0;
            this.timestamp = this._dom.timestamp;
        }
        MountedDrive.prototype.files = function () {
            return this._dom.files();
        };
        MountedDrive.prototype.read = function (file) {
            return this._dom.read(file);
        };
        MountedDrive.prototype.write = function (file, content) {
            if (this.updateTime) {
                this.timestamp = +new Date();
            }
            this._dom.timestamp = this.timestamp;
            this._dom.write(file, content);
            if (this._shadow) {
                this._shadow.timestamp = this.timestamp;
                this._shadow.write(file, content);
            }
        };
        return MountedDrive;
    })();
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function normalizePath(path) {
        if (!path)
            return '/'; // empty paths converted to root
        if (path.charAt(0) !== '/')
            path = '/' + path;
        path = path.replace(/\/\/*/g, '/'); // replacing duplicate slashes with single
        return path;
    }
    persistence.normalizePath = normalizePath;
})(persistence || (persistence = {}));

//# sourceURL=/load/shellLoader.ts.js
</script>

<!--total 45Mb, saved 31 Jul 2015 02:26:21.333 GMT+0100-->

<!-- /shell/showCommander.js
var isolation;
(function (isolation) {
    var Context = (function () {
        function Context(_window) {
            this._window = _window;
            this._obscureScope = {};
            this._disposed = false;
            this._frame = createFrame(this._window);
            defineObscureScope(this._obscureScope, this._frame.global);
            defineObscureScope(this._obscureScope, this._frame.window);
            this._obscureScope.global = void 0;
            var setGlobal = this._frame.evalFN('(function() { return function(global) { window.global = global; }; })()');
            setGlobal(this._obscureScope);
        }
        Context.prototype.run = function (code, path, scope) {
            path = path || typeof path === 'string' ? path : createTimebasedPath();
            this._obscureScope.global = scope || {};
            var decoratedCode = 'with(window.global){with(global){   ' + code +
                '\n }}  //# sourceURL=' + path;
            var result = this._frame.evalFN(decoratedCode);
            this._obscureScope.global = null;
            return result;
        };
        Context.prototype.dispose = function () {
            if (!this._disposed) {
                document.body.removeChild(this._frame.iframe);
                this._disposed = true;
            }
        };
        return Context;
    })();
    isolation.Context = Context;
    function createTimebasedPath() {
        var now = new Date();
        var path = now.getFullYear() +
            (now.getMonth() + 1 > 9 ? '' : '0') + now.getMonth() +
            (now.getDate() > 9 ? '' : '0') + now.getDate() + '-' +
            (now.getHours() > 9 ? '' : '0') + now.getHours() +
            (now.getMinutes() > 9 ? '' : '0') + now.getMinutes() + '-' +
            (now.getSeconds() > 9 ? '' : '0') + now.getSeconds() +
            '.' + ((now.getMilliseconds() | 0) + 1000).toString().slice(1) +
            '.js';
        return path;
    }
    function createFrame(window) {
        var ifr = window.document.createElement('iframe');
        ifr.style.display = 'none';
        window.document.body.appendChild(ifr);
        var ifrwin = ifr.contentWindow || ifr.window;
        var ifrdoc = ifrwin.document;
        if (ifrdoc.open)
            ifrdoc.open();
        ifrdoc.write('<!' + 'doctype html' + '>' +
            '<' + 'html' + '><' + 'body' + '>' +
            '<' + 'script' + '>window.__eval_export_=function(code) { return eval(code); }</' + 'script' + '>' +
            '<' + 'body' + '></' + 'html' + '>');
        if (ifrdoc.close)
            ifrdoc.close();
        var ifrwin_eval = ifrwin.__eval_export_;
        try {
            delete ifrwin.__eval_export_;
        }
        catch (weirdIEFailure) {
        }
        ifrdoc.body.innerHTML = '';
        return {
            document: ifrdoc,
            window: ifrwin,
            global: ifrwin_eval('this'),
            iframe: ifr,
            evalFN: ifrwin_eval
        };
    }
    function defineObscureScope(scope, pollutedGlobal) {
        var natives = defineAllowedNatives();
        var dummy;
        // normal properties
        for (var k in pollutedGlobal) {
            if (scope[k] || natives[k])
                continue;
            scope[k] = dummy;
        }
        // non-enumerable properties directly on global
        if (Object.getOwnPropertyNames) {
            var props = Object.getOwnPropertyNames(pollutedGlobal);
            for (var i = 0; i < props.length; i++) {
                if (scope[props[i]] || natives[props[i]])
                    continue;
                scope[props[i]] = dummy;
            }
            // non-enumerable properties on global's prototype
            if (pollutedGlobal.constructor
                && pollutedGlobal.constructor.prototype
                && pollutedGlobal.constructor.prototype !== Object.prototype) {
                props = Object.getOwnPropertyNames(pollutedGlobal.constructor.prototype);
                for (var i = 0; i < props.length; i++) {
                    if (scope[props[i]] || natives[props[i]])
                        continue;
                    scope[props[i]] = dummy;
                }
            }
        }
    }
    var allowedNatives = null;
    function defineAllowedNatives() {
        return {
            setTimeout: 1, setInterval: 1, clearTimeout: 1, clearInterval: 1,
            eval: 1,
            console: 1,
            undefined: 1,
            Object: 1, Array: 1, Date: 1, Function: 1, String: 1, Boolean: 1, Number: 1,
            Infinity: 1, NaN: 1, isNaN: 1, isFinite: 1, parseInt: 1, parseFloat: 1,
            escape: 1, unescape: 1,
            Int32Array: 1, Int8Array: 1, Int16Array: 1,
            UInt32Array: 1, UInt8Array: 1, UInt8ClampedArray: 1, UInt16Array: 1,
            Float32Array: 1, Float64Array: 1, ArrayBuffer: 1,
            Math: 1, JSON: 1, RegExp: 1,
            Error: 1, SyntaxError: 1, EvalError: 1, RangeError: 1, ReferenceError: 1,
            toString: 1, toJSON: 1, toValue: 1,
            Map: 1, Promise: 1
        };
    }
})(isolation || (isolation = {}));
var noapi;
(function (noapi) {
    var HostedProcess = (function () {
        function HostedProcess(options) {
            var _this = this;
            this.exitCode = null;
            this.finished = false;
            this._waitFor = 0;
            this.global = {};
            this.coreModules = {
                fs: null,
                os: null,
                path: null
            };
            var noopt = {
                argv: options.argv || ['/node', options.scriptPath],
                cwd: options.cwd,
                env: options.env || {}
            };
            this._scriptPath = options.scriptPath;
            this._drive = options.drive;
            if (!noopt.cwd)
                noopt.cwd = noapi.dirname(options.scriptPath);
            this.global.process = this.process = noapi.createProcess(this.coreModules, noopt);
            this.global.module = this.mainModule = noapi.createModule('repl' /*id*/, null /*filename*/, null /*parent*/, require);
            var noapicontext = this;
            function require(moduleName) { return noapicontext.requireModule(moduleName, noapi.dirname(options.scriptPath), null); }
            this.global.require = (function (moduleName) { return require(moduleName); });
            this.global.require.resolve = function (id) { return _this.resolve(id, noopt.cwd); };
            this.global.__filename = options.scriptPath;
            this.global.__dirname = noapi.dirname(options.scriptPath);
            if (options.console)
                this.global.console = options.console;
            this._console = options.console;
            this.coreModules.fs = noapi.createFS(options.drive, this.coreModules);
            this.coreModules.os = noapi.createOS(this.global);
            this.coreModules.path = noapi.createPath(this.global);
            this._context = new isolation.Context(window);
            this.process.exit = function (code) {
                _this.finished = true;
                _this.exitCode = code || 0;
                _this.dispose();
            };
            this.process.abort = function () {
                _this.finished = true;
                _this.dispose();
            };
            var timeouts = [];
            this.global.setTimeout = function (fun, time) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                if (_this.finished)
                    return 0;
                var wait = _this.keepAlive();
                var complete = function () {
                    delete timeouts[result];
                    wait();
                    fun();
                };
                var passArgs = [];
                passArgs.push(complete);
                passArgs.push(time);
                for (var i = 0; i < args.length; i++) {
                    passArgs.push(args[i]);
                }
                var result = setTimeout.apply(_this.global, passArgs);
                timeouts[result] = wait;
                return result;
            };
            this.global.clearTimeout = function (tout) {
                var wait = timeouts[tout];
                if (wait)
                    wait();
                delete timeouts[tout];
                clearTimeout(tout);
            };
            var intervals = [];
            this.global.setInterval = function (fun, time) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                if (_this.finished)
                    return 0;
                var wait = _this.keepAlive();
                var passArgs = [];
                passArgs.push(fun);
                passArgs.push(time);
                for (var i = 0; i < args.length; i++) {
                    passArgs.push(args[i]);
                }
                var result = setInterval.apply(_this.global, passArgs);
                intervals[result] = wait;
                return result;
            };
            this.global.clearInterval = function (intv) {
                var wait = intervals[intv];
                if (wait)
                    wait();
                delete intervals[intv];
                clearTimeout(intv);
            };
            this.process.nextTick = function (fun) {
                var wait = _this.keepAlive();
                setTimeout(function () {
                    wait();
                    fun();
                }, 1);
            };
        }
        HostedProcess.prototype.eval = function (code) {
            var wait = this.keepAlive();
            try {
                return this._context.run(code, this._scriptPath, this.global);
            }
            finally {
                wait();
            }
        };
        HostedProcess.prototype.resolve = function (id, modulePath) {
            if (id.charAt(0) === '.') {
                return this.coreModules.path.join(modulePath, id);
            }
            else if (id.charAt(0) === '/') {
                return id;
            }
            else {
                var tryPath = this.coreModules.path.normalize(modulePath);
                var probePatterns = [
                    '../' + i, '../' + id + '.js', '../' + id + '/index.js',
                    '../node_modules/' + id + '/index.js'];
                while (true) {
                    tryPath = this.coreModules.path.basename(tryPath);
                    if (!tryPath || tryPath === '/')
                        return null;
                    for (var i = 0; i < probePatterns.length; i++) {
                        var p = this.coreModules.path.join(tryPath, probePatterns[i]);
                        if (this._drive.read(p))
                            return p;
                    }
                }
            }
        };
        HostedProcess.prototype.requireModule = function (moduleName, parentModulePath, parentModule) {
            var _this = this;
            if (this.coreModules.hasOwnProperty(moduleName))
                return this.coreModules[moduleName];
            var resolvedPath = this.resolve(moduleName, parentModulePath);
            if (resolvedPath) {
                var content = this._drive.read(resolvedPath);
                if (content) {
                    var loadedModule = noapi.createModule(moduleName, resolvedPath, parentModule, function (moduleName) { return _this.requireModule(moduleName, resolvedPath, loadedModule); });
                    var moduleScope = (function () {
                        var ModuleContext = function () { };
                        ModuleContext.prototype = _this.global;
                        var moduleScope = new ModuleContext();
                        moduleScope.global = moduleScope;
                        moduleScope.require = function (moduleName) { return loadedModule.require(moduleName); };
                        moduleScope.exports = loadedModule.exports;
                        moduleScope.global.__filename = resolvedPath;
                        moduleScope.global.__dirname = noapi.dirname(resolvedPath);
                        if (_this._console)
                            _this.global.console = _this._console;
                        moduleScope.module = loadedModule;
                        return moduleScope;
                    })();
                    this._context.run(content, resolvedPath, moduleScope);
                    return loadedModule.exports;
                }
            }
        };
        HostedProcess.prototype.dispose = function () {
            this._context.dispose();
        };
        HostedProcess.prototype.keepAlive = function () {
            var _this = this;
            this._waitFor++;
            return function () {
                _this._waitFor--;
                if (_this._waitFor <= 0) {
                    setTimeout(function () {
                        if (_this._waitFor <= 0)
                            _this.dispose();
                    }, 1000);
                }
            };
        };
        return HostedProcess;
    })();
    noapi.HostedProcess = HostedProcess;
})(noapi || (noapi = {}));
var noapi;
(function (noapi) {
    function apply(global, drive, options) {
        var apiGlobal = {
            process: null,
            module: null
        };
        if (!options)
            options = {};
        var cleanOptions = {
            argv: options.argv || ['/node'],
            cwd: options.cwd || '/',
            env: options.env || {}
        };
        var coreModules = {
            fs: null,
            os: null,
            path: null
        };
        apiGlobal.process = noapi.createProcess(coreModules, cleanOptions);
        apiGlobal.module = noapi.createModule('repl' /*id*/, null /*filename*/, null /*parent*/, module_require);
        coreModules.fs = noapi.createFS(drive, coreModules);
        coreModules.os = noapi.createOS(apiGlobal);
        coreModules.path = noapi.createPath(apiGlobal);
        global.process = apiGlobal.process;
        global.module = apiGlobal.module;
        global.require = global_require;
        function global_require(moduleName) {
            return module_require(moduleName);
        }
        function module_require(moduleName) {
            if (coreModules.hasOwnProperty(moduleName))
                return coreModules[moduleName];
            throw new Error('Cannot find module \'' + moduleName + '\'');
        }
    }
    noapi.apply = apply;
    function nextTick(callback) {
        function fire() {
            if (fired)
                return;
            fired = true;
            callback();
        }
        var fired = false;
        setTimeout(fire, 0);
        if (typeof requestAnimationFrame !== 'undefined') {
            requestAnimationFrame(fire);
        }
        else if (typeof msRequestAnimationFrame !== 'undefined') {
            msRequestAnimationFrame(fire);
        }
    }
    noapi.nextTick = nextTick;
    function wrapAsync(fn) {
        return function () {
            var args = [];
            for (var i = 0; i < arguments.length - 1; i++) {
                args.push(arguments[i]);
            }
            var callback = arguments[arguments.length - 1];
            nextTick(function () {
                try {
                    var result = fn.apply(null, args);
                }
                catch (error) {
                    callback(error);
                }
                callback(null, result);
            });
        };
    }
    noapi.wrapAsync = wrapAsync;
    function wrapAsyncNoError(fn) {
        return function () {
            var args = [];
            for (var i = 0; i < arguments.length - 1; i++) {
                args.push(arguments[i]);
            }
            var callback = arguments[arguments.length - 1];
            nextTick(function () {
                try {
                    var result = fn.apply(null, args);
                }
                catch (error) {
                    callback(error);
                }
                callback(result);
            });
        };
    }
    noapi.wrapAsyncNoError = wrapAsyncNoError;
})(noapi || (noapi = {}));
var noapi;
(function (noapi) {
    function createEventEmitter() {
        var _listeners = {};
        var result = {
            addListener: addListener, removeListener: removeListener, removeAllListeners: removeAllListeners,
            on: on, once: once,
            setMaxListeners: setMaxListeners,
            listeners: listeners,
            emit: emit
        };
        return result;
        function addListener(event, listener) {
            var key = '*' + event;
            var list = _listeners[key] || (this._listeners[key] = []);
            list.push(listener);
            return result;
        }
        function removeListener(event, listener) {
            var key = '*' + event;
            var list = _listeners[key];
            if (list) {
                for (var i = 0; i < list.length; i++) {
                    if (list[i] === listener) {
                        list.splice(i, 1);
                        break;
                    }
                }
            }
            return result;
        }
        function removeAllListeners(event) {
            var key = '*' + event;
            delete _listeners[key];
            return result;
        }
        function setMaxListeners(n) {
            // too complicated for now, ignore
        }
        function listeners(event) {
            var key = '*' + event;
            var list = _listeners[key];
            if (list)
                return list.slice(0);
            else
                return [];
        }
        function emit(event) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var key = '*' + event;
            var list = _listeners[key];
            if (!list)
                return false;
            for (var i = 0; i < list.length; i++) {
                var f = list[i];
                f.apply(null, args);
            }
            return true;
        }
        function on(event, listener) {
            return addListener(event, listener);
        }
        function once(event, listener) {
            return on(event, listener);
        }
    }
    noapi.createEventEmitter = createEventEmitter;
})(noapi || (noapi = {}));
var noapi;
(function (noapi) {
    function createFS(drive, modules) {
        var fs = {
            renameSync: renameSync,
            rename: noapi.wrapAsync(renameSync),
            statSync: statSync,
            lstatSync: statSync,
            stat: noapi.wrapAsync(statSync),
            lstat: noapi.wrapAsync(statSync),
            fstat: null, fstatSync: null,
            existsSync: existsSync,
            exists: noapi.wrapAsyncNoError(existsSync),
            openSync: openSync,
            open: noapi.wrapAsync(openSync),
            close: null, closeSync: null,
            fsync: null, fsyncSync: null,
            readFileSync: readFileSync,
            readFile: noapi.wrapAsync(readFileSync),
            createReadStream: null,
            writeFileSync: writeFileSync,
            writeFile: noapi.wrapAsync(writeFileSync),
            appendFile: null, appendFileSync: null,
            createWriteStream: null,
            readSync: readSync,
            read: noapi.wrapAsync(readSync),
            writeSync: writeSync,
            write: noapi.wrapAsync(writeSync),
            truncate: null, truncateSync: null,
            ftruncate: null, ftruncateSync: null,
            chown: null, chownSync: null,
            fchown: null, fchownSync: null,
            lchown: null, lchownSync: null,
            chmod: null, chmodSync: null,
            fchmod: null, fchmodSync: null,
            lchmod: null, lchmodSync: null,
            link: null, linkSync: null,
            readlink: null, readlinkSync: null,
            symlink: null, symlinkSync: null,
            unlink: null, unlinkSync: null,
            realpath: null, realpathSync: null,
            mkdir: noapi.wrapAsync(mkdirSync), mkdirSync: mkdirSync,
            rmdir: null, rmdirSync: null,
            readdir: null, readdirSync: null,
            utimes: null, utimesSync: null,
            futimes: null, futimesSync: null,
            watch: null, watchFile: null, unwatchFile: null
        };
        return fs;
        function existsSync(file) {
            var content = drive.read(file);
            if (content || (content !== null && typeof content === 'undefined'))
                return true;
            var files = drive.files();
            var normPath = modules.path.normalize(file);
            if (normPath.slice(-1) !== '/')
                normPath += '/';
            var leadMatch = getStartMatcher(file);
            for (var i = 0; i < files.length; i++) {
                if (leadMatch(files[i]))
                    return;
            }
            return false;
        }
        function mkdirSync(path, mode) {
            var normPath = modules.path.normalize(path);
            if (normPath.slice(-1) !== '/')
                normPath += '/';
            if (existsSync(path))
                throw new Error('Directory \'' + path + '\'');
            drive.write(normPath, '');
        }
        function renameSync(oldPath, newPath) {
            var oldContent = drive.read(oldPath);
            if (oldContent !== null) {
                // TODO: check if directory is in the way
                // if (nofs
                drive.write(newPath, oldContent);
                drive.write(oldPath, null);
                return;
            }
            if (drive.read(newPath) !== null) {
                // node actually reports oldPath here, but let's be reasonable
                throw new Error('ENOTDIR, not a directory \'' + newPath + '\'');
            }
            var norm_oldPath = modules.path.resolve(oldPath);
            if (norm_oldPath === '/')
                throw new Error('EBUSY, resource busy or locked \'/\'');
            else
                norm_oldPath += '/';
            var norm_newPath = modules.path.resolve(newPath);
            if (norm_newPath === '/')
                throw new Error('EBUSY, resource busy or locked \'/\'');
            else
                norm_newPath += '/';
            var files = drive.files();
            var startAsOld = getStartMatcher(norm_oldPath);
            for (var i = 0; i < files.length; i++) {
                var fi = files[i];
                if (startAsOld(fi)) {
                    var oldContent = drive.read(fi);
                    var restPath = fi.slice(norm_newPath.length);
                    var newFiPath = norm_newPath + restPath;
                    drive.write(newFiPath, oldContent);
                    drive.write(newFiPath, null);
                }
            }
        }
        function statSync(path) {
            // TODO: implement
            throw new Error('Not implemented');
        }
        /*
          stat(path: string, callback?: (err: no_ErrnoError, stats: nofs_Stats) => any): void;
          lstat(path: string, callback?: (err: no_ErrnoError, stats: nofs_Stats) => any): void;
          fstat(fd: number, callback?: (err: no_ErrnoError, stats: nofs_Stats) => any): void;
          statSync(path: string): nofs_Stats;
          lstatSync(path: string): nofs_Stats;
          fstatSync(fd: number): nofs_Stats;
        */
        function readFileSync(filename, options) {
            // TODO: handle encoding and other
            return drive.read(filename);
        }
        function readSync(fd, buffer, offset, length, position) {
            // TODO: consider also std handles
            //var path = nofs_fdtable()[fd];
            throw new Error('Buffer-aware API fs.readSync is not implemented.');
        }
        function writeFileSync(filename, content) {
            drive.write(filename, content);
        }
        function writeSync(fd, buffer, offset, length, position) {
            if (fd === 1) {
                if (typeof console !== 'undefined')
                    console.log(buffer);
                return length;
            }
            var path = get_fdtable()[fd];
            throw new Error('Buffer-aware API fs.writeSync is not implemented.');
        }
        function openSync(path, flags, mode) {
            var fdtable = get_fdtable();
            for (var fd in fdtable) {
                var fpath = fdtable[fd];
                if (fpath === path) {
                    return Number(fd);
                }
            }
            var newFD = _fdbase_++;
            fdtable[newFD] = path;
            return newFD;
        }
        var _fdbase_;
        var _fdtable_;
        function get_fdtable() {
            if (!_fdtable_) {
                _fdtable_ = [];
                _fdbase_ = 34957346;
            }
            return _fdtable_;
        }
    }
    noapi.createFS = createFS;
    function getStartMatcher(oldPath) {
        if (!oldPath)
            return function (txt) { return !txt; };
        return function (txt) {
            if (!txt)
                return false;
            if (txt.length < oldPath.length)
                return false;
            return txt.slice(0, oldPath.length) === oldPath;
        };
    }
})(noapi || (noapi = {}));
var noapi;
(function (noapi) {
    function createModule(id, filename, parent, requireForModule) {
        var module = {
            exports: {},
            id: id,
            filename: filename,
            loaded: false,
            parent: parent,
            children: [],
            require: require
        };
        return module;
        var _moduleCache;
        var _resolveCache;
        function require(moduleName) {
            var key = '*' + moduleName;
            if (_moduleCache && key in _moduleCache)
                return _moduleCache[key];
            var mod = requireForModule(moduleName);
            (_moduleCache || (_moduleCache = {}))[key] = mod;
            return mod;
        }
    }
    noapi.createModule = createModule;
})(noapi || (noapi = {}));
var noapi;
(function (noapi) {
    function createOS(global) {
        return {
            EOL: '\n',
            tmpdir: function () { return '/.tmp'; },
            hostname: function () { return 'localhost'; },
            type: function () { return 'Linux'; },
            arch: function () { return global.process.arch; },
            platform: function () { return global.process.platform; },
            release: function () { return '3.16.0-38-generic'; },
            uptime: function () { return global.process.uptime(); },
            loadavg: function () { return [0.7275390625, 0.65576171875, 0.4658203125]; },
            totalmem: function () { return 3680739328 + ((Math.random() * 1000) | 0); },
            freemem: function () { return 2344873984 - ((Math.random() * 1000) | 0); },
            cpus: function () { return [
                { model: 'AMD A4-1250 APU with Radeon(TM) HD Graphics', speed: 800, times: { user: 8058000, nice: 29600, sys: 1079400, idle: 128185400, irq: 0 } },
                { model: 'AMD A4-1250 APU with Radeon(TM) HD Graphics', speed: 800, times: { user: 7779400, nice: 33000, sys: 1069200, idle: 127970900, irq: 0 } }
            ]; },
            networkInterfaces: function () {
                return {
                    lo: [
                        { address: '127.0.0.1', family: 'IPv4', internal: true },
                        { address: '::1', family: 'IPv6', internal: true }
                    ],
                    wlan0: [
                        { address: '192.168.1.3', family: 'IPv4', internal: false },
                        { address: 'fe80::8256:f2ff:fe04:3d29', family: 'IPv6', internal: false }
                    ]
                };
            }
        };
    }
    noapi.createOS = createOS;
})(noapi || (noapi = {}));
var noapi;
(function (noapi) {
    function createPath(global) {
        var result = {
            basename: basename, extname: extname,
            dirname: dirname,
            isAbsolute: isAbsolute,
            normalize: normalize,
            join: join,
            relative: relative, resolve: resolve,
            sep: '/',
            delimiter: ':'
        };
        return result;
        function isAbsolute(p) {
            return /^\//.test(p);
        }
        function extname(p) {
            var base = basename(p);
            var lastDot = base.lastIndexOf('.');
            if (lastDot >= 0)
                return base.slice(lastDot);
            else
                return '';
        }
        function join() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i - 0] = arguments[_i];
            }
            return join_core(paths);
        }
        function join_core(paths) {
            var parts = [];
            var trailSlash = false;
            for (var i = 0; i < paths.length; i++) {
                var part = paths[i];
                if (!part)
                    continue;
                if (parts.length) {
                    var wlead = part;
                    part = part.replace(/^\/*/, '');
                    if (!part)
                        continue;
                    if (wlead.length > part.length)
                        parts.push('');
                }
                var wtrail = part;
                part = part.replace(/\/*$/, '');
                if (!part)
                    continue;
                parts.push(part);
                trailSlash = wtrail.length > part.length;
            }
            if (trailSlash)
                parts.push('/');
            return parts.join('/');
        }
        function relative(from, to) {
            throw new Error('path/relative is not implemented');
        }
        function resolve() {
            var pathSegments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                pathSegments[_i - 0] = arguments[_i];
            }
            var res = join_core(pathSegments);
            if (!/^\//.test(res))
                res = global.process.cwd() + res;
            return res;
        }
    }
    noapi.createPath = createPath;
    function basename(p, ext) {
        p = normalize(p);
        if (p === '/')
            return '';
        var result;
        var lastSlash = p.lastIndexOf('/');
        if (lastSlash === p.length - 1) {
            var prevSlash = p.lastIndexOf('/', lastSlash - 1);
            if (prevSlash < 0)
                prevSlash = 0;
            result = p.slice(prevSlash + 1, lastSlash);
        }
        else {
            result = p.slice(lastSlash + 1);
        }
        if (ext && result.length >= ext.length && result.slice(-ext.length) === ext)
            result = result.slice(0, result.length - ext.length);
    }
    noapi.basename = basename;
    function dirname(p) {
        var p = normalize(p);
        if (p === '/')
            return '/';
        var lastSlash = p.lastIndexOf('/');
        if (lastSlash === p.length - 1)
            lastSlash = p.lastIndexOf('/', lastSlash - 1);
        return p.slice(0, lastSlash + 1);
    }
    noapi.dirname = dirname;
    function normalize(p) {
        return p;
    }
    noapi.normalize = normalize;
})(noapi || (noapi = {}));
var noapi;
(function (noapi) {
    function createProcess(modules, options) {
        var evt = noapi.createEventEmitter();
        return {
            abort: abort, exit: exit, kill: kill,
            nextTick: noapi.nextTick,
            chdir: chdir, cwd: cwd,
            title: 'node',
            arch: 'ia32',
            platform: 'linux',
            execPath: '/usr/bin/nodejs',
            getgid: getgid, setgid: setgid, getuid: getuid, setuid: setuid,
            stdout: load_stdout(), stderr: load_stderr(), stdin: load_stdin(),
            memoryUsage: memoryUsage,
            uptime: load_uptime(),
            hrtime: function () { throw new Error('High resultion time is not implemenetd yet.'); },
            pid: load_pid(),
            umask: load_umask(),
            config: load_config(),
            versions: load_versions(),
            version: load_versions().node,
            argv: options.argv,
            env: options.env,
            addListener: evt.addListener,
            on: evt.on,
            once: evt.once,
            removeListener: evt.removeListener,
            removeAllListeners: evt.removeAllListeners,
            setMaxListeners: evt.setMaxListeners,
            listeners: evt.listeners,
            emit: evt.emit
        };
        function abort() {
        }
        function exit(code) {
        }
        function kill(pid, signal) {
            // when we emulate processes, implement process termination
        }
        function chdir(directory) {
            var dirStat = modules.fs.statSync(directory);
            if (dirStat && dirStat.isDirectory()) {
                if (directory !== cwd()) {
                    var normDirectory = modules.path.normalize(directory);
                    if (cwd() !== normDirectory) {
                        options.cwd = normDirectory;
                    }
                }
            }
            else {
                // TODO: throw a node-shaped error instead
                throw new Error('ENOENT, no such file or directory');
            }
        }
        function cwd() {
            return options.cwd;
        }
        function getgid() {
            // taken from node running on ubuntu
            return 1000;
        }
        function setgid(id) {
            // TODO: use node-shaped error
            throw new Error('EPERM, Operation not permitted');
        }
        function getuid() {
            // taken from node running on ubuntu
            return 1000;
        }
        function setuid(id) {
            // TODO: use node-shaped error
            throw new Error('EPERM, Operation not permitted');
        }
        function load_uptime() {
            var _uptime_start_ = typeof Date.now === 'function' ? Date.now() : +(new Date());
            return uptime;
            function uptime() {
                var now = typeof Date.now === 'function' ? Date.now() : +(new Date());
                return now - _uptime_start_;
            }
        }
        function load_stdout() {
            return {};
        }
        function load_stderr() {
            return {};
        }
        function load_stdin() {
            return {};
        }
        function memoryUsage() {
            return {
                rss: 13225984 + ((Math.random() * 3000) | 0),
                heapTotal: 7130752 + ((Math.random() * 3000) | 0),
                heapUsed: 2449612 + ((Math.random() * 3000) | 0)
            };
        }
        function load_pid() {
            return 32754 + ((Math.random() * 500) | 0);
        }
        function load_umask() {
            var _umask_;
            return umask;
            function umask(mask) {
                if (typeof _umask_ !== 'number') {
                    _umask_ = 2;
                }
                if (typeof mask === 'number') {
                    var res = _umask_;
                    _umask_ = mask;
                    return res;
                }
                return _umask_;
            }
        }
        function load_versions() {
            // real node running on ubuntu as of Friday 22 of May 2015
            // (these might not be properly implemented when hosted in browser)
            return {
                http_parser: '1.0',
                node: '0.10.38',
                v8: '3.14.5.9',
                ares: '1.9.0-DEV',
                uv: '0.10.36',
                zlib: '1.2.8',
                modules: '11',
                openssl: '1.0.1m'
            };
        }
        function load_config() {
            return {
                target_defaults: {
                    cflags: [],
                    default_configuration: 'Release',
                    defines: [],
                    include_dirs: [],
                    libraries: []
                },
                variables: {
                    clang: 0,
                    gcc_version: 48,
                    host_arch: 'ia32',
                    node_install_npm: true,
                    node_prefix: '/usr',
                    node_shared_cares: false,
                    node_shared_http_parser: false,
                    node_shared_libuv: false,
                    node_shared_openssl: false,
                    node_shared_v8: false,
                    node_shared_zlib: false,
                    node_tag: '',
                    node_unsafe_optimizations: 0,
                    node_use_dtrace: false,
                    node_use_etw: false,
                    node_use_openssl: true,
                    node_use_perfctr: false,
                    node_use_systemtap: false,
                    openssl_no_asm: 0,
                    python: '/usr/bin/python',
                    target_arch: 'ia32',
                    v8_enable_gdbjit: 0,
                    v8_no_strict_aliasing: 1,
                    v8_use_snapshot: false,
                    want_separate_host_toolset: 0
                }
            };
        }
    }
    noapi.createProcess = createProcess;
})(noapi || (noapi = {}));
var nobrowser;
(function (nobrowser) {
    var HostedWindow = (function () {
        function HostedWindow(_window, _drive) {
            this._window = _window;
            this._drive = _drive;
        }
        return HostedWindow;
    })();
    nobrowser.HostedWindow = HostedWindow;
})(nobrowser || (nobrowser = {}));
var nobrowser;
(function (nobrowser) {
    function overrideLocalStorage(drive, cachePath) {
        var cachePathDir = cachePath + (cachePath.slice(-1) === '/' ? '' : '/');
        return LocalStorageOverride;
        var LocalStorageOverride = (function () {
            function LocalStorageOverride() {
                this._keys = null;
                this.length = 0;
                var files = drive.files();
                for (var i = 0; i < files.length; i++) {
                    var f = files[i];
                    if (f.length > cachePathDir.length && f.slice(0, cachePathDir.length) === cachePathDir)
                        this._keys.push(f.slice(cachePathDir.length));
                }
                this.length = this._keys.length;
            }
            LocalStorageOverride.prototype.clear = function () {
                for (var i = 0; i < this._keys.length; i++) {
                    var f = cachePathDir + this._keys[i];
                    drive.write(f, null);
                }
                this._keys = [];
            };
            LocalStorageOverride.prototype.key = function (index) {
                return this._keys[index];
            };
            LocalStorageOverride.prototype.getItem = function (key) {
                var keypath = cachePathDir + key;
                return drive.read(keypath);
            };
            LocalStorageOverride.prototype.setItem = function (key, value) {
                var keypath = cachePathDir + key;
                drive.write(keypath, value);
                for (var i = 0; i < this._keys.length; i++) {
                    if (key === this._keys[i])
                        return;
                }
                this._keys.push(key);
                this.length++;
            };
            LocalStorageOverride.prototype.removeItem = function (key) {
                var keypath = cachePathDir + key;
                for (var i = 0; i < this._keys.length; i++) {
                    if (key === this._keys[i]) {
                        this._keys.splice(i, 1);
                        this.length++;
                        drive.write(keypath, null);
                        return;
                    }
                }
            };
            return LocalStorageOverride;
        })();
    }
    nobrowser.overrideLocalStorage = overrideLocalStorage;
})(nobrowser || (nobrowser = {}));
var nobrowser;
(function (nobrowser) {
    function overrideXMLHttpRequest(readCache) {
        return XMLHttpRequestOverride;
        // urlBase - 'https://rawgit.com/jeffpar/pcjs/master'
        var XMLHttpRequestOverride = (function () {
            function XMLHttpRequestOverride() {
                this._url = null;
                this.status = 0;
                this.readyState = 0;
                this.responseText = null;
                this.onreadystatechange = null;
            }
            XMLHttpRequestOverride.prototype.open = function (method, url) {
                this._url = url;
            };
            XMLHttpRequestOverride.prototype.send = function () {
                var _this = this;
                var completed = false;
                this.readyState = 0;
                readCache(this._url, function (content) {
                    _this.status = 200;
                    _this.readyState = 4;
                    _this.responseText = content;
                    if (completed)
                        _this.onreadystatechange();
                    return;
                });
                if (this.readyState === 4) {
                    setTimeout(function () { return _this.onreadystatechange(); }, 1);
                }
            };
            XMLHttpRequestOverride.prototype.setRequestHeader = function () {
            };
            return XMLHttpRequestOverride;
        })();
    }
    nobrowser.overrideXMLHttpRequest = overrideXMLHttpRequest;
    var overrideXMLHttpRequest;
    (function (overrideXMLHttpRequest) {
        function withDrive(drive, cachePath, realXMLHttpRequest) {
            return overrideXMLHttpRequest(function (url, callback) {
                var existing = cachePath + (cachePath.slice(-1) === '/' ? '' : '/') + (url.charAt(0) === '/' ? url.slice(1) : url);
                var existingContent = drive.read(existing);
                if (existingContent) {
                    callback(existingContent);
                    return;
                }
                var xhr = new realXMLHttpRequest();
                xhr.open('GET', url);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        var response = xhr.responseText || xhr.response;
                        drive.write(existing, response);
                        callback(response);
                    }
                };
                xhr.send();
            });
        }
        overrideXMLHttpRequest.withDrive = withDrive;
    })(overrideXMLHttpRequest = nobrowser.overrideXMLHttpRequest || (nobrowser.overrideXMLHttpRequest = {}));
})(nobrowser || (nobrowser = {}));
var nojq;
(function (nojq) {
    function noajax(drive, basePath, window) {
        var existingAjax = window['$'] ? window['$']['ajax'] : null;
        return function (options) {
            var dt = drive.read(basePath + options.url);
            if (dt) {
                options.success(dt);
            }
            else {
                if (typeof console !== 'undefined' && console && console.error)
                    console.error('No data found for ', options);
                options.error(new Error('No data found for ' + options.url));
            }
        };
        /*
        $.ajax({
                            url: file,
                            dataType: 'string',
                            success: function(data) {
                                if(!data) {
                                    $(useFallback);
                                    return;
                                }
                                svgdoc = parser.parseFromString(data, "text/xml");
                                $(function() {
                                    getIcons('ajax');
                                });
                            },
                  error: function(err) {
                  })
        */
    }
    nojq.noajax = noajax;
})(nojq || (nojq = {}));
var shell;
(function (shell) {
    var CommanderShell = (function () {
        function CommanderShell(_host, _drive, complete) {
            var _this = this;
            this._host = _host;
            this._drive = _drive;
            this._editor = null;
            this._repl = new noapi.HostedProcess({
                window: window,
                drive: this._drive,
                scriptPath: '/node_modules/repl.js',
                console: { log: function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i - 0] = arguments[_i];
                        }
                        return _this._terminal.log(args);
                    } }
            });
            this._enhanceNoprocess(this._repl);
            this._replAlive = this._repl.keepAlive();
            elem(this._host, {
                background: 'black',
                color: 'silver'
            });
            this._metrics = new shell.layout.MetricsCollector(window);
            this._terminal = new shell.terminal.Terminal(this._host, this._repl);
            this._twoPanels = new shell.panels.TwoPanels(this._host, '/', '/src', this._drive);
            this._twoPanels.ondoubleclick = function () { return _this._twoPanels_doubleclick(); };
            this._keybar = new shell.keybar.Keybar(this._host, [
                { text: 'Help' },
                { text: '<None>' },
                { text: 'View' },
                { text: 'Edit', action: function () { return _this._openEditor(_this._twoPanels.cursorPath()) || true; } },
                { text: 'Copy', action: function () { return _this._command(shell.actions.copy); } },
                { text: 'Copy', action: function () { return _this._command(shell.actions.move); } },
                { text: 'MkDir', action: function () { return _this._command(shell.actions.mkDir); } },
                { text: 'Delete', action: function () { return _this._command(shell.actions.remove); } },
                { text: 'Options' },
                { text: 'Save', action: function () { return shell.actions.save() || true; } }
            ]);
            var resizeMod = require('resize');
            resizeMod.on(function (winMetrics) {
                _this._metrics.resize(winMetrics);
                _this.measure();
                _this.arrange();
            });
            this.measure();
            this.arrange();
            on(this._host, 'keydown', function (e) { return _this._keydown(e); });
            var _glob = (function () { return this; })();
            var applyConsole = function (glob) {
                if (glob.console) {
                    var _oldLog = glob.console.log;
                    var term = _this._terminal;
                    console.log = function () {
                        var args = [];
                        for (var i = 0; i < arguments.length; i++) {
                            args.push(arguments[i]);
                        }
                        term.log(args);
                        if (typeof _oldLog === 'function')
                            _oldLog.apply(glob.console, args);
                    };
                }
                else {
                    var term = _this._terminal;
                    glob.console = {
                        log: function () {
                            var args = [];
                            for (var i = 0; i < arguments.length; i++) {
                                args.push(arguments[i]);
                            }
                            term.log(args);
                        }
                    };
                }
            };
            applyConsole(_glob);
            applyConsole(window);
            setTimeout(function () {
                _this._terminal.writeDirect(complete());
            }, 1);
            this._terminal.onexecute = function (code) { return _this._terminalExecute(code); };
        }
        CommanderShell.prototype.measure = function () {
            this._metrics.measure();
            this._twoPanels.measure();
            this._terminal.measure();
            // this._editor.measure();
        };
        CommanderShell.prototype.arrange = function () {
            this._host.style.width = this._metrics.metrics.hostWidth + 'px';
            this._host.style.height = this._metrics.metrics.hostHeight + 'px';
            this._twoPanels.arrange(this._metrics.metrics);
            this._terminal.arrange(this._metrics.metrics);
            //this._editor.arrange();
            this._keybar.arrange(this._metrics.metrics);
        };
        CommanderShell.prototype._twoPanels_doubleclick = function () {
            var cursorPath = this._twoPanels.cursorPath();
            return this._execute(cursorPath, null);
        };
        CommanderShell.prototype._keydown = function (e) {
            var res = this._keydownCore(e);
            if (res) {
                if (e.preventDefault)
                    e.preventDefault();
            }
            return res;
        };
        CommanderShell.prototype._keydownCore = function (e) {
            if (this._editor) {
                if (e.keyCode === 27) {
                    this._closeEditor();
                    return true;
                }
                return;
            }
            if (e.keyCode === 27) {
                if (!this._terminal.isInputEmpty()) {
                    return this._terminal.keydown(e, this._twoPanels.cursorPath());
                }
                else if (!e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
                    this._twoPanels.toggleVisibility();
                    return true;
                }
            }
            if (this._twoPanels.isVisible() && (e.keyCode !== 13 || this._terminal.isInputEmpty())) {
                if (this._twoPanels.keydown(e))
                    return true;
            }
            var cursorPath = this._twoPanels.cursorPath();
            this._terminal.focus();
            if (this._terminal.keydown(e, cursorPath))
                return true;
            if (e.keyCode === 13)
                return this._execute(cursorPath, null);
            //if (e.keyCode < 32 || e.keyCode > 126) {
            //	this._terminal.log('CommanderShell::keydown ' + e.yCode);
            //}
            if (this._keybar.handleKeydown(e))
                return true;
            if (e.ctrlKey || e.altKey || e.metaKey) {
            }
        };
        CommanderShell.prototype._command = function (action) {
            var cursorPath = this._twoPanels.cursorPath();
            var currentOppositePath = this._twoPanels.currentOppositePath();
            var runResult = action(this._drive, cursorPath, currentOppositePath);
            if (!runResult)
                return false;
            this.measure();
            this.arrange();
            return true;
        };
        CommanderShell.prototype._closeEditor = function () {
            var newText = this._editor.getText();
            var cursorPath = this._twoPanels.cursorPath();
            var oldText = this._drive.read(cursorPath);
            if (newText !== oldText) {
                if (confirm('File was changed: ' + cursorPath + ', save before exit?'))
                    this._drive.write(cursorPath, newText);
            }
            this._editor.close();
            this._editor = null;
            this.measure();
            this.arrange();
        };
        CommanderShell.prototype._openEditor = function (cursorPath) {
            var _this = this;
            if (cursorPath) {
                var text = this._drive.read(cursorPath);
                if (typeof text === 'string') {
                    this._terminal.writeDirect('@edit ' + cursorPath);
                    this._editor = new shell.editor.Editor(this._host, cursorPath, text);
                    setTimeout(function () {
                        if (_this._editor)
                            _this._editor.focus();
                    }, 1);
                }
                else {
                    this._terminal.log(['text at ', cursorPath, ' is ', text]);
                }
            }
            else {
                this._terminal.log(['cursorPath = ', cursorPath]);
            }
        };
        CommanderShell.prototype._enhanceNoprocess = function (nopro) {
            nopro.coreModules['nodrive'] = this._drive;
            nopro.coreModules['nowindow'] = window;
        };
        CommanderShell.prototype._terminalExecute = function (code) {
            if (!code)
                return void 0;
            var firstWord = (code.match(/^\s*(\S+)[\s$]/) || [])[1];
            var moreArgs = (code.match(/^\s*\S+\s+(\S[\S\s]*)$/) || [])[1];
            switch (firstWord) {
                case 'cd':
                    return this._cd(moreArgs);
                case 'ls':
                    return this._ls(moreArgs);
                case 'type':
                    return this._type(moreArgs);
                case 'node':
                    return this._node(moreArgs);
                case 'tsc':
                    return this._tsc(moreArgs);
                default:
                    return this._repl.eval(code);
            }
        };
        CommanderShell.prototype._cd = function (args) {
            if (!args) {
                this._terminal.writeDirect(this._twoPanels.currentPath());
                return true;
            }
            if (this._twoPanels.setPath(args)) {
                return true;
            }
            else {
                this._terminal.writeDirect('Directory ' + args + ' not found.');
                return false;
            }
        };
        CommanderShell.prototype._ls = function (args) {
            this._terminal.writeDirect('ls command is not implemented yet');
        };
        CommanderShell.prototype._type = function (args) {
            if (!args) {
                this._terminal.writeDirect('type command requires file name');
                return false;
            }
            var content = this._drive.read(args);
            if (content === null) {
                this._terminal.writeDirect('File ' + args + ' not found');
                return false;
            }
            this._terminal.writeDirect(content);
        };
        CommanderShell.prototype._node = function (args) {
            var _this = this;
            var argList = (args || '').split(/\s+/);
            if (!argList[0]) {
                this._terminal.writeDirect('Node emulation, v0.EARLY');
                return false;
            }
            var text = this._drive.read(argList[0]);
            if (typeof text !== 'undefined' && text !== null) {
                this._terminal.writeDirect('node ' + args);
                var ani = this._twoPanels.temporarilyHidePanels();
                setTimeout(function () {
                    try {
                        var proc = new noapi.HostedProcess({
                            window: window,
                            drive: _this._drive,
                            scriptPath: argList[0],
                            argv: argList.slice(1),
                            console: { log: function () {
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i - 0] = arguments[_i];
                                    }
                                    return _this._terminal.log(args);
                                } }
                        });
                        _this._enhanceNoprocess(proc);
                        var result = proc.eval(text);
                        if (typeof proc.exitCode == 'number')
                            result = proc.exitCode;
                        else
                            result = proc.mainModule.exports;
                    }
                    catch (error) {
                        result = error;
                    }
                    ani();
                    _this._terminal.log([result]);
                }, 1);
                return true;
            }
        };
        CommanderShell.prototype._tsc = function (args) {
            this._terminal.writeDirect('tsc command is not implemented yet');
        };
        CommanderShell.prototype._execute = function (cursorPath, callback) {
            var _this = this;
            if (/\.js$/.test(cursorPath)) {
                return this._node(cursorPath);
            }
            else if (/\.ts$/.test(cursorPath)) {
                var text = this._drive.read('/src/typescript/tsc.js');
                if (typeof text !== 'undefined' && text !== null) {
                    this._terminal.writeDirect('@tsc ' + cursorPath);
                    var ani = this._twoPanels.temporarilyHidePanels();
                    setTimeout(function () {
                        try {
                            var proc = new noapi.HostedProcess({
                                window: window,
                                drive: _this._drive,
                                scriptPath: '/src/typescript/tsc.js',
                                argv: ['node', '/src/typescript/tsc.js', cursorPath],
                                console: { log: function () {
                                        var args = [];
                                        for (var _i = 0; _i < arguments.length; _i++) {
                                            args[_i - 0] = arguments[_i];
                                        }
                                        return _this._terminal.log(args);
                                    } }
                            });
                            _this._enhanceNoprocess(proc);
                            setTimeout(function () {
                                if (!finishedOK) {
                                    var compileTime = +new Date() - start;
                                    _this._terminal.log(['Compilation seems to have failed after ' + compileTime / 1000 + ' sec.']);
                                    ani();
                                }
                            }, 100);
                            var start = +new Date();
                            _this._terminal.log(['... started at ' + (new Date())]);
                            var result = proc.eval(text);
                            _this._terminal.log(['...finished at ' + (new Date())]);
                            if (typeof proc.exitCode == 'number')
                                result = proc.exitCode;
                            else
                                result = proc.mainModule.exports;
                            _this._terminal.log([result]);
                        }
                        catch (error) {
                            _this._terminal.log([error]);
                        }
                        var finishedOK = true;
                        ani();
                    }, 1);
                    return true;
                }
            }
            else if (/.html$/.test(cursorPath)) {
                this._terminal.writeDirect('@build ' + cursorPath);
                var ani = this._twoPanels.temporarilyHidePanels();
                setTimeout(function () {
                    var htmlTemplate = _this._drive.read(cursorPath);
                    var blankWindow = window.open('', '_blank' + (+new Date()));
                    var pollUntil = (+new Date()) + 1000;
                    while (+new Date() < pollUntil) {
                        try {
                            var blankWindowDoc = blankWindow.document;
                        }
                        catch (error) { }
                    }
                    if (!blankWindowDoc) {
                        alert('Cannot open a window to host the built document');
                        ani();
                        return;
                    }
                    blankWindow.document.open();
                    blankWindow.document.write([
                        '<html><title>Building ' + cursorPath + '...</title>',
                        '<style>',
                        'html, body { background: black; color: greenyellow; }',
                        'h2 { font-weight: 100; width: 40%; position: fixed; font-size: 200%; }',
                        'pre { width: 50%; padding-left: 50%; opacity: 1; transition: opacity 1s; }',
                        '</style>',
                        '<h2>Building ' + cursorPath + '</h2>',
                        '<' + 's' + 'cript>',
                        'var textContentProp = "textContent" in document.createElement("pre") ? "textContent" : "innerText";',
                        'var lastLogElem;',
                        'function log(text) {',
                        '  var logElem = document.createElement("pre");',
                        '  logElem[textContentProp]=text;',
                        '  document.body.appendChild(logElem);',
                        '  logElem.scrollIntoView();',
                        '  if (lastLogElem) {',
                        '    lastLogElem.style.opacity = 0.5;',
                        '  }',
                        '  lastLogElem = logElem;',
                        '}',
                        '<' + '/' + 's' + 'cript>'].join('\n'));
                    blankWindow.document.close();
                    var buildScope = {
                        embedFile: function (file) { return _this._drive.read(file); }
                    };
                    try {
                        shell.build.processTemplate(htmlTemplate, [buildScope], function (txt) {
                            _this._terminal.log([txt]);
                            blankWindow.log(txt);
                        }, function (error, result) {
                            if (error) {
                                _this._terminal.log([error]);
                                ani();
                                return;
                            }
                            try {
                                var blob = new Blob([result], { type: 'text/html' });
                                var url = URL.createObjectURL(blob);
                                blankWindow.location.replace(url);
                            }
                            catch (blobError) {
                                blankWindow.document.open();
                                blankWindow.document.write(result);
                                blankWindow.document.close();
                            }
                            ani();
                        });
                    }
                    catch (errorProcessTemplate) {
                        ani();
                        _this._terminal.log([errorProcessTemplate]);
                    }
                }, 1);
            }
            else {
                var ani = this._twoPanels.temporarilyHidePanels();
                this._terminal.writeDirect('@type ' + cursorPath);
                this._terminal.writeDirect(this._drive.read(cursorPath));
                ani();
            }
        };
        return CommanderShell;
    })();
    shell.CommanderShell = CommanderShell;
})(shell || (shell = {}));
var shell;
(function (shell) {
    var actions;
    (function (actions) {
        function copy(drive, selectedPath, targetPanelPath) {
            return actions.copyOrMove(false /*move*/, drive, selectedPath, targetPanelPath);
        }
        actions.copy = copy;
    })(actions = shell.actions || (shell.actions = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var actions;
    (function (actions) {
        function copyOrMove(move, drive, cursorPath, targetPanelPath) {
            if (!cursorPath || !targetPanelPath || cursorPath === '/')
                return false;
            var filesToCopy = actions.getDirFiles(drive, cursorPath);
            // TODO: pop up a confirmation and pop up a progress dialog -- as DOM elements
            var targetDir = prompt((move ? 'Move/rename ' : 'Copy ') +
                (filesToCopy.length === 1 ? '\n   "' + filesToCopy[0] + '"' : filesToCopy.length + ' files from\n   "' + cursorPath + '"') +
                '\n   to', targetPanelPath);
            if (!targetDir)
                return false;
            var normTargetDir = targetDir;
            if (normTargetDir.charAt(0) !== '/')
                normTargetDir = cursorPath.slice(0, cursorPath.lastIndexOf('/') + 1) + normTargetDir;
            var targetDirFiles = actions.getDirFiles(drive, normTargetDir);
            if (filesToCopy.length === 1 && filesToCopy[0] === cursorPath
                && targetDirFiles.length === 1 && targetDirFiles[0] === normTargetDir) {
                var content = drive.read(filesToCopy[0]);
                drive.write(normTargetDir, content);
                if (move)
                    drive.write(filesToCopy[0], null);
            }
            else {
                if (normTargetDir.slice(-1) !== '/')
                    normTargetDir += '/';
                var baseDir = cursorPath.slice(0, cursorPath.lastIndexOf('/') + 1);
                for (var i = 0; i < filesToCopy.length; i++) {
                    var content = drive.read(filesToCopy[i]);
                    var newPath = normTargetDir +
                        filesToCopy[i].slice(baseDir.length);
                    drive.write(newPath, content);
                    if (move)
                        drive.write(filesToCopy[i], null);
                }
            }
            return true;
        }
        actions.copyOrMove = copyOrMove;
    })(actions = shell.actions || (shell.actions = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var actions;
    (function (actions) {
        function getDirFiles(drive, path) {
            var fileResult = [];
            var allFiles = drive.files();
            for (var i = 0; i < allFiles.length; i++) {
                var f = allFiles[i];
                if (f.slice(0, path.length) !== path)
                    continue;
                if (f === path || f.slice(path.length, path.length + 1) === '/')
                    fileResult.push(f);
            }
            return fileResult;
        }
        actions.getDirFiles = getDirFiles;
    })(actions = shell.actions || (shell.actions = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var actions;
    (function (actions) {
        function mkDir(drive, selectedPath, targetPanelPath) {
            var dir = prompt('Make directory: ');
            if (!dir || dir === '/')
                return false;
            var dirPath = dir;
            if (dir.slice(0, 1) !== '/') {
                dirPath = selectedPath + '/' + dirPath;
                if (dirPath.slice(0, 2) === '//')
                    dirPath = dirPath.slice(1);
            }
            if (dirPath.slice(-1) === '/')
                dirPath = dirPath.slice(0, dirPath.length - 1);
            var matchFiles = actions.getDirFiles(drive, dirPath);
            if (matchFiles.length)
                return;
            drive.write(dirPath + '/', '');
            return true;
        }
        actions.mkDir = mkDir;
    })(actions = shell.actions || (shell.actions = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var actions;
    (function (actions) {
        function move(drive, selectedPath, targetPanelPath) {
            return actions.copyOrMove(true /*move*/, drive, selectedPath, targetPanelPath);
        }
        actions.move = move;
    })(actions = shell.actions || (shell.actions = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var actions;
    (function (actions) {
        function remove(drive, selectedPath, targetPanelPath) {
            var filesToRemove = actions.getDirFiles(drive, selectedPath);
            if (!confirm('Remove ' + filesToRemove.length + ' files from\n   "' + selectedPath + '"?'))
                return false;
            for (var i = 0; i < filesToRemove.length; i++) {
                drive.write(filesToRemove[i], null);
            }
            return true;
        }
        actions.remove = remove;
    })(actions = shell.actions || (shell.actions = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var actions;
    (function (actions) {
        function save() {
            var window = require('nowindow');
            var document = window.document;
            var textChunks = ['<!doctype html>\n', document.documentElement.outerHTML];
            var totalSize = 0;
            for (var i = 0; i < textChunks.length; i++)
                totalSize += textChunks[i].length;
            var filename = saveFileName();
            exportBlob(filename, textChunks);
            console.log('saved ' + totalSize);
            function exportBlob(filename, textChunks) {
                try {
                    var blob = new Blob(textChunks, { type: 'application/octet-stream' });
                }
                catch (blobError) {
                    exportDocumentWrite(filename, textChunks.join(''));
                    return;
                }
                exportBlobHTML5(filename, blob);
            }
            function exportBlobHTML5(filename, blob) {
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.href = url;
                a.setAttribute('download', filename);
                try {
                    // safer save method, supposed to work with FireFox
                    var evt = document.createEvent("MouseEvents");
                    evt.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                    a.dispatchEvent(evt);
                }
                catch (e) {
                    a.click();
                }
            }
            function exportDocumentWrite(filename, content) {
                var win = document.createElement('iframe');
                win.style.width = '100px';
                win.style.height = '100px';
                win.style.display = 'none';
                document.body.appendChild(win);
                setTimeout(function () {
                    var doc = win.contentDocument || win.document;
                    doc.open();
                    doc.write(content);
                    doc.close();
                    doc.execCommand('SaveAs', null, filename);
                }, 200);
            }
            function saveFileName() {
                if (window.location.protocol.toLowerCase() === 'blob:')
                    return 'mi-save.html';
                var urlParts = window.location.pathname.split('/');
                var currentFileName = decodeURI(urlParts[urlParts.length - 1]);
                var lastDot = currentFileName.indexOf('.');
                if (lastDot > 0) {
                    currentFileName = currentFileName.slice(0, lastDot) + '.html';
                }
                else {
                    currentFileName += '.html';
                }
                return currentFileName;
            }
        }
        actions.save = save;
    })(actions = shell.actions || (shell.actions = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var build;
    (function (build) {
        function processTemplate(template, scopes, log, callback) {
            // <%= expr %>
            // <% statement %>
            // <%-- comment --%>
            log('Generating build script...');
            setTimeout(function () {
                var fnText = generateBuildScript(template, scopes);
                log('Preprocessing build script...');
                setTimeout(function () {
                    try {
                        var fn = Function('scopes', fnText);
                        log('Executing build script...');
                        var output = fn(scopes);
                        var outputIndex = 0;
                    }
                    catch (error) {
                        log('Build failure ' + error);
                        callback(error);
                        return;
                    }
                    processNextOutputChunk();
                    function processNextOutputChunk() {
                        var startTime = +new Date();
                        // all heavy chunks will bail out and queue the next one on setTimeout,
                        // simple literal insertions keep going for a slice of time
                        while (true) {
                            if (outputIndex >= output.length) {
                                var result = output.join('');
                                callback(null, result);
                                return;
                            }
                            var outputChunk = output[outputIndex];
                            if (typeof outputChunk === 'function') {
                                log('Processing ' + outputChunk + '...');
                                setTimeout(function () {
                                    try {
                                        var chunkResult = outputChunk();
                                        var chunkResultText = String(chunkResult);
                                        output[outputIndex] = chunkResultText;
                                    }
                                    catch (error) {
                                        callback(error);
                                        return;
                                    }
                                    log('...OK [' + chunkResultText.length + ']');
                                    outputIndex++;
                                    processNextOutputChunk();
                                    //setTimeout(processNextOutputChunk, 1);
                                }, 1);
                                break;
                            }
                            else {
                                var literal = String(outputChunk);
                                output[outputIndex] = literal;
                                var literalLines = (literal.length > 100 ? literal.slice(0, 50) + '\n...\n' + literal.slice(literal.length - 5) : literal).split('\n');
                                while (literalLines.length && !literalLines[0])
                                    literalLines.shift();
                                while (literalLines.length && !literalLines[literalLines.length - 1])
                                    literalLines.pop();
                                log(literalLines.length <= 2 ? literalLines.join('\n') : literalLines[0] + '\n...\n' + literalLines[literalLines.length - 1]);
                                outputIndex++;
                                if (+new Date() - startTime > 300) {
                                    setTimeout(processNextOutputChunk, 1);
                                    break;
                                }
                            }
                        }
                    }
                }, 1);
            }, 1);
        }
        build.processTemplate = processTemplate;
        function generateBuildScript(template, scopes) {
            var generated = [];
            for (var i = 0; i < scopes.length; i++) {
                generated.push('with(scopes[' + i + ']) {');
            }
            generated.push('var output =[];');
            var index = 0;
            while (index < template.length) {
                var nextOpenASP = template.indexOf('<%', index);
                if (nextOpenASP < 0) {
                    generateWrite(generated, template.slice(index));
                    break;
                }
                var ch = template.charAt(nextOpenASP + 2);
                if (ch === '=') {
                    var closeASP = template.indexOf('%>', nextOpenASP);
                    if (closeASP < 0) {
                        generateWrite(generated, template.slice(index));
                        break;
                    }
                    generateWrite(generated, template.slice(index, nextOpenASP));
                    generateRedirect(generated, template.slice(nextOpenASP + 3, closeASP));
                    index = closeASP + 2;
                }
                else if (ch === '-') {
                    var closeCommentMatch = template.charAt(nextOpenASP + 3) === '-' ? '--%>' : '-%>';
                    var closeComment = template.indexOf(closeCommentMatch, nextOpenASP);
                    if (closeComment < 0) {
                        generateWrite(generated, template.slice(index));
                        break;
                    }
                    generateWrite(generated, template.slice(index, nextOpenASP));
                    index = closeComment + closeCommentMatch.length;
                }
                else {
                    var closeASP = template.indexOf('%>', nextOpenASP);
                    if (closeASP < 0) {
                        generateWrite(generated, template.slice(index));
                        break;
                    }
                    generateWrite(generated, template.slice(index, nextOpenASP));
                    generateStatement(generated, template.slice(nextOpenASP + 2, closeASP));
                    index = closeASP + 2;
                }
            }
            for (var i = 0; i < scopes.length; i++) {
                generated.push('}');
            }
            generated.push('return output;');
            var fnText = generated.join('\n');
            return fnText;
        }
        function generateWrite(generated, chunk) {
            if (chunk)
                generated.push('output.push(\'' + stringLiteral(chunk) + '\');');
        }
        function generateRedirect(generated, redirect) {
            generated.push('output.push(' + redirect + ');');
        }
        function generateStatement(generated, statement) {
            generated.push(statement);
        }
        function stringLiteral(text) {
            return text.
                replace(/\\/g, '\\\\').
                replace(/\n/g, '\\n').
                replace(/\r/g, '\\r').
                replace(/\t/g, '\\t').
                replace(/\'/g, '\\\'').
                replace(/\"/g, '\\"');
        }
    })(build = shell.build || (shell.build = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var editor;
    (function (editor) {
        var Editor = (function () {
            function Editor(_host, _file, text) {
                this._host = _host;
                this._file = _file;
                this._textarea = elem('textarea', {
                    background: 'navy',
                    color: 'silver',
                    top: '0', left: '0',
                    width: '100%', height: '100%', position: 'absolute',
                    borderTop: 'solid 1em black',
                    overflow: 'auto'
                }, this._host);
                this._title = elem('div', {
                    position: 'absolute',
                    top: '0', left: '0',
                    width: '100%', height: '1em',
                    background: 'silver', color: 'navy',
                    text: this._file
                }, this._host);
                if (typeof text === 'string')
                    this._textarea.value = text;
            }
            Editor.prototype.focus = function () {
                this._textarea.focus();
            };
            Editor.prototype.setText = function (text) {
                this._textarea.value = text;
            };
            Editor.prototype.getText = function () {
                return this._textarea.value;
            };
            Editor.prototype.close = function () {
                this._host.removeChild(this._textarea);
                this._host.removeChild(this._title);
            };
            return Editor;
        })();
        editor.Editor = Editor;
    })(editor = shell.editor || (shell.editor = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var handlers;
    (function (handlers) {
        handlers.defaults = handlers.text;
    })(handlers = shell.handlers || (shell.handlers = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var handlers;
    (function (handlers) {
        var js;
        (function (js) {
            js.preferredFiles = '*.js;*.json';
            //export var entryStyle = {};
            function exec(file, callback) {
                // TODO: load in node
            }
            js.exec = exec;
            function edit(file, editorHost, callback) {
                // TODO: augment CodeMirror mode when CodeMirror is supported
                return handlers.text.edit(file, editorHost, callback);
            }
            js.edit = edit;
        })(js = handlers.js || (handlers.js = {}));
    })(handlers = shell.handlers || (shell.handlers = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var handlers;
    (function (handlers) {
        var text;
        (function (text) {
            text.preferredFiles = '*.txt;*.text';
            //export var entryStyle = {};
            function exec(file, callback) {
            }
            text.exec = exec;
            function edit(file, editorHost, callback) {
            }
            text.edit = edit;
        })(text = handlers.text || (handlers.text = {}));
    })(handlers = shell.handlers || (shell.handlers = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var keybar;
    (function (keybar) {
        var Keybar = (function () {
            function Keybar(_host, keys) {
                this._host = _host;
                this._fnKeys = [];
                for (var i = 0; i < keys.length; i++) {
                    var k = keys[i];
                    var keyElem = elem('div', {
                        position: 'absolute', bottom: '0',
                        whiteSpace: 'nowrap',
                        cursor: 'pointer'
                    }, this._host);
                    var keyName = (i === 0 ? 'F1' : '' + (i + 1));
                    elem('span', { background: 'black', color: 'gray', text: keyName + ' ' }, keyElem);
                    elem('span', { background: 'gray', color: 'black', text: k.text }, keyElem);
                    this._fnKeys.push({
                        element: keyElem,
                        text: k.text,
                        action: k.action
                    });
                    on(keyElem, 'click', k.action);
                }
            }
            Keybar.prototype.arrange = function (metrics) {
                var keySize = ((metrics.hostWidth / this._fnKeys.length) | 0);
                for (var i = 0; i < this._fnKeys.length; i++) {
                    this._fnKeys[i].element.style.left = (i * keySize) + 'px';
                    this._fnKeys[i].element.style.width = keySize + 'px';
                }
            };
            Keybar.prototype.handleKeydown = function (e) {
                var fnKeyIndex = e.keyCode - 112;
                if (fnKeyIndex < 0 || fnKeyIndex >= this._fnKeys.length)
                    return false;
                var k = this._fnKeys[fnKeyIndex];
                if (!k.action)
                    return false;
                k.action();
                return true;
            };
            return Keybar;
        })();
        keybar.Keybar = Keybar;
    })(keybar = shell.keybar || (shell.keybar = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var layout;
    (function (layout) {
        var MetricsCollector = (function () {
            function MetricsCollector(window) {
                this.metrics = {
                    hostWidth: 0,
                    hostHeight: 0,
                    emWidth: 0,
                    emHeight: 0
                };
                this.metrics.hostWidth = window.document.body.offsetWidth;
                this.metrics.hostHeight = window.document.body.offsetHeight;
                this._metricElem = window.document.createElement('div');
                this._metricElem.style.position = 'absolute';
                this._metricElem.style.opacity = '0';
                this._metricElem.style.left = '-200px';
                this._metricElem.style.top = '-200px';
                this._metricElem.style.width = 'auto';
                this._metricElem.style.height = 'auto';
                this._metricElem.innerHTML =
                    'MMMMMMMM<br>' +
                        'MMMMMMMM<br>' +
                        'MMMMMMMM<br>' +
                        'MMMMMMMM<br>' +
                        'MMMMMMMM<br>' +
                        'MMMMMMMM<br>' +
                        'MMMMMMMM<br>' +
                        'MMMMMMMM';
                window.document.body.appendChild(this._metricElem);
            }
            MetricsCollector.prototype.resize = function (winMetrics) {
                this.metrics.hostWidth = winMetrics.windowWidth;
                this.metrics.hostHeight = winMetrics.windowHeight;
            };
            MetricsCollector.prototype.measure = function () {
                this.metrics.emWidth = this._metricElem.offsetWidth / 8;
                this.metrics.emHeight = this._metricElem.offsetHeight / 8;
            };
            return MetricsCollector;
        })();
        layout.MetricsCollector = MetricsCollector;
    })(layout = shell.layout || (shell.layout = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var panels;
    (function (panels) {
        var panelClass = 'panels-panel-page';
        var Panel = (function () {
            function Panel(_host, _path, _directoryService) {
                var _this = this;
                this._host = _host;
                this._path = _path;
                this._directoryService = _directoryService;
                this._cursorEntryIndex = -1;
                this._entries = null;
                this._redrawRequested = 0;
                this._metrics = null;
                this._pages = [];
                this._entriesInColumn = 0;
                this._pageHeight = 0;
                this._pageInterval = 0;
                this._columnsOnPage = 0;
                this._columnWidth = 0;
                this._scrollTop = 0;
                this._scrollTopHeight = 0;
                this._isActive = false;
                this._nextRedrawScrollToCurrent = false;
                this.ondoubleclick = null;
                this._scrollContent = elem('div', this._host);
                this._scrollContent.isScrollContent = true;
                on(this._host, 'scroll', function () { return _this._onscroll(); });
                this._queueRedraw();
            }
            Panel.prototype.set = function (paths) {
                if (paths.currentPath)
                    this._path = paths.currentPath;
                if (paths.cursorPath) {
                    this._cursorPath = paths.cursorPath;
                    this._nextRedrawScrollToCurrent = true;
                }
                this._queueRedraw();
            };
            Panel.prototype.handleClick = function (e) {
                if (!this._entries)
                    return;
                var clickElem = (e.srcElement || e.target || e.currentTarget);
                var entryDIV;
                var columnDIV;
                var pageDIV;
                var leadPaddingDIV;
                while (clickElem) {
                    if (clickElem.isScrollContent) {
                        if (clickElem !== this._scrollContent)
                            return false;
                        break;
                    }
                    if (clickElem.isPageDIV)
                        pageDIV = clickElem;
                    if (clickElem.isColumnDIV)
                        columnDIV = clickElem;
                    if (clickElem.isEntryDIV)
                        entryDIV = clickElem;
                    clickElem = clickElem.parentElement;
                }
                if (entryDIV) {
                    for (var i = 0; i < this._entries.length; i++) {
                        if (this._entries[i].entryDIV === entryDIV) {
                            if (this._cursorPath === this._entries[i].path) {
                                if (this._entries[i].flags & Panel.EntryFlags.Directory) {
                                    this._cursorPath = this._path;
                                    this._path = this._entries[i].path; // double click (or second click) opens directory
                                }
                                else {
                                    // double click (or second click) on  a file
                                    this._nextRedrawScrollToCurrent = true;
                                    this._queueRedraw();
                                    return this.ondoubleclick && this.ondoubleclick();
                                }
                            }
                            else {
                                this._cursorPath = this._entries[i].path;
                            }
                            this._nextRedrawScrollToCurrent = true;
                            this._queueRedraw();
                            break;
                        }
                    }
                    this._redrawNow();
                }
                return true;
            };
            Panel.prototype.currentPath = function () {
                return this._path;
            };
            Panel.prototype.cursorPath = function () {
                return this._cursorPath;
            };
            Panel.prototype.arrange = function (metrics) {
                this._metrics = metrics;
                this._redrawNow();
            };
            Panel.prototype.isActive = function () {
                return this._isActive;
            };
            Panel.prototype.activate = function () {
                this._isActive = true;
                this._scrollContent.className = 'panels-panel-active';
            };
            Panel.prototype.deactivate = function () {
                this._isActive = false;
                this._scrollContent.className = 'panels-panel-inactive';
            };
            Panel.prototype.cursorGo = function (direction) {
                if (!this._entries || !this._entries.length)
                    return;
                var moveStep = 0;
                switch (direction) {
                    case -1:
                        moveStep = -1;
                        break;
                    case +1:
                        moveStep = +1;
                        break;
                    case -10:
                        var entryIndex = this._calcEntryIndex(this._cursorEntryIndex);
                        if (this._columnsOnPage === 1) {
                            moveStep = -entryIndex || -1;
                        }
                        else {
                            var columnIndex = this._calcColumnIndex(this._cursorEntryIndex);
                            if (columnIndex > 0) {
                                moveStep = -this._entriesInColumn;
                            }
                            else {
                                moveStep = this._entriesInColumn * (this._columnsOnPage - 1) - 1;
                                // overflow cases
                                if (this._cursorEntryIndex === 0) {
                                    moveStep = this._entriesInColumn * (this._columnsOnPage - 1);
                                }
                                else if (this._cursorEntryIndex + moveStep >= this._entries.length) {
                                    var endEntryIndex = this._calcEntryIndex(this._entries.length - 1);
                                    var endColumnIndex = this._calcColumnIndex(this._entries.length - 1);
                                    // if the last entry is higher vertically, stop at the previous column
                                    var targetColumnIndex = endEntryIndex >= entryIndex ? endColumnIndex : endColumnIndex - 1;
                                    if (targetColumnIndex <= columnIndex) {
                                        moveStep = -entryIndex; // if nowhere to go right, go all the way up
                                    }
                                    else {
                                        // there are columns on the right, so go there (and one up after)
                                        moveStep = (targetColumnIndex - columnIndex) * this._entriesInColumn - 1;
                                    }
                                }
                            }
                        }
                        break;
                    case +10:
                        var columnIndex = this._calcColumnIndex(this._cursorEntryIndex);
                        if (columnIndex < this._columnsOnPage - 1) {
                            moveStep = +this._entriesInColumn;
                        }
                        else {
                            moveStep = -this._entriesInColumn * 2 + 1;
                        }
                        break;
                    case -100:
                        moveStep = -this._entriesInColumn * this._columnsOnPage;
                        break;
                    case +100:
                        moveStep = +this._entriesInColumn * this._columnsOnPage;
                        break;
                }
                if (moveStep) {
                    var newCursorEntryIndex = Math.max(0, Math.min(this._entries.length - 1, this._cursorEntryIndex + moveStep));
                    var e = this._entries[newCursorEntryIndex];
                    if (e) {
                        this._cursorPath = this._entries[newCursorEntryIndex].path;
                        this._nextRedrawScrollToCurrent = true;
                        this._queueRedraw();
                    }
                }
            };
            Panel.prototype.navigateCursor = function () {
                if (this._cursorEntryIndex >= 0) {
                    var entry = this._entries[this._cursorEntryIndex];
                    if (entry) {
                        if (entry.flags & Panel.EntryFlags.Directory) {
                            this._cursorPath = this._path;
                            this._path = entry.path;
                            this._nextRedrawScrollToCurrent = true;
                            this._queueRedraw();
                            return true;
                        }
                    }
                }
            };
            Panel.prototype._queueRedraw = function () {
                var _this = this;
                if (this._redrawRequested)
                    return;
                this._redrawRequested = setTimeout(function () { return _this._redrawNow(); }, 100);
            };
            Panel.prototype._redrawNow = function () {
                var prevOffset = this._calcEntryTopOffset(Math.max(0, this._cursorEntryIndex));
                var entries = this._directoryService(this._path);
                this._entries = [];
                entries.sort(function (e1, e2) {
                    var flagCompare = (e1.flags & Panel.EntryFlags.Directory) ?
                        ((e2.flags & Panel.EntryFlags.Directory) ? 0 : -1) :
                        ((e2.flags & Panel.EntryFlags.Directory) ? +1 : 0);
                    if (flagCompare)
                        return flagCompare;
                    var nameCompare = e1.name > e2.name ? 1 : e1.name < e2.name ? -1 : 0;
                    return nameCompare;
                });
                if (this._path !== '/') {
                    var parentPath = this._path.slice(0, this._path.lastIndexOf('/')) || '/';
                    entries.unshift({
                        name: '..',
                        path: parentPath,
                        flags: Panel.EntryFlags.Directory
                    });
                }
                if (!entries || !entries.length) {
                    this._scrollContent.innerHTML = '';
                    this._pages = [];
                    return;
                }
                this._cursorEntryIndex = -1;
                for (var i = 0; i < entries.length; i++) {
                    if (entries[i].path === this._cursorPath) {
                        this._cursorEntryIndex = i;
                        break;
                    }
                }
                if (this._cursorEntryIndex < 0) {
                    this._cursorEntryIndex = 0;
                    this._cursorPath = entries.length > 0 ? entries[0].path : null;
                }
                this._entriesInColumn = Math.max(3, ((this._metrics.hostHeight / this._metrics.windowMetrics.emHeight) | 0) - 2);
                this._pageHeight = this._entriesInColumn * this._metrics.windowMetrics.emHeight;
                this._pageInterval = this._metrics.hostHeight - this._pageHeight - this._metrics.windowMetrics.emHeight;
                var desiredColumnWidth = 17 * this._metrics.windowMetrics.emWidth;
                this._columnsOnPage = Math.max(1, Math.round(this._metrics.hostWidth / desiredColumnWidth) | 0);
                this._columnWidth = ((this._metrics.hostWidth / this._columnsOnPage) | 0) - 1;
                if (!this._pages)
                    this._pages = [];
                for (var i = 0; i < entries.length; i++) {
                    var pageIndex = this._calcPageIndex(i);
                    var page = this._pages[pageIndex];
                    if (page) {
                        if (page.height !== this._pageHeight) {
                            page.height = this._pageHeight;
                            page.pageDIV.style.height = this._pageHeight + 'px';
                        }
                        if (page.leadInterval !== this._pageInterval) {
                            page.leadInterval = this._pageInterval;
                            if (page.leadPaddingDIV)
                                page.leadPaddingDIV.style.height = this._pageInterval + 'px';
                        }
                    }
                    else {
                        if (pageIndex) {
                            var leadPaddingDIV = elem('div', {
                                className: 'panels-page-separator',
                                height: this._pageInterval + 'px'
                            }, this._scrollContent);
                            leadPaddingDIV.isLeadPaddingDIV = true;
                        }
                        page = {
                            leadPaddingDIV: leadPaddingDIV,
                            leadInterval: this._pageInterval,
                            height: this._pageHeight,
                            pageDIV: elem('div', {
                                className: panelClass,
                                height: this._pageHeight + 'px'
                            }, this._scrollContent),
                            columns: []
                        };
                        page.pageDIV.isPageDIV = true;
                        this._pages.push(page);
                    }
                    var columnIndex = this._calcColumnIndex(i);
                    var column = page.columns[columnIndex];
                    if (column) {
                        if (columnIndex === this._columnsOnPage - 1 && page.columns.length > this._columnsOnPage) {
                            this._removeExcessColumns(page, this._columnsOnPage);
                        }
                        if (column.height !== this._pageHeight) {
                            column.height = this._pageHeight;
                            column.columnDIV.style.height = this._pageHeight + 'px';
                        }
                        if (column.width !== this._columnWidth) {
                            column.width = this._columnWidth;
                            column.columnDIV.style.width = this._columnWidth + 'px';
                        }
                    }
                    else {
                        column = {
                            height: this._pageHeight,
                            width: this._columnWidth,
                            columnDIV: elem('div', {
                                className: 'panels-panel-column',
                                height: this._pageHeight + 'px',
                                width: this._columnWidth + 'px'
                            }, page.pageDIV),
                            entries: []
                        };
                        column.columnDIV.isColumnDIV = true;
                        page.columns.push(column);
                    }
                    var dentry = entries[i];
                    var entryIndex = this._calcEntryIndex(i);
                    var entry = column.entries[entryIndex];
                    if (!entry) {
                        var dirfileClassName = dentry.flags & Panel.EntryFlags.Directory ? ' panels-entry-dir' : ' panels-entry-file';
                        var entryClassName = 'panels-entry' +
                            dirfileClassName +
                            (this._cursorEntryIndex === i ? ' panels-entry-current' + dirfileClassName + '-current' : '');
                        entry = {
                            name: dentry.name,
                            path: dentry.path,
                            flags: dentry.flags,
                            selectionFlags: this._cursorEntryIndex === i ? Panel.SelectionFlags.Current : 0,
                            entryDIV: elem('div', {
                                className: entryClassName,
                                text: dentry.name,
                                height: this._metrics.windowMetrics.emHeight + 'px'
                            }, column.columnDIV)
                        };
                        entry.entryDIV.isEntryDIV = true;
                        column.entries.push(entry);
                    }
                    else {
                        var expectedSelectionFlags = this._cursorEntryIndex === i ? Panel.SelectionFlags.Current : 0;
                        if (entry.name !== dentry.name) {
                            entry.name = dentry.name;
                            setText(entry.entryDIV, dentry.name);
                        }
                        if (entry.path !== dentry.path) {
                            entry.path = dentry.path;
                        }
                        if (entry.flags !== dentry.flags || entry.selectionFlags !== expectedSelectionFlags) {
                            var dirfileClassName = dentry.flags & Panel.EntryFlags.Directory ? ' panels-entry-dir' : ' panels-entry-file';
                            var entryClassName = 'panels-entry' +
                                dirfileClassName +
                                (this._cursorEntryIndex === i ? ' panels-entry-current' + dirfileClassName + '-current' : '');
                            entry.entryDIV.className = entryClassName;
                            entry.flags = dentry.flags;
                            entry.selectionFlags = expectedSelectionFlags;
                        }
                        if (entryIndex === this._entriesInColumn - 1 && column.entries.length > this._entriesInColumn) {
                            this._removeExcessEntries(column, this._entriesInColumn);
                        }
                    }
                    this._entries.push(entry);
                }
                this._removeExcessPages(pageIndex + 1);
                var p = this._pages[pageIndex];
                this._removeExcessColumns(p, columnIndex + 1);
                var c = p.columns[columnIndex];
                this._removeExcessEntries(c, entryIndex + 1);
                var newOffset = this._calcEntryTopOffset(Math.max(0, this._cursorEntryIndex));
                if (this._nextRedrawScrollToCurrent) {
                    this._nextRedrawScrollToCurrent = false;
                    var maxScroll = newOffset - this._metrics.windowMetrics.emHeight * 2;
                    var minScroll = newOffset - this._metrics.hostHeight + this._metrics.windowMetrics.emHeight * 3;
                    var newScrollTop = this._scrollTop < minScroll ? minScroll :
                        this._scrollTop > maxScroll ? maxScroll :
                            -1;
                    if (newScrollTop >= 0) {
                        //console.log('redraw: scroll to current [' + newScrollTop + ']');
                        this._host.scrollTop = newScrollTop;
                    }
                }
                else {
                    var prevDistanceFromCenter = prevOffset - (this._scrollTop + this._scrollTopHeight / 2);
                    var newScrollTop = newOffset - prevDistanceFromCenter - this._metrics.hostHeight / 2;
                    //console.log({
                    //  prevDistanceFromCenter, prevOffset, this_scrollTop: this._scrollTop, this_scrollTopHeight: this._scrollTopHeight,
                    //  newOffset, this_metrics_hostHeight: this._metrics.hostHeight, newScrollTop
                    //});
                    //console.log('redraw: scroll to approximate prev. [' + newScrollTop + ']');
                    this._host.scrollTop = newScrollTop;
                }
                this._redrawRequested = 0;
                // end of _redrawNow()
            };
            Panel.prototype._removeExcessPages = function (expectedCount) {
                for (var i = this._pages.length - 1; i >= expectedCount; i--) {
                    var p = this._pages[i];
                    p.pageDIV.parentElement.removeChild(p.pageDIV);
                    if (p.leadPaddingDIV)
                        p.leadPaddingDIV.parentElement.removeChild(p.leadPaddingDIV);
                }
                if (this._pages.length > expectedCount)
                    this._pages = this._pages.slice(0, expectedCount);
            };
            Panel.prototype._removeExcessColumns = function (p, expectedCount) {
                for (var i = p.columns.length - 1; i >= expectedCount; i--) {
                    var c = p.columns[i];
                    c.columnDIV.parentElement.removeChild(c.columnDIV);
                }
                if (p.columns.length > expectedCount)
                    p.columns = p.columns.slice(0, expectedCount);
            };
            Panel.prototype._removeExcessEntries = function (c, expectedCount) {
                for (var i = c.entries.length - 1; i >= expectedCount; i--) {
                    var e = c.entries[i];
                    e.entryDIV.parentElement.removeChild(e.entryDIV);
                }
                if (c.entries.length > expectedCount)
                    c.entries = c.entries.slice(0, expectedCount);
            };
            Panel.prototype._onscroll = function () {
                if (this._redrawRequested)
                    return;
                this._scrollTop = this._host.scrollTop;
                this._scrollTopHeight = this._metrics.hostHeight;
                //console.log('onscroll ' + this._scrollTop);
            };
            Panel.prototype._calcPageIndex = function (indexOfEntry) {
                return (indexOfEntry / (this._columnsOnPage * this._entriesInColumn)) | 0;
            };
            Panel.prototype._calcColumnIndex = function (indexOfEntry) {
                return ((indexOfEntry / this._entriesInColumn) | 0) % this._columnsOnPage;
            };
            Panel.prototype._calcEntryIndex = function (indexOfEntry) {
                return indexOfEntry % this._entriesInColumn;
            };
            Panel.prototype._calcEntryTopOffset = function (indexOfEntry) {
                if (!this._metrics || !this._metrics.windowMetrics)
                    return 0;
                var pageIndex = this._calcPageIndex(indexOfEntry);
                var entryIndex = this._calcEntryIndex(indexOfEntry);
                var offset = pageIndex * this._entriesInColumn * this._metrics.windowMetrics.emHeight +
                    Math.max(0, pageIndex - 1) * this._pageInterval +
                    entryIndex * this._metrics.windowMetrics.emHeight; // distance from the top of the page
                return offset;
            };
            return Panel;
        })();
        panels.Panel = Panel;
        var Panel;
        (function (Panel) {
            (function (EntryFlags) {
                EntryFlags[EntryFlags["Directory"] = 1] = "Directory";
            })(Panel.EntryFlags || (Panel.EntryFlags = {}));
            var EntryFlags = Panel.EntryFlags;
            (function (SelectionFlags) {
                SelectionFlags[SelectionFlags["None"] = 0] = "None";
                SelectionFlags[SelectionFlags["Current"] = 1] = "Current";
                SelectionFlags[SelectionFlags["Selected"] = 2] = "Selected";
            })(Panel.SelectionFlags || (Panel.SelectionFlags = {}));
            var SelectionFlags = Panel.SelectionFlags;
        })(Panel = panels.Panel || (panels.Panel = {}));
    })(panels = shell.panels || (shell.panels = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var panels;
    (function (panels) {
        var panelHMargin = 10;
        var panelVMargin = 5;
        var TwoPanels = (function () {
            function TwoPanels(_host, leftPath, rightPath, _drive) {
                var _this = this;
                this._host = _host;
                this._drive = _drive;
                this.ondoubleclick = null;
                this._scrollHost = elem('div', { className: 'panels-scroll-host' }, this._host);
                this._scrollContent = elem('div', { className: 'panels-scroll-content' }, this._scrollHost);
                this._leftPanelHost = elem('div', { className: 'panels-panel panels-left-panel' }, this._scrollContent);
                this._rightPanelHost = elem('div', { className: 'panels-panel panels-right-panel' }, this._scrollContent);
                this._directoryService = panels.driveDirectoryService(this._drive);
                this._leftPanel = new panels.Panel(this._leftPanelHost, leftPath, this._directoryService);
                this._rightPanel = new panels.Panel(this._rightPanelHost, rightPath, this._directoryService);
                this._leftPanel.activate();
                /*
                TODO: ensure focus stays with the text input at the bottom
                elem.on(this._leftPanel, 'mousedown', e=> {
                  if (e.preventDefault)
                    e.preventDefault();
                  return false;
                }); */
                on(this._leftPanelHost, 'click', function (e) { return _this._onclick(e, true /*isLeft*/); });
                on(this._rightPanelHost, 'click', function (e) {
                    var handled = _this._onclick(e, false /*isLeft*/);
                    if (handled) {
                        if (e.preventDefault)
                            e.preventDefault();
                    }
                });
                this._leftPanel.ondoubleclick = function () { return _this.ondoubleclick(); };
                this._rightPanel.ondoubleclick = function () { return _this.ondoubleclick(); };
            }
            TwoPanels.prototype.setPath = function (path) {
                var norm = normalizePath(path || '');
                if (norm !== '/' && norm.slice(-1) === '/')
                    norm = norm.slice(0, norm.slice.length - 1);
                if (norm !== '/') {
                    // check if valid path
                    var parent = norm.slice(0, norm.lastIndexOf('/'));
                    var siblings = this._directoryService(parent);
                    var foundAndDir = false;
                    for (var i = 0; i < siblings.length; i++) {
                        if (siblings[i].path === norm && siblings[i].flags & panels.Panel.EntryFlags.Directory) {
                            foundAndDir = true;
                            break;
                        }
                    }
                    if (!foundAndDir)
                        return false;
                }
                this._getPanel(this.isLeftActive()).set({ currentPath: norm });
                return true;
                function normalizePath(path) {
                    if (!path)
                        return '/'; // empty paths converted to root
                    if (path.charAt(0) !== '/')
                        path = '/' + path;
                    path = path.replace(/\/\/*/g, '/'); // replacing duplicate slashes with single
                    return path;
                }
            };
            TwoPanels.prototype.measure = function () {
            };
            TwoPanels.prototype.arrange = function (metrics) {
                var contentWidth = 0;
                if (metrics.hostWidth < metrics.emWidth * 80 && metrics.hostWidth < metrics.hostHeight * 1) {
                    // flippable layout
                    contentWidth = Math.max(metrics.hostWidth / 2, metrics.hostWidth * 2 - metrics.emWidth * 4);
                }
                else {
                    // full layout
                    contentWidth = metrics.hostWidth;
                }
                var bottomGap = Math.min(metrics.hostHeight / 3, metrics.emHeight * 5.5);
                this._scrollHost.style.width = metrics.hostWidth + 'px';
                var panelsHeight = metrics.hostHeight - bottomGap;
                this._scrollHost.style.height = panelsHeight + 'px';
                this._scrollContent.style.width = contentWidth + 'px';
                this._scrollContent.style.height = panelsHeight + 'px';
                var panelWidth = (contentWidth / 2 - 0.5) | 0;
                this._leftPanelHost.style.height = panelsHeight + 'px';
                this._leftPanelHost.style.width = panelWidth + 'px';
                this._rightPanelHost.style.height = panelsHeight + 'px';
                this._rightPanelHost.style.width = panelWidth + 'px';
                if (this._leftPanelHost.style.display !== 'none') {
                    this._leftPanel.arrange({
                        windowMetrics: metrics,
                        hostWidth: panelWidth - panelHMargin * 2,
                        hostHeight: panelsHeight - panelVMargin * 2
                    });
                }
                if (this._rightPanelHost.style.display !== 'none') {
                    this._rightPanel.arrange({
                        windowMetrics: metrics,
                        hostWidth: panelWidth - panelHMargin * 2,
                        hostHeight: panelsHeight - panelVMargin * 2
                    });
                }
            };
            TwoPanels.prototype.isVisible = function () {
                return this._scrollHost.style.display !== 'none';
            };
            TwoPanels.prototype.toggleVisibility = function () {
                this._scrollHost.style.display = this.isVisible() ? 'none' : 'block';
            };
            TwoPanels.prototype.isLeftActive = function () {
                return this._leftPanel.isActive();
            };
            TwoPanels.prototype.toggleActivePanel = function () {
                if (!this.isVisible())
                    return;
                var isLeftActive = this._leftPanel.isActive();
                this._getPanel(isLeftActive).deactivate();
                this._getPanel(!isLeftActive).activate();
            };
            TwoPanels.prototype.temporarilyHidePanels = function () {
                var _this = this;
                var start = +new Date();
                var stayTime = 200;
                var fadeTime = 500;
                var opacity = 0.1;
                var applyOpacity = function () {
                    _this._scrollHost.style.opacity = opacity;
                    _this._scrollHost.style.filter = 'alpha(opacity=' + (opacity * 100) + ')';
                };
                applyOpacity();
                var animateBack = function () {
                    animateBack = function () { };
                    var startFade = function () {
                        var fadeStart = +new Date();
                        var ani = setInterval(function () {
                            var passed = (Date.now ? Date.now() : +new Date()) - fadeStart;
                            if (passed > fadeTime) {
                                clearInterval(ani);
                                _this._scrollHost.style.opacity = null;
                                _this._scrollHost.style.filter = null;
                                return;
                            }
                            opacity = passed / fadeTime;
                            applyOpacity();
                        }, 1);
                    };
                    var sinceStart = +new Date() - start;
                    if (sinceStart >= stayTime) {
                        startFade();
                    }
                    else {
                        setTimeout(startFade, fadeTime - sinceStart);
                    }
                };
                return animateBack;
            };
            TwoPanels.prototype.keydown = function (e) {
                switch (e.keyCode) {
                    case 38:
                        return this._selectionGo(-1);
                    case 40:
                        return this._selectionGo(+1);
                    case 33:
                        return this._selectionGo(-100);
                    case 34:
                        return this._selectionGo(+100);
                    case 37:
                        return this._selectionGo(-10);
                    case 39:
                        return this._selectionGo(+10);
                    case 9:
                        this.toggleActivePanel();
                        return true;
                    case 86:
                        if (e.ctrlKey || e.metaKey)
                            return this.togglePanelPaths();
                        break;
                    case 112:
                        if (e.ctrlKey || e.metaKey) {
                            return this.togglePartHidden(true);
                        }
                        break;
                    case 113:
                        if (e.ctrlKey || e.metaKey) {
                            return this.togglePartHidden(false);
                        }
                        break;
                    case 13:
                        var activePa = this._getPanel(this.isLeftActive());
                        return activePa.navigateCursor();
                    default:
                        if (e.ctrlKey) {
                        }
                        break;
                }
                return false;
            };
            TwoPanels.prototype.togglePartHidden = function (leftPanel) {
                var togglePanelHost = this._getPanelHost(leftPanel);
                var oppositePanelHost = this._getPanelHost(!leftPanel);
                if (!this.isVisible()) {
                    togglePanelHost.style.display = 'block';
                    oppositePanelHost.style.display = 'none';
                    if (this.isLeftActive() !== leftPanel)
                        this.toggleActivePanel();
                    this.toggleVisibility();
                }
                else {
                    if (togglePanelHost.style.display !== 'none') {
                        if (oppositePanelHost.style.display === 'none') {
                            togglePanelHost.style.display = 'block';
                            this.toggleVisibility();
                        }
                        else {
                            togglePanelHost.style.display = 'none';
                            if (this.isLeftActive() === leftPanel)
                                this.toggleActivePanel();
                        }
                    }
                    else {
                        togglePanelHost.style.display = 'block';
                    }
                }
                return true;
            };
            TwoPanels.prototype.togglePanelPaths = function () {
                console.log('Ctrl+U toggle is not implemented.');
                return false;
            };
            TwoPanels.prototype.cursorPath = function () {
                if (!this.isVisible())
                    return null;
                var pan = this._getPanel(this.isLeftActive());
                return pan.cursorPath();
            };
            TwoPanels.prototype.currentPath = function () {
                if (!this.isVisible())
                    return null;
                var pan = this._getPanel(this.isLeftActive());
                return pan.currentPath();
            };
            TwoPanels.prototype.cursorOppositePath = function () {
                if (!this.isVisible())
                    return null;
                var pan = this._getPanel(!this.isLeftActive());
                return pan.cursorPath();
            };
            TwoPanels.prototype.currentOppositePath = function () {
                if (!this.isVisible())
                    return null;
                var pan = this._getPanel(!this.isLeftActive());
                return pan.currentPath();
            };
            TwoPanels.prototype._selectionGo = function (direction) {
                var panel = this._getPanel(this.isLeftActive()).cursorGo(direction);
                return true;
            };
            TwoPanels.prototype._getPanel = function (left) {
                return left ? this._leftPanel : this._rightPanel;
            };
            TwoPanels.prototype._getPanelHost = function (left) {
                return left ? this._leftPanelHost : this._rightPanelHost;
            };
            TwoPanels.prototype._onclick = function (e, isLeft) {
                if (isLeft !== this.isLeftActive())
                    this.toggleActivePanel();
                var panel = this._getPanel(isLeft);
                return panel.handleClick(e);
            };
            return TwoPanels;
        })();
        panels.TwoPanels = TwoPanels;
    })(panels = shell.panels || (shell.panels = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var panels;
    (function (panels) {
        function driveDirectoryService(drive) {
            return function (path) {
                var pathPrefix = path === '/' ? path : path + '/';
                var result = [];
                var resByName = {};
                var files = drive.files();
                for (var i = 0; i < files.length; i++) {
                    var fi = files[i];
                    if (fi.length < pathPrefix.length + 1)
                        continue;
                    if (fi.slice(0, pathPrefix.length) !== pathPrefix)
                        continue;
                    var name;
                    var entryPath = fi;
                    var isDirectory = false;
                    var nextSlashPos = fi.indexOf('/', pathPrefix.length);
                    if (nextSlashPos < 0) {
                        name = fi.slice(pathPrefix.length);
                    }
                    else {
                        name = fi.slice(pathPrefix.length, nextSlashPos);
                        entryPath = fi.slice(0, nextSlashPos);
                        isDirectory = true;
                    }
                    if (resByName.hasOwnProperty(name))
                        continue;
                    var entry = { path: entryPath, name: name, flags: isDirectory ? panels.Panel.EntryFlags.Directory : 0 };
                    result.push(entry);
                    resByName[name] = entry;
                }
                return result;
            };
        }
        panels.driveDirectoryService = driveDirectoryService;
    })(panels = shell.panels || (shell.panels = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    function start(complete) {
        var drive = require('nodrive');
        var parentWin = require('nowindow');
        parentWin.document.body.background = 'black';
        if (parentWin.document.parentElement)
            parentWin.document.parentElement.body.background = 'black';
        document.body.style.overflow = 'hidden';
        document.body.parentElement.style.overflow = 'hidden';
        var commander = new shell.CommanderShell(document.body, drive, complete);
    }
    shell.start = start;
})(shell || (shell = {}));
var shell;
(function (shell) {
    var terminal;
    (function (terminal) {
        var CommandHistory = (function () {
            function CommandHistory() {
                this._history = [new terminal.CommandHistoryEntry()];
                this._index = 0;
            }
            CommandHistory.prototype.persistAndStartNew = function (input) {
                if (!(input.value || '').replace(/\s/g, '')) {
                    if (this._index === this._history.length - 1)
                        return; // it's already empty, and it's the last entry too
                    this._history[this._index].restore();
                    if (this._history[this._index].edit.replace(/\s/g, ''))
                        this._history.push(new terminal.CommandHistoryEntry());
                }
                else {
                    if (this._index === this._history.length - 1) {
                        this._history[this._index].storeEdit(input);
                        this._history.push(new terminal.CommandHistoryEntry());
                    }
                    else {
                        this._history[this._index].restore();
                        if (!this._history[this._history.length - 1].text) {
                            if (this._history[this._history.length - 1].edit)
                                this._history[this._history.length - 1].text = this._history[this._history.length - 1].edit;
                            else
                                this._history.pop();
                        }
                        else if (!this._history[this._history.length - 1].edit) {
                            this._history[this._history.length - 1].edit = this._history[this._history.length - 1].text;
                        }
                        this._history.push(new terminal.CommandHistoryEntry(input));
                        this._history.push(new terminal.CommandHistoryEntry());
                    }
                }
                this._index = this._history.length - 1;
                input.value = '';
            };
            CommandHistory.prototype.scrollUp = function (input) {
                return this._scroll(input, -1);
            };
            CommandHistory.prototype.scrollDown = function (input) {
                return this._scroll(input, +1);
            };
            CommandHistory.prototype._scroll = function (input, step) {
                var newIndex = this._index + step;
                if (newIndex < 0 || newIndex >= this._history.length)
                    return false;
                this._history[this._index].storeEdit(input);
                this._index = newIndex;
                this._history[this._index].applyTo(input);
            };
            return CommandHistory;
        })();
        terminal.CommandHistory = CommandHistory;
    })(terminal = shell.terminal || (shell.terminal = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var terminal;
    (function (terminal) {
        var CommandHistoryEntry = (function () {
            function CommandHistoryEntry(takeContent) {
                if (takeContent) {
                    this.storeEdit(takeContent);
                    this.text = this.edit;
                }
                else {
                    this.edit = this.text = '';
                    this.start = this.end = 0;
                }
            }
            CommandHistoryEntry.prototype.storeEdit = function (takeContent) {
                this.edit = takeContent.value;
                if (!this.text)
                    this.text = this.edit;
                if ('selectionStart' in takeContent) {
                    this.start = takeContent.selectionStart;
                    this.end = takeContent.selectionEnd;
                }
                else {
                    this._tryStoreSelectionIE(takeContent);
                }
            };
            CommandHistoryEntry.prototype.applyTo = function (takeContent) {
                var _this = this;
                takeContent.value = this.edit;
                this._applySelection(takeContent);
                setTimeout(function () {
                    if (takeContent.value === _this.edit)
                        _this._applySelection(takeContent);
                }, 1);
            };
            CommandHistoryEntry.prototype.restore = function () {
                this.edit = this.text;
            };
            CommandHistoryEntry.prototype._applySelection = function (input) {
                if ('selectionStart' in input) {
                    input.selectionStart = this.start;
                    input.selectionEnd = this.end;
                }
                else {
                    this._tryApplySelectionIE(input);
                }
            };
            CommandHistoryEntry.prototype._tryStoreSelectionIE = function (input) {
                var selection = document.selection;
                var range = selection ? selection.createRange() : null;
                if (!range || range.parentElement() !== input)
                    return false;
                var len = input.value.length;
                var normalizedValue = input.value.replace(/\r\n/g, "\n");
                // Create a working TextRange that lives only in the input
                var textInputRange = input.createTextRange();
                textInputRange.moveToBookmark(range.getBookmark());
                // Check if the start and end of the selection are at the very end
                // of the input, since moveStart/moveEnd doesn't return what we want
                // in those cases
                var endRange = input.createTextRange();
                endRange.collapse(false);
                if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
                    this.start = this.end = len;
                    return true;
                }
                this.start = -textInputRange.moveStart("character", -len);
                this.start += normalizedValue.slice(0, this.start).split("\n").length - 1;
                if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1) {
                    this.end = len;
                }
                else {
                    this.end = -textInputRange.moveEnd("character", -len);
                    this.end += normalizedValue.slice(0, this.end).split("\n").length - 1;
                }
                return true;
            };
            CommandHistoryEntry.prototype._tryApplySelectionIE = function (input) {
                if (!input.createTextRange)
                    return false;
                var range = input.createTextRange();
                range.collapse(true);
                range.moveStart('character', this.start);
                range.moveEnd('character', this.end);
                range.select();
            };
            return CommandHistoryEntry;
        })();
        terminal.CommandHistoryEntry = CommandHistoryEntry;
    })(terminal = shell.terminal || (shell.terminal = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var terminal;
    (function (terminal) {
        var Terminal = (function () {
            function Terminal(_host, _repl) {
                var _this = this;
                this._host = _host;
                this._repl = _repl;
                this._promptWidth = 0;
                this._historyContentHeight = 0;
                this._hostMetrics = null;
                this._commandHistory = new terminal.CommandHistory();
                this.onexecute = null;
                this._history = elem('div', { className: 'terminal-history' }, this._host);
                this._historyContent = elem('pre', {
                    className: 'terminal-history-content',
                    text: 'Hello world from mini-shell\n\nVersion 0.7s\n' + shell.buildMessage + '\nOleg Mihailik\n\nPlease be careful.'
                }, this._history);
                this._prompt = elem('div', { className: 'terminal-prompt', text: '>' }, this._host);
                this._input = elem('textarea', { className: 'terminal-input', autofocus: true }, this._host);
                this._input.setAttribute('autocorrect', 'off');
                this._input.setAttribute('autocapitalize', 'off');
                setTimeout(function () { return _this._input.focus(); }, 1);
            }
            Terminal.prototype.writeDirect = function (text) {
                elem('div', { text: text, opacity: 0.4 }, this._historyContent);
                if (this._hostMetrics) {
                    this.measure();
                    this.arrange(this._hostMetrics);
                }
            };
            Terminal.prototype.log = function (args) {
                terminal.log(args, this._historyContent);
                if (this._hostMetrics) {
                    this.measure();
                    this.arrange(this._hostMetrics);
                }
            };
            Terminal.prototype.isInputEmpty = function () {
                return !this._input.value;
            };
            Terminal.prototype.getInput = function () {
                return (this._input.value || '').replace(/[\r\n]/g, '');
            };
            Terminal.prototype.focus = function () {
                this._input.focus();
            };
            Terminal.prototype.temporarilyHidePrompt = function (replacementText) {
                // TODO: hide prompt, display replacement text instead
                return function () { };
            };
            Terminal.prototype.measure = function () {
                this._promptWidth = this._prompt.offsetWidth;
                this._historyContentHeight = this._historyContent.offsetHeight;
            };
            Terminal.prototype.arrange = function (metrics) {
                this._hostMetrics = metrics;
                this._history.style.width = metrics.hostWidth + 'px';
                this._history.style.bottom = (metrics.emHeight * 2.2) + 'px';
                if (metrics.hostHeight - metrics.emHeight * 2.2 > this._historyContentHeight) {
                    this._history.style.height = this._historyContentHeight + 'px';
                }
                else {
                    this._history.style.height = (metrics.hostHeight - metrics.emHeight * 2.2) + 'px';
                    this._history.scrollTop = this._historyContentHeight - (metrics.hostHeight - metrics.emHeight * 2);
                }
                this._input.style.left = this._promptWidth + 'px';
                this._input.style.width = (metrics.hostWidth - this._promptWidth) + 'px';
            };
            Terminal.prototype.storeAsHistory = function (command) {
                this._commandHistory.persistAndStartNew(this._input);
                this._input.value = command;
                this._commandHistory.persistAndStartNew(this._input);
            };
            Terminal.prototype.keydown = function (e, cursorPath) {
                if (e.keyCode === 27) {
                    this._input.value = '';
                    return true;
                }
                else if (e.keyCode === 38) {
                    return this._commandHistory.scrollUp(this._input);
                }
                else if (e.keyCode === 40) {
                    return this._commandHistory.scrollDown(this._input);
                }
                else if (e.keyCode === 13) {
                    var code = this.getInput();
                    this._commandHistory.persistAndStartNew(this._input);
                    if (code) {
                        if (code.slice(-2) === '\r\n')
                            code = code.slice(0, code.length - 2);
                        this._input.value = '';
                        elem('div', {
                            text: code,
                            color: 'gray'
                        }, this._historyContent);
                        this._evalAndLogResults(code);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            };
            Terminal.prototype._evalAndLogResults = function (code) {
                var result;
                try {
                    if (this.onexecute) {
                        result = this.onexecute(code);
                    }
                    else {
                        result = this._repl.eval(code);
                    }
                }
                catch (error) {
                    elem('div', {
                        text: error && error.stack ? error.stack : error,
                        color: 'red'
                    }, this._historyContent);
                    if (this._hostMetrics) {
                        this.measure();
                        this.arrange(this._hostMetrics);
                    }
                    return;
                }
                if (typeof result !== 'undefined')
                    this.log([result]);
            };
            return Terminal;
        })();
        terminal.Terminal = Terminal;
    })(terminal = shell.terminal || (shell.terminal = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var terminal;
    (function (terminal) {
        function log(args, historyContent) {
            var output = elem('div', historyContent);
            for (var i = 0; i < args.length; i++) {
                if (i > 0)
                    elem('span', { text: ' ' }, output);
                if (args[i] === null) {
                    elem('span', { text: 'null', color: 'green' }, output);
                }
                else {
                    terminal.logAppendObj(args[i], output, 0);
                }
            }
        }
        terminal.log = log;
    })(terminal = shell.terminal || (shell.terminal = {}));
})(shell || (shell = {}));
var shell;
(function (shell) {
    var terminal;
    (function (terminal) {
        function logAppendObj(obj, output, level) {
            switch (typeof obj) {
                case 'number':
                case 'boolean':
                    elem('span', { text: obj, color: 'green' }, output);
                    break;
                case 'undefined':
                    elem('span', { text: 'undefined', color: 'green', opacity: 0.5 }, output);
                    break;
                case 'function':
                    var funContainer = elem('span', output);
                    var funFunction = elem('span', { text: 'function ', color: 'silver', opacity: 0.5 }, funContainer);
                    var funName = elem('span', { text: obj.name, color: 'cornflowerblue', fontWeight: 'bold' }, funContainer);
                    funContainer.title = obj;
                    break;
                case 'string':
                    var strContainer = elem('span', output);
                    elem('span', { text: '"', color: 'tomato' }, strContainer);
                    elem('span', { text: obj, color: 'tomato', opacity: 0.5 }, strContainer);
                    elem('span', { text: '"', color: 'tomato' }, strContainer);
                    break;
                default:
                    if (obj === null) {
                        elem('span', { text: 'null', color: 'green', opacity: 0.5 }, output);
                        break;
                    }
                    if (typeof obj.getFullYear === 'function' && typeof obj.getTime === 'function' && typeof obj.constructor.parse === 'function') {
                        elem('span', { text: 'Date(', color: 'green', opacity: 0.5 }, output);
                        elem('span', { text: obj, color: 'green' }, output);
                        elem('span', { text: ')', color: 'green', opacity: 0.5 }, output);
                        break;
                    }
                    if (obj.constructor && obj.constructor.name !== 'Object' && obj.constructor.name !== 'Array') {
                        elem('span', { text: obj.constructor.name, color: 'cornflowerblue' }, output);
                        if (obj.constructor.prototype && obj.constructor.prototype.constructor
                            && obj.constructor.prototype.constructor.name
                            && obj.constructor.prototype.constructor.name !== 'Object' && obj.constructor.prototype.constructor.name !== 'Array'
                            && obj.constructor.prototype.constructor.name !== obj.constructor.name)
                            elem('span', { text: ':' + obj.constructor.prototype.constructor.name, color: 'cornflowerblue', opacity: 0.5 }, output);
                        elem('span', output);
                    }
                    if (typeof obj.length === 'number' && obj.length >= 0) {
                        elem('span', { text: '[', color: 'white' }, output);
                        if (level > 1) {
                            elem('span', { text: '...', color: 'silver' }, output);
                        }
                        else {
                            for (var i = 0; i < obj.length; i++) {
                                if (i > 0)
                                    elem('span', { text: ', ', color: 'gray' }, output);
                                if (typeof obj[i] !== 'undefined')
                                    logAppendObj(obj[i], output, level + 1);
                            }
                        }
                        elem('span', { text: ']', color: 'white' }, output);
                    }
                    else if (obj.createElement + '' === document.createElement + '' && obj.getElementById + '' === document.getElementById + '' && 'title' in obj) {
                        elem('span', { text: '#document ' + obj.title, color: 'green' }, output);
                    }
                    else if (obj.setInterval + '' === window.setInterval + '' && obj.setTimeout + '' === window.setTimeout + '' && 'location' in obj) {
                        elem('span', { text: '#window ' + obj.location, color: 'green' }, output);
                    }
                    else if (typeof obj.tagName === 'string' && obj.getElementsByTagName + '' === document.body.getElementsByTagName + '') {
                        elem('span', { text: '<' + obj.tagName + '>', color: 'green' }, output);
                    }
                    else if (obj + '' !== '[Object]') {
                        elem('span', { text: '{', color: 'cornflowerblue' }, output);
                        if (level > 1) {
                            elem('span', { text: '...', color: 'cornflowerblue', opacity: 0.5 }, output);
                        }
                        else {
                            var first = true;
                            var hadMessage = false;
                            for (var k in obj) {
                                if (obj.hasOwnProperty && !obj.hasOwnProperty(k))
                                    continue;
                                if (first) {
                                    first = false;
                                }
                                else {
                                    elem('span', { text: ', ', color: 'cornflowerblue', opacity: 0.3 }, output);
                                    first = false;
                                }
                                elem('span', { text: k, color: 'cornflowerblue', fontWeight: 'bold' }, output);
                                elem('span', { text: ': ', color: 'cornflowerblue', opacity: 0.5 }, output);
                                logAppendObj(obj[k], output, level + 1);
                                if (k === 'message')
                                    hadMessage = true;
                            }
                            if (typeof obj.message === 'string' && !hadMessage) {
                                elem('span', { text: 'message', color: 'tomato', fontWeight: 'bold' }, output);
                                elem('span', { text: ': ', color: 'tomato', opacity: 0.5 }, output);
                                elem('span', { text: obj.message, color: 'tomato' }, output);
                            }
                        }
                        elem('span', { text: '}', color: 'cornflowerblue' }, output);
                    }
                    else {
                        elem('span', { text: obj, color: 'cornflowerblue' }, output);
                    }
                    break;
            }
        }
        terminal.logAppendObj = logAppendObj;
    })(terminal = shell.terminal || (shell.terminal = {}));
})(shell || (shell = {}));

-->

<!-- /shell/buildMessage.js

var shell;
if (!shell) shell = {};
shell.buildMessage = 'Built at 30 Jul 2015 21:42:56.481 GMT+0100';

shell.buildTime = 1438288976488;
-->

<!-- /shell/!onerror.js
window.__boot_times = window.__boot_times || {};
window.__boot_times.onerror_start = +new Date();

window.onerror = function onerror() {

  var msg = [];
  for (var i = 0; i < arguments.length; i++) {
    var a = arguments[i];
    if (a && (typeof a === 'object')) {

      if (a.stack) {
        msg.push(a.stack);
      }
      else {
        var msg1 = [];
        for (var k in a) {
          var r = a[k];
          if (typeof r === 'function' || (typeof r === 'object' && !r)) continue;
          msg1.push(k+':'+r);
        }
        msg.push(msg1.join(', '));
      }
    }
    else {
      msg.push(a===null ? 'null' : a);
    }

  }

  alert(msg.join('\n'));

}
-->

<!-- /empty/
-->


<!-- /LF-file.txt
123
456-->

<!-- /CRLF-file [CRLF]
123
456-->

<!-- /CR-file [CR]
123
456-->

<!-- /exportsome.js [CR]
module.exports = 55-->

<!-- /exports_fs.js [CR]
module.exports = require('fs')-->

<!-- /exports_process.js [CR]
module.exports = process-->

<!-- /eval-file.txt [eval]
 "random char: " + String.fromCharCode(Math.random()*16000)+"\n"+
 "date: "+new Date()+"\n"+
 "location: "+location -->

<!-- /json-file.txt [json]
"new ok \u2222 and what\r\n or \u0001?\n\n\n"-->










<!-- /shell/style.css
.panels-scroll-host {
  position: absolute;
  left: 0; top: 0; width: 0; height: 0;
  overflow: auto;
  overflow-y: hidden;
  background: black;
  background: transparent;
}

.panels-scroll-content {
  width: 0; height: 0;   overflow: hidden;
}

.panels-panel {
  width: 0; height: 0;
  overflow: auto;
  overflow-x: hidden;
  background: rgba(4, 12, 64, 0.95) !important;
  background: navy;
  color: darkcyan;
  padding-top: 10px;
  padding-bottom: 10px;
  cursor: default;
}

.panels-panel * {
  cursor: default;
}

.panels-left-panel {
  float: left;
}

.panels-right-panel {
  float: right;
}

.panels-panel-page {
  clear: both;
}

.panels-page-separator {
  clear: both;
}

.panels-panel-column {
  float: left;
}

.panels-entry {
  padding-left: 10px;
  padding-right: 10px;
}

.panels-entry-dir {
  color: white;
}

.panels-panel-active .panels-entry-current {
  background: darkcyan;
}

.panels-panel-active .panels-entry-file-current {
  color: navy;
}

::-webkit-scrollbar {
    width: 0.5em;
    height: 0.5em
}
.terminal-history {
  position: absolute;
  left: 0; bottom: 1.6em;
  width: 100%; height: 0;
  overflow-y: auto;
  overflow-x: hidden;
}

.terminal-history-content {
  margin: 0; padding: 0;
}

.terminal-prompt {
  position: absolute;
  left: 0; bottom: 1.5em;
  height: 1em;
}

.terminal-input {
  position: absolute;
  left: 0; bottom: 1.5em;
  width: 0; height: 1em;
  font: inherit;
  border: none;
  background: transparent;
  color: silver;
  outline: none;
  resize: none;
  overflow: hidden;
}
-->




















































































































































































































































































































































<iframe style="position: absolute; left: 0px; top: 0px; width: 1366px; height: 677px; border: none; opacity: 1;"></iframe></body></html>