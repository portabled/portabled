// <script>document.body.innerHTML = '' </script> <script id=submodule_script>

  

function isolation() {

	isolation.build = {
    timestamp: 1465366247781, // Wed Jun 08 2016 07:10:47 GMT+0100 (GMT Daylight Time)
    taken: 18888,
    platform: "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36"
};

var createContextHost = (function () {
    var errorSer = createErrorSerializer();
    createContextHost.worker = createWebWorkerHost;
    createContextHost.iframe = createIFrameHost;
    return createContextHost;
    function createContextHost(drive, callback) {
        var tryUseWebWorker = detectWebWorkerHint();
        if (tryUseWebWorker) {
            try {
                createWebWorkerHost(drive, callback);
            }
            catch (webWorkerBarredError) {
                createIFrameHost(drive, callback);
            }
        }
        else {
            createIFrameHost(drive, callback);
        }
    }
    function detectWebWorkerHint() {
        try {
            return typeof Worker === 'function';
        }
        catch (webWorkerBarredError) {
            return false;
        }
    }
    function createWebWorkerHost(drive, callback) {
        var webWorker = createWebWorker();
        var diagTimeStart = +new Date();
        var requests = { count: 0 };
        webWorker.onmessage = webworker_onmessage;
        webWorker.postMessage({ init_worker_connect: true });
        var hst = {
            type: null,
            remoteEval: remoteEval_webworker,
            pushMessage: pushMessage_webworker,
            terminate: terminate_webworker,
            onerror: null,
            onmessage: null
        };
        var fs;
        function completeIsolatedProcess(type) {
            hst.type = type;
            callback(hst);
        }
        function webworker_onmessage(e) {
            if (e.data.requestInitSync) {
                handleRequestInitSync(e.data.requestInitSync);
            }
            else if (e.data.requestInitSync_completed) {
                handleRequestInitSync_completed(e.data.requestInitSync_completed);
            }
            else if (e.data.requestInitAsync) {
                handleRequestInitAsync(e.data.requestInitAsync);
            }
            else if (e.data.invokeSync) {
                handleInvokeSync(e.data.invokeSync);
            }
            else if (e.data.invokeAsync) {
                handleInvokeAsync(e.data.invokeAsync);
            }
            else if (e.data.remoteResponse) {
                handleRemoteResponse(e.data.remoteResponse);
            }
            else if (e.data.remoteErrorResponse) {
                handleRemoteErrorResponse(e.data.remoteErrorResponse);
            }
            else if (e.data.driveUpdates) {
                handleDriveUpdates(e.data);
            }
            else if (e.data.driveRequest_files) {
                handleDriveRequest_files(e.data.driveRequest_files);
            }
            else if (e.data.driveRequest_read) {
                handleDriveRequest_read(e.data.driveRequest_read);
            }
            else if (e.data.driveRequest_storedSize) {
                handleDriveRequest_storedSize(e.data.driveRequest_storedSize);
            }
            else if (e.data.key) {
                var req = requests[e.data.key];
                if (!req)
                    return;
                delete requests[e.data.key];
                req(e.data.error, e.data.result);
            }
            else {
                if (typeof console !== 'undefined' && console && typeof console.log === 'function') {
                    console.log('host: unknown message from webworker: ', e.data);
                }
            }
        }
        function handleRequestInitAsync(requestInitAsync) {
            var driveSnapshot = createDriveSnapshot();
            webWorker.postMessage({ driveSnapshot: driveSnapshot });
            completeIsolatedProcess('worker-async');
        }
        function handleRequestInitSync(requestInitSync) {
            createFS(tryReplyOK_waitForInitSyncOK);
            function tryReplyOK_waitForInitSyncOK(error, createdFS) {
                fs = createdFS;
                try {
                    writeFS(requestInitSync, '{ "driveTimestamp": ' + (drive.timestamp | 0) + ' }', function (error) {
                        if (error) {
                            var driveSnapshot = createDriveSnapshot();
                            webWorker.postMessage({ requestInitSync_reject: driveSnapshot });
                        }
                        // if succeeds, they see the file and know already
                    });
                }
                catch (error) {
                    var driveSnapshot = createDriveSnapshot();
                    webWorker.postMessage({ requestInitSync_reject: driveSnapshot });
                }
            }
        }
        function handleInvokeSync(invokeSync) {
            if (!hst.onmessage)
                return;
            hst.onmessage(invokeSync.msg, /*syncReply*/ true, function (error, response) {
                if (invokeSync.key) {
                    var responseMsg = {
                        error: error,
                        response: response
                    };
                    var responseStr = JSON.stringify(responseMsg);
                    writeFS(invokeSync.key, responseStr);
                }
            });
        }
        function handleInvokeAsync(invokeAsync) {
            if (!hst.onmessage)
                return;
            hst.onmessage(invokeAsync.msg, /*syncReply*/ false, function (error, response) {
                var error_serialized = errorSer.serialize(error);
                webWorker.postMessage({ asyncResponse: { key: invokeAsync.key, error: error_serialized, response: response } });
            });
        }
        function handleRemoteResponse(remoteResponse) {
            var req = requests[remoteResponse.key];
            if (!req)
                return;
            delete requests[remoteResponse.key];
            req(null, remoteResponse.result);
        }
        function handleRemoteErrorResponse(remoteErrorResponse) {
            var req = requests[remoteErrorResponse.key];
            if (!req)
                return;
            delete requests[remoteErrorResponse.key];
            var error_deserialized = errorSer.deserialize(remoteErrorResponse);
            req(error_deserialized);
        }
        function handleDriveUpdates(driveUpdates) {
            driveApplyUpdates(drive, driveUpdates);
        }
        function handleDriveRequest_files(cookie) {
            writeFS(cookie, JSON.stringify(drive.files()));
        }
        function handleDriveRequest_read(msg) {
            writeFS(msg.key, JSON.stringify(drive.read(msg.file)));
        }
        function handleDriveRequest_storedSize(msg) {
            var size;
            if (drive.storedSize)
                size = drive.storedSize(msg.file);
            else
                size = (drive.read(msg.file) || '').length;
            writeFS(msg.key, '' + size);
        }
        function createDriveSnapshot() {
            var driveSnapshot = { timestamp: drive.timestamp };
            var driveFiles = drive.files();
            for (var i = 0; i < driveFiles.length; i++) {
                driveSnapshot[driveFiles[i]] = drive.read(driveFiles[i]);
            }
            return driveSnapshot;
        }
        function handleRequestInitSync_completed(requestInitSync_completed) {
            completeIsolatedProcess('worker-sync');
        }
        function createFS(callback) {
            try {
                if (typeof requestFileSystem === 'function') {
                    var reqFS = requestFileSystem;
                    var reqFS_name = 'requestFileSystem';
                }
                else if (typeof webkitRequestFileSystem === 'function') {
                    var reqFS = webkitRequestFileSystem;
                    var reqFS_name = 'webkitRequestFileSystem';
                }
                else if (typeof mozRequestFileSystem === 'function') {
                    var reqFS = mozRequestFileSystem;
                    var reqFS_name = 'mozRequestFileSystem';
                }
                else if (typeof oRequestFileSystem === 'function') {
                    var reqFS = oRequestFileSystem;
                    var reqFS_name = 'oRequestFileSystem';
                }
                else if (typeof msRequestFileSystem === 'function') {
                    var reqFS = msRequestFileSystem;
                    var reqFS_name = 'msRequestFileSystem';
                }
                else {
                    callback(new Error('filesystem cannot be found'));
                    return;
                }
                var timeoutReqFS = setTimeout(function () {
                    clearTimeout(timeoutReqFS);
                    timeoutReqFS = 0;
                    callback(new Error('Waiting for ' + reqFS_name + ' timed out.'));
                }, 1000);
                reqFS('TEMPORARY', 1024, function (fs) {
                    if (timeoutReqFS) {
                        clearTimeout(timeoutReqFS);
                    }
                    else {
                        return; // timeout already fired, it's too late
                    }
                    callback(null, fs);
                });
            }
            catch (error) {
                callback(error);
            }
        }
        function writeFS(name, content, callback) {
            try {
                fs.root.getFile('/isolation-syncfs-aided--' + name, { create: true }, getFile_handler, callback);
            }
            catch (error) {
                if (callback)
                    callback(error);
            }
            function getFile_handler(fileEntry) {
                try {
                    fileEntry.createWriter(createWriter_handler, callback);
                }
                catch (error) {
                    if (callback)
                        callback(error);
                }
            }
            function createWriter_handler(fileWriter) {
                try {
                    if (callback) {
                        fileWriter.onwriteend = fileWriter_onwriteend;
                        fileWriter.onerror = callback;
                    }
                    var bb = new Blob([content]);
                    fileWriter.write(bb);
                }
                catch (error) {
                    if (callback)
                        callback(error);
                }
            }
            function fileWriter_onwriteend(e) { callback(); }
        }
        function remoteEval_webworker(fnScript, arg, callback) {
            var key = (requests.count++).toString();
            // generate a bit of timestamp for the benefit of easier debugging
            if (Date.now)
                key += '-' + (Date.now() - diagTimeStart) + 'ms';
            else
                key += '-' + (+new Date() - diagTimeStart) + 'ms';
            requests[key] = function (error, result) {
                callback(error, result);
            };
            webWorker.postMessage({ remoteEval: { script: fnScript, arg: arg, key: key } });
        }
        function pushMessage_webworker(msg) {
            webWorker.postMessage({ pushMessage: msg });
        }
        function terminate_webworker() {
            webWorker.terminate();
        }
        function createWebWorker() {
            var worker_body = getWorkerAgentScript();
            worker_body += '\n//# ' + 'sourceURL=/isolation_worker_body.js';
            if (typeof Blob === 'function') {
                try {
                    return webWorkerFromBlob();
                }
                catch (errWebWorkerBlob) {
                    return webWorkerFromDataURI();
                }
            }
            else {
                try {
                    return webWorkerFromDataURI();
                }
                catch (errWorkerDataURI) {
                    return webWorkerFromBlob();
                }
            }
            function webWorkerFromDataURI() {
                var worker = new Worker('data:application/javascript,' + encodeURIComponent(worker_body));
                return worker;
            }
            function webWorkerFromBlob() {
                var blob = new Blob([worker_body], { type: 'text/javascript' });
                var url = URL.createObjectURL(blob);
                var worker = new Worker(url);
                return worker;
            }
        }
    }
    function createIFrameHost(drive, callback) {
        var frm = createIFrame();
        var hst = {
            type: 'iframe',
            remoteEval: remoteEval_iframe,
            pushMessage: pushMessage_iframe,
            terminate: terminate_iframe,
            onerror: null,
            onmessage: null
        };
        var registeredPushMessageCallbacks = [];
        var registeredPushMessageCallbacks_length = 0;
        callback(hst);
        function remoteEval_iframe(fnScript, arg, callback) {
            var fn = (0, frm.evalFN)('(function(){' + fnScript + '\n})');
            try {
                var result = fn(arg);
            }
            catch (error) {
                callback(error);
                return;
            }
            callback(null, result);
        }
        function pushMessage_iframe(msg) {
            for (var i = 0; i < registeredPushMessageCallbacks_length; i++) {
                var cb = registeredPushMessageCallbacks[i];
                if (cb)
                    cb(msg);
            }
        }
        function terminate_iframe() {
            if (frm && frm.ifr.parentElement) {
                frm.ifr.parentElement.removeChild(frm.ifr);
                frm = null;
            }
        }
        function onPushMessage(registerCallback) {
            var index = registeredPushMessageCallbacks_length;
            registeredPushMessageCallbacks.push(registerCallback);
            registeredPushMessageCallbacks_length++;
            return unregister_pushMessageCallback;
            function unregister_pushMessageCallback() {
                if (index < 0)
                    return;
                delete registeredPushMessageCallbacks[index];
                index = -1;
                // adjust the tail (removal of callbacks may run out of order)
                var newLength = registeredPushMessageCallbacks_length;
                while (!registeredPushMessageCallbacks[newLength] && newLength >= 0) {
                    newLength--;
                }
                if (newLength !== registeredPushMessageCallbacks_length)
                    registeredPushMessageCallbacks_length = newLength;
            }
        }
        function createIFrame() {
            var ifr = document.createElement('iframe');
            ifr.src = 'about:blank'; // TODO: explore loading from Blob/data URI directly
            ifr.style.cssText = 'display: none; position: absolute; left: -50px; top: -50px; width: 0px; height: 0px;';
            document.body.appendChild(ifr);
            var ifrwin = ifr.contentWindow || ifr.window;
            ifrwin.document.write('<' + 'script>window[" "] = (function(ev){ return function(){ return ev(arguments[0]); }; })(eval);</' + 'script>');
            var evalFN = ifrwin[" "];
            evalFN('window[" "]=void 0; (function(){arguments[0][0].parentElement.removeChild(arguments[0][0]);})(document.getElementsByTagName("script"));');
            var connection_to_parent = {
                drive: drive,
                invokeAsync: function (msg, callback) {
                    try {
                        hst.onmessage(msg, /*syncReply*/ true, callback);
                    }
                    catch (error) {
                        callback(error, null);
                    }
                },
                invokeSync: function (msg) {
                    var reply;
                    hst.onmessage(msg, /*syncReply*/ true, function (reply_passed) { return reply = reply_passed; });
                    return reply;
                },
                onPushMessage: onPushMessage
            };
            ifrwin.connection_to_parent = connection_to_parent;
            return { ifr: ifr, evalFN: evalFN, connection_to_parent: connection_to_parent };
        }
        ;
    }
    function getWorkerAgentScript() {
        return "function RUN_ASYNC_CHANNEL(driveSnapshot) {\n"+
  "    self_onmessage = ASYNC_CHANNEL_webworker_onmessage;\n"+
  "    var pushMessageDispatcher = createPushMessageDispatcher();\n"+
  "    var requestResponseDispatcher = createRequestResponseDispatcher();\n"+
  "    var drive = {\n"+
  "        timestamp: driveSnapshot.timestamp,\n"+
  "        files: files_ASYNC_CHANNEL,\n"+
  "        read: read_ASYNC_CHANNEL,\n"+
  "        write: write_ASYNC_CHANNEL,\n"+
  "        storedSize: storedSize_ASYNC_CHANNEL\n"+
  "    };\n"+
  "    var tmDrive = {\n"+
  "        timestamp: driveSnapshot.timestamp,\n"+
  "        write: driveUpdate_write_ASYNC_CHANNEL\n"+
  "    };\n"+
  "    connection_to_parent = {\n"+
  "        drive: drive,\n"+
  "        onPushMessage: pushMessageDispatcher.onPushMessage,\n"+
  "        invokeAsync: invokeAsync_ASYNC_CHANNEL\n"+
  "    };\n"+
  "    function invokeAsync_ASYNC_CHANNEL(msg, callback) {\n"+
  "        if (callback) {\n"+
  "            var key = requestResponseDispatcher.pushCallback(callback);\n"+
  "            postMessageToHost({ invokeAsync: { key: key, msg: msg } });\n"+
  "        }\n"+
  "        else {\n"+
  "            postMessageToHost({ invokeAsync: { msg: msg } });\n"+
  "        }\n"+
  "    }\n"+
  "    function ASYNC_CHANNEL_webworker_onmessage(e) {\n"+
  "        if (e.data.asyncResponse) {\n"+
  "            handleAsyncResponse_ASYNC_CHANNEL(e.data.asyncResponse);\n"+
  "        }\n"+
  "        else if (e.data.remoteEval) {\n"+
  "            handleRemoteEval_EITHER_CHANNEL(e.data.remoteEval);\n"+
  "        }\n"+
  "        else if (e.data.pushMessage) {\n"+
  "            pushMessageDispatcher.handlePushMessage(e.data.pushMessage);\n"+
  "        }\n"+
  "        else if (e.data.driveUpdates) {\n"+
  "            handleDriveUpdates_ASYNC_CHANNEL(e.data.driveUpdates);\n"+
  "        }\n"+
  "        else {\n"+
  "            reportUnknownMessage_ASYNC_CHANNEL(e);\n"+
  "        }\n"+
  "    }\n"+
  "    function handleAsyncResponse_ASYNC_CHANNEL(asyncResponse) {\n"+
  "        if (!asyncResponse.key) {\n"+
  "            reportKeylessResponse(asyncResponse);\n"+
  "            return;\n"+
  "        }\n"+
  "        var callback = requestResponseDispatcher.popCallback(asyncResponse.key);\n"+
  "        callback(asyncResponse.error && errorSer.serialize(asyncResponse.error), asyncResponse.result);\n"+
  "    }\n"+
  "    function handleDriveUpdates_ASYNC_CHANNEL(driveUpdates) {\n"+
  "        driveSnapshot.timestamp = Math.max(driveSnapshot.timestamp, driveUpdates.timestamp);\n"+
  "        driveApplyUpdates(tmDrive, driveUpdates);\n"+
  "    }\n"+
  "    function reportUnknownMessage_ASYNC_CHANNEL(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown in ASYNC_CHANNEL: ', e.data, e);\n"+
  "    }\n"+
  "    function driveUpdate_write_ASYNC_CHANNEL(file, content) {\n"+
  "        if (content || typeof content === 'string')\n"+
  "            driveSnapshot[file] = content;\n"+
  "        else\n"+
  "            delete driveSnapshot[file];\n"+
  "    }\n"+
  "    function reportKeylessResponse(asyncResponse) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: asyncResponse with no key: ', asyncResponse);\n"+
  "    }\n"+
  "    function createDriveFromSnapshot(snapshot) {\n"+
  "        var tmDrive = {\n"+
  "            timestamp: drive.timestamp,\n"+
  "            write: function (file, content) {\n"+
  "                drive.timestamp = Math.max(drive.timestamp, tmDrive.timestamp);\n"+
  "                if (content || typeof content === 'string')\n"+
  "                    driveSnapshot[file] = content;\n"+
  "                else\n"+
  "                    delete driveSnapshot[file];\n"+
  "            }\n"+
  "        };\n"+
  "        return drive;\n"+
  "    }\n"+
  "    function files_ASYNC_CHANNEL() {\n"+
  "        var result = [];\n"+
  "        for (var k in driveSnapshot) {\n"+
  "            if (k && k.charCodeAt(0) === 47)\n"+
  "                result.push(k);\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function read_ASYNC_CHANNEL(file) {\n"+
  "        var result = driveSnapshot[file];\n"+
  "        if (result || typeof result !== 'undefined')\n"+
  "            return result;\n"+
  "        else\n"+
  "            return null;\n"+
  "    }\n"+
  "    function write_ASYNC_CHANNEL(file, content) {\n"+
  "        var msg;\n"+
  "        if (!content && (content === null || typeof content === 'undefined')) {\n"+
  "            delete driveSnapshot[file];\n"+
  "            msg = { driveUpdates: [{ deleteFile: file }], timestamp: drive.timestamp };\n"+
  "        }\n"+
  "        else {\n"+
  "            driveSnapshot[file] = content;\n"+
  "            msg = { driveUpdates: [{ updateFile: file, content: content }], timestamp: drive.timestamp };\n"+
  "        }\n"+
  "        postMessageToHost(msg);\n"+
  "    }\n"+
  "    function storedSize_ASYNC_CHANNEL(file) {\n"+
  "        var file = read_ASYNC_CHANNEL(file);\n"+
  "        if (file)\n"+
  "            return file.length;\n"+
  "        else\n"+
  "            return 0;\n"+
  "    }\n"+
  "}\n"+
  "function RUN_SYNCFS_AIDED_CHANNEL(fs, msg) {\n"+
  "    var cookieBaseDate = +new Date();\n"+
  "    self_onmessage = SYNCFS_AIDED_CHANNEL_webworker_onmessage;\n"+
  "    var pushMessageDispatcher = createPushMessageDispatcher();\n"+
  "    var requestResponseDispatcher = createRequestResponseDispatcher();\n"+
  "    var drive = {\n"+
  "        timestamp: msg.driveTimestamp,\n"+
  "        files: files_SYNCFS_AIDED_CHANNEL,\n"+
  "        read: read_SYNCFS_AIDED_CHANNEL,\n"+
  "        write: write_SYNCFS_AIDED_CHANNEL,\n"+
  "        storedSize: storedSize_SYNCFS_AIDED_CHANNEL\n"+
  "    };\n"+
  "    connection_to_parent = {\n"+
  "        drive: drive,\n"+
  "        onPushMessage: pushMessageDispatcher.onPushMessage,\n"+
  "        invokeAsync: invokeAsync_SYNCFS_AIDED_CHANNEL,\n"+
  "        invokeSync: invokeSync_SYNCFS_AIDED_CHANNEL\n"+
  "    };\n"+
  "    function SYNCFS_AIDED_CHANNEL_webworker_onmessage(e) {\n"+
  "        if (e.data.asyncResponse) {\n"+
  "            handleAsyncResponse_SYNCFS_AIDED_CHANNEL(e.data.asyncResponse);\n"+
  "        }\n"+
  "        else if (e.data.remoteEval) {\n"+
  "            handleRemoteEval_EITHER_CHANNEL(e.data.remoteEval);\n"+
  "        }\n"+
  "        else if (e.data.pushMessage) {\n"+
  "            pushMessageDispatcher.handlePushMessage(e.data.pushMessage);\n"+
  "        }\n"+
  "        else if (e.data.driveUpdates) {\n"+
  "            handleDriveUpdates_SYNCFS_AIDED_CHANNEL(e.data.driveUpdates);\n"+
  "        }\n"+
  "        else {\n"+
  "            reportUnknownMessage_SYNCFS_AIDED_CHANNEL(e);\n"+
  "        }\n"+
  "    }\n"+
  "    function handleAsyncResponse_SYNCFS_AIDED_CHANNEL(asyncResponse) {\n"+
  "        if (!asyncResponse.key) {\n"+
  "            reportKeylessResponse(asyncResponse);\n"+
  "            return;\n"+
  "        }\n"+
  "        var callback = requestResponseDispatcher.popCallback(asyncResponse.key);\n"+
  "        callback(asyncResponse.error && errorSer.serialize(asyncResponse.error), asyncResponse.result);\n"+
  "    }\n"+
  "    function handleDriveUpdates_SYNCFS_AIDED_CHANNEL(driveUpdates) {\n"+
  "        // TODO: support drive watch\n"+
  "    }\n"+
  "    function reportUnknownMessage_SYNCFS_AIDED_CHANNEL(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown in SYNCFS_AIDED_CHANNEL: ', e.data, e);\n"+
  "    }\n"+
  "    function files_SYNCFS_AIDED_CHANNEL() {\n"+
  "        var cookieFilename = generateCookieFilename('drive_files_');\n"+
  "        var files_response = postMessageWaitForResponse({ driveRequest_files: cookieFilename }, cookieFilename, 'drive.files_');\n"+
  "        return files_response;\n"+
  "    }\n"+
  "    function read_SYNCFS_AIDED_CHANNEL(file) {\n"+
  "        var cookieFilename = generateCookieFilename('drive_read_');\n"+
  "        var read_response = postMessageWaitForResponse({ driveRequest_read: { key: cookieFilename, file: file } }, cookieFilename, 'drive.read_');\n"+
  "        return read_response;\n"+
  "    }\n"+
  "    function write_SYNCFS_AIDED_CHANNEL(file, content) {\n"+
  "        var msg;\n"+
  "        if (!content && (content === null || typeof content === 'undefined')) {\n"+
  "            msg = { driveUpdates: [{ deleteFile: file }], timestamp: drive.timestamp };\n"+
  "        }\n"+
  "        else {\n"+
  "            msg = { driveUpdates: [{ updateFile: file, content: content }], timestamp: drive.timestamp };\n"+
  "        }\n"+
  "        postMessageToHost(msg);\n"+
  "    }\n"+
  "    function storedSize_SYNCFS_AIDED_CHANNEL(file) {\n"+
  "        var cookieFilename = generateCookieFilename('drive_storedSize_');\n"+
  "        var storedSize_response = postMessageWaitForResponse({ driveRequest_storedSize: { key: cookieFilename, file: file } }, cookieFilename, 'drive.storedSize_');\n"+
  "        return storedSize_response;\n"+
  "    }\n"+
  "    function reportKeylessResponse(asyncResponse) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: asyncResponse with no key: ', asyncResponse);\n"+
  "    }\n"+
  "    function invokeAsync_SYNCFS_AIDED_CHANNEL(msg, callback) {\n"+
  "        if (callback) {\n"+
  "            var key = requestResponseDispatcher.pushCallback(callback);\n"+
  "            postMessageToHost({ invokeAsync: { key: key, msg: msg } });\n"+
  "        }\n"+
  "        else {\n"+
  "            postMessageToHost({ invokeAsync: { msg: msg } });\n"+
  "        }\n"+
  "    }\n"+
  "    function invokeSync_SYNCFS_AIDED_CHANNEL(msg) {\n"+
  "        var cookieFilename = generateCookieFilename('invokeSync_');\n"+
  "        var invokeSync_response = postMessageWaitForResponse({ invokeSync: { key: cookieFilename, msg: msg } }, cookieFilename, 'invokeSync_');\n"+
  "        if (invokeSync_response.error) {\n"+
  "            var toThrow = errorSer.deserialize(invokeSync_response.error);\n"+
  "            throw toThrow;\n"+
  "        }\n"+
  "        return invokeSync_response.response;\n"+
  "    }\n"+
  "    function postMessageWaitForResponse(msg, cookieFile, idle_sping_reason) {\n"+
  "        postMessageToHost(msg);\n"+
  "        while (true) {\n"+
  "            var content = getFileSync(fs, cookieFile);\n"+
  "            if (content) {\n"+
  "                var result = _JSON_parse(content);\n"+
  "                return result;\n"+
  "            }\n"+
  "            SYNCFS_idle_spin(idle_sping_reason);\n"+
  "        }\n"+
  "    }\n"+
  "    function generateCookieFilename(hint) {\n"+
  "        var fn = hint + 'T' + ((+new Date()) - cookieBaseDate) + 'R' + Math.random().toString().replace(/\\./g, '');\n"+
  "        return fn;\n"+
  "    }\n"+
  "}\n"+
  "function SYNCFS_idle_spin(reason) {\n"+
  "}\n"+
  "var _addEventListener;\n"+
  "var _setInterval;\n"+
  "var _clearInterval;\n"+
  "var _postMessage;\n"+
  "var _Function;\n"+
  "var _FileReaderSync;\n"+
  "var _eval;\n"+
  "var _console_log;\n"+
  "var _JSON_parse;\n"+
  "function captureGlobalScopeVariables_atStart() {\n"+
  "    _addEventListener = addEventListener;\n"+
  "    _setInterval = setInterval;\n"+
  "    _clearInterval = clearInterval;\n"+
  "    _postMessage = postMessage;\n"+
  "    _Function = Function;\n"+
  "    _FileReaderSync = FileReaderSync;\n"+
  "    _eval = eval;\n"+
  "    if (typeof console !== 'undefined' && console && typeof console.log === 'function') {\n"+
  "        if (console.log.bind)\n"+
  "            _console_log = console.log.bind(console);\n"+
  "    }\n"+
  "    if (typeof JSON !== 'undefined' && JSON && typeof JSON.parse === 'function') {\n"+
  "        if (JSON.parse.bind) {\n"+
  "            _JSON_parse = JSON.parse.bind(JSON);\n"+
  "        }\n"+
  "        else {\n"+
  "            var _JSON = JSON;\n"+
  "            var _parse = JSON.parse;\n"+
  "            _JSON_parse = function (txt) { return _parse.apply(_JSON, [txt]); };\n"+
  "        }\n"+
  "    }\n"+
  "}\n"+
  "function postMessageToHost(msg) {\n"+
  "    _postMessage(msg);\n"+
  "}\n"+
  "var errorSer = createErrorSerializer();\n"+
  "captureGlobalScopeVariables_atStart();\n"+
  "addMessageEventListener();\n"+
  "expectMessage_init_worker_connect(function () {\n"+
  "    var fs = detectSyncFSAvailable_or_reason();\n"+
  "    if (typeof fs === 'string')\n"+
  "        return requestAsyncMode(fs);\n"+
  "    try {\n"+
  "        trySetupSyncMode(fs);\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        requestAsyncMode(error.message);\n"+
  "    }\n"+
  "});\n"+
  "function detectSyncFSAvailable_or_reason() {\n"+
  "    var reqFS;\n"+
  "    var reqFS_variant_name;\n"+
  "    try {\n"+
  "        reqFS_variant_name = 'requestFileSystemSync';\n"+
  "        if (typeof requestFileSystemSync === 'function')\n"+
  "            reqFS = requestFileSystemSync;\n"+
  "        else {\n"+
  "            reqFS_variant_name = 'webkitRequestFileSystemSync';\n"+
  "            if (typeof webkitRequestFileSystemSync === 'function')\n"+
  "                reqFS = webkitRequestFileSystemSync;\n"+
  "            else {\n"+
  "                reqFS_variant_name = 'mozRequestFileSystemSync';\n"+
  "                if (typeof mozRequestFileSystemSync === 'function')\n"+
  "                    reqFS = mozRequestFileSystemSync;\n"+
  "                else {\n"+
  "                    reqFS_variant_name = 'oRequestFileSystemSync';\n"+
  "                    if (typeof oRequestFileSystemSync === 'function')\n"+
  "                        reqFS = oRequestFileSystemSync;\n"+
  "                    else {\n"+
  "                        reqFS_variant_name = 'msRequestFileSystemSync';\n"+
  "                        if (typeof msRequestFileSystemSync === 'function')\n"+
  "                            reqFS = msRequestFileSystemSync;\n"+
  "                        else\n"+
  "                            return 'requestFileSystemSync and its prefixed variants are unavailable';\n"+
  "                    }\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        return error.message + ' - probing typeof ' + reqFS_variant_name;\n"+
  "    }\n"+
  "    try {\n"+
  "        var fs = reqFS('TEMPORARY', 1024);\n"+
  "        return fs;\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        return error.message + ' - invoking ' + reqFS_variant_name;\n"+
  "    }\n"+
  "}\n"+
  "function expectMessage_init_worker_connect(callback) {\n"+
  "    self_onmessage = function (e) {\n"+
  "        if (e.data.init_worker_connect) {\n"+
  "            self_onmessage = null;\n"+
  "            callback();\n"+
  "        }\n"+
  "        else {\n"+
  "            reportUnknownMessage_expecting_init_worker_connect(e);\n"+
  "        }\n"+
  "    };\n"+
  "    function reportUnknownMessage_expecting_init_worker_connect(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown expecting init_worker_connect: ', e.data, e);\n"+
  "    }\n"+
  "}\n"+
  "function handleRemoteEval_EITHER_CHANNEL(remoteEval) {\n"+
  "    try {\n"+
  "        var script = remoteEval.script;\n"+
  "        var arg = remoteEval.arg;\n"+
  "        var result = (new _Function(script))(arg);\n"+
  "        if (!remoteEval.key) {\n"+
  "            if (_console_log)\n"+
  "                _console_log('remoteEval: succeeded while no key was passed: ', result, remoteEval);\n"+
  "            return;\n"+
  "        }\n"+
  "        var remoteResponse = {\n"+
  "            key: remoteEval.key,\n"+
  "            result: result\n"+
  "        };\n"+
  "        postMessageToHost({ remoteResponse: remoteResponse });\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        if (!remoteEval.key) {\n"+
  "            if (_console_log)\n"+
  "                _console_log('remoteEval: error while no key was passed: ', error, remoteEval);\n"+
  "            return;\n"+
  "        }\n"+
  "        var remoteErrorResponse = {\n"+
  "            key: remoteEval.key,\n"+
  "            error: errorSer.serialize(error)\n"+
  "        };\n"+
  "        postMessageToHost({ remoteErrorResponse: remoteErrorResponse });\n"+
  "    }\n"+
  "}\n"+
  "/// <reference path=\"../../persistence/src/API.d.ts\"/>\n"+
  "function createErrorSerializer() {\n"+
  "    var dummyError = new Error();\n"+
  "    var knownProps = [\n"+
  "        'message', 'name',\n"+
  "        'stack',\n"+
  "        'fileName', 'lineNumber', 'columnNumber',\n"+
  "        'description', 'number', 'stackTraceLimit'\n"+
  "    ];\n"+
  "    var deserializedCtorCache = {};\n"+
  "    return {\n"+
  "        serialize: serialize_error,\n"+
  "        deserialize: deserialize_error\n"+
  "    };\n"+
  "    function serialize_error(error) {\n"+
  "        if (!error)\n"+
  "            return error;\n"+
  "        var result = {};\n"+
  "        if (typeof error.prototype.constructor === 'function') {\n"+
  "            if (error.constructor.name) {\n"+
  "                result['@constructor'] = error.constructor.name;\n"+
  "            }\n"+
  "            else {\n"+
  "                var nameMatch = /function ([^\\(]*)/.exec(error.constructor + '');\n"+
  "                if (nameMatch && nameMatch[1] && nameMatch[1].length < 200) {\n"+
  "                    var ctorName = nameMatch[1].replace(/[\\s]+/g, ''); // additionally eliminate possible spaces\n"+
  "                    result['@constructor'] = ctorName;\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "        for (var i = 0; i < knownProps.length; i++) {\n"+
  "            var p = knownProps[i];\n"+
  "            if (error[p] !== null && typeof error[p] !== 'undefined' && typeof error[p] !== 'function')\n"+
  "                result[p] = error[p];\n"+
  "        }\n"+
  "        for (var p in error) {\n"+
  "            if (p in result)\n"+
  "                continue;\n"+
  "            // this skips those weird upper-case constants from Error\n"+
  "            if (p in dummyError && error[p] === dummyError[p] && p.match(/^[A-Z][A-Z0-9_]+$/))\n"+
  "                continue;\n"+
  "            if (typeof error[p] === 'function')\n"+
  "                continue;\n"+
  "            result[p] = error[p];\n"+
  "        }\n"+
  "        if (error.prototype) {\n"+
  "            for (var p in error.prototype) {\n"+
  "                if (p in result)\n"+
  "                    continue;\n"+
  "                // this skips those weird upper-case constants from Error\n"+
  "                if (p in dummyError && error[p] === dummyError[p] && p.match(/^[A-Z][A-Z0-9_]+$/))\n"+
  "                    continue;\n"+
  "                if (typeof error[p] === 'function')\n"+
  "                    continue;\n"+
  "                result[p] = error[p];\n"+
  "            }\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function deserialize_error(err) {\n"+
  "        if (!err)\n"+
  "            return err;\n"+
  "        var result;\n"+
  "        var ctorName = err['@constructor'];\n"+
  "        if (deserializedCtorCache.hasOwnProperty(ctorName)) {\n"+
  "            result = new deserializedCtorCache[ctorName];\n"+
  "        }\n"+
  "        else {\n"+
  "            result = createErrorInstance_uncachedCtorName(ctorName);\n"+
  "        }\n"+
  "        for (var k in err) {\n"+
  "            if (!result[k])\n"+
  "                result[k] = err[k];\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function createErrorInstance_uncachedCtorName(ctorName) {\n"+
  "        var result;\n"+
  "        ctorName = validateCtorName(ctorName);\n"+
  "        if (ctorName) {\n"+
  "            try {\n"+
  "                var getFromGlobal = new Function('return typeof ' + ctorName + '===\"undefined\"?null:' + ctorName);\n"+
  "                var ctor = getFromGlobal();\n"+
  "                if (ctor) {\n"+
  "                    result = new ctor();\n"+
  "                    deserializedCtorCache[ctorName] = ctor;\n"+
  "                }\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "            }\n"+
  "            if (!result) {\n"+
  "                var getCtor = new Function('return ' + ctorName + '; function ' + ctorName + '(){}');\n"+
  "                ctor = getCtor();\n"+
  "                deserializedCtorCache[ctorName] = ctor;\n"+
  "                result = new ctor();\n"+
  "            }\n"+
  "        }\n"+
  "        else {\n"+
  "            result = {};\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function validateCtorName(ctorName) {\n"+
  "        if (ctorName) {\n"+
  "            if (!/^A-Za-z0-9_$/.test(ctorName)) {\n"+
  "                for (var i = 0; i < ctorName.length; i++) {\n"+
  "                    var ctorChar = ctorName.charAt(i);\n"+
  "                    if (/^A-Za-z0-9_$/.test(ctorChar))\n"+
  "                        continue;\n"+
  "                    else if (ctorChar.toLowerCase() !== ctorChar.toUpperCase())\n"+
  "                        continue;\n"+
  "                    // no, this is definitely a wrong character for identifier\n"+
  "                    ctorName = null;\n"+
  "                    break;\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "        return ctorName;\n"+
  "    }\n"+
  "}\n"+
  "function createRequestResponseDispatcher() {\n"+
  "    var diagTimeStart = +new Date();\n"+
  "    var requests = { count: 0 };\n"+
  "    return {\n"+
  "        pushCallback: pushCallback_reqResDispatcher,\n"+
  "        popCallback: popCallback_reqResDispatcher\n"+
  "    };\n"+
  "    function pushCallback_reqResDispatcher(callback) {\n"+
  "        var key = generateKey();\n"+
  "        requests[key] = callback;\n"+
  "        return key;\n"+
  "    }\n"+
  "    function popCallback_reqResDispatcher(key) {\n"+
  "        if (key) {\n"+
  "            var callback = requests[key];\n"+
  "            if (callback)\n"+
  "                delete requests[key];\n"+
  "        }\n"+
  "        return callback;\n"+
  "    }\n"+
  "    function generateKey() {\n"+
  "        var key = (requests.count++).toString();\n"+
  "        // generate a bit of timestamp for the benefit of easier debugging\n"+
  "        if (Date.now)\n"+
  "            key += '-' + (Date.now() - diagTimeStart) + 'ms';\n"+
  "        else\n"+
  "            key += '-' + (+new Date() - diagTimeStart) + 'ms';\n"+
  "        return key;\n"+
  "    }\n"+
  "}\n"+
  "function createPushMessageDispatcher() {\n"+
  "    var registeredPushMessageCallbacks = [];\n"+
  "    var registeredPushMessageCallbacks_length = 0;\n"+
  "    return {\n"+
  "        handlePushMessage: handlePushMessage_pushMessageDispatcher,\n"+
  "        onPushMessage: onPushMessage_pushMessageDispatcher\n"+
  "    };\n"+
  "    function handlePushMessage_pushMessageDispatcher(pushMessage) {\n"+
  "        for (var i = 0; i < registeredPushMessageCallbacks_length; i++) {\n"+
  "            var cb = registeredPushMessageCallbacks[i];\n"+
  "            if (cb)\n"+
  "                cb(pushMessage);\n"+
  "        }\n"+
  "    }\n"+
  "    function onPushMessage_pushMessageDispatcher(callback) {\n"+
  "        var index = registeredPushMessageCallbacks_length;\n"+
  "        registeredPushMessageCallbacks.push(callback);\n"+
  "        registeredPushMessageCallbacks_length++;\n"+
  "        return unregister_pushMessageCallback;\n"+
  "        function unregister_pushMessageCallback() {\n"+
  "            if (index < 0)\n"+
  "                return;\n"+
  "            delete registeredPushMessageCallbacks[index];\n"+
  "            index = -1;\n"+
  "            // adjust the tail (removal of callbacks may run out of order)\n"+
  "            var newLength = registeredPushMessageCallbacks_length;\n"+
  "            while (!registeredPushMessageCallbacks[newLength] && newLength >= 0) {\n"+
  "                newLength--;\n"+
  "            }\n"+
  "            if (newLength !== registeredPushMessageCallbacks_length)\n"+
  "                registeredPushMessageCallbacks_length = newLength;\n"+
  "        }\n"+
  "    }\n"+
  "}\n"+
  "function driveApplyUpdates(tmDrive, msg) {\n"+
  "    tmDrive.timestamp = Math.max(tmDrive.timestamp, msg.timestamp);\n"+
  "    for (var i = 0; i < msg.driveUpdates.length; i++) {\n"+
  "        var up = msg.driveUpdates[i];\n"+
  "        if (up.deleteFile) {\n"+
  "            tmDrive.write(up.deleteFile, null);\n"+
  "        }\n"+
  "        else if (up.updateFile) {\n"+
  "            tmDrive.write(up.updateFile, up.content);\n"+
  "        }\n"+
  "    }\n"+
  "}\n"+
  "/// <reference path=\"ref.ts\"/>\n"+
  "/// <reference path=\"createErrorSerializer.ts\"/>\n"+
  "/// <reference path=\"createRequestResponseDispatcher.ts\"/>\n"+
  "/// <reference path=\"createPushMessageDispatcher.ts\"/>\n"+
  "/// <reference path=\"driveApplyUpdates.ts\"/>\n"+
  "/// <reference path=\"../shared/all.ts\"/>\n"+
  "function requestAsyncMode(fs_reason) {\n"+
  "    self_onmessage = expect_driveSnapshot_thenStart_ASYNC_CHANNEL;\n"+
  "    postMessageToHost({ requestInitAsync: fs_reason });\n"+
  "    function expect_driveSnapshot_thenStart_ASYNC_CHANNEL(e) {\n"+
  "        if (e.data.driveSnapshot) {\n"+
  "            RUN_ASYNC_CHANNEL(e.data.driveSnapshot);\n"+
  "        }\n"+
  "        else {\n"+
  "            report_unexpectedMessage_whenExpecting_driveSnapshot(e);\n"+
  "        }\n"+
  "    }\n"+
  "    function report_unexpectedMessage_whenExpecting_driveSnapshot(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown expecting driveSnapshot for ASYNC_CHANNEL: ', e.data, e);\n"+
  "    }\n"+
  "}\n"+
  "var self_onmessage;\n"+
  "function addMessageEventListener() {\n"+
  "    _addEventListener('message', function (e) {\n"+
  "        if (!self_onmessage) {\n"+
  "            if (_console_log)\n"+
  "                _console_log('onmessage: self_onmessage is null: ', e.data, e); // but let it throw too\n"+
  "        }\n"+
  "        self_onmessage(e);\n"+
  "    }, true);\n"+
  "}\n"+
  "function trySetupSyncMode(fs) {\n"+
  "    var cookieFilename = generateCookieFilename();\n"+
  "    pollForFile_or_expectMessage_requestInitSync_reject({\n"+
  "        file: cookieFilename,\n"+
  "        when_OK: function (msg) {\n"+
  "            postMessageToHost({ requestInitSync_completed: 'done' });\n"+
  "            return RUN_SYNCFS_AIDED_CHANNEL(fs, msg);\n"+
  "        },\n"+
  "        when_requestInitSync_reject: function (driveSnapshot) {\n"+
  "            return RUN_ASYNC_CHANNEL(driveSnapshot);\n"+
  "        },\n"+
  "        when_timeout: function () {\n"+
  "            return requestAsyncMode('wait for cookie file timed out: ' + cookieFilename);\n"+
  "        }\n"+
  "    });\n"+
  "    function generateCookieFilename() {\n"+
  "        var fn = 'T' + (+new Date()) + 'R' + Math.random().toString().replace(/\\./g, '');\n"+
  "        return fn;\n"+
  "    }\n"+
  "    function pollForFile_or_expectMessage_requestInitSync_reject(opts) {\n"+
  "        var cookieFilename = opts.file;\n"+
  "        var timeoutAfter = +new Date() + 1000 * 88888; // TODO: DEBUGDEBUG\n"+
  "        self_onmessage = requestInitSync_onmessage;\n"+
  "        var pollFS = _setInterval(setInterval_pollFS, 5);\n"+
  "        postMessageToHost({ requestInitSync: opts.file });\n"+
  "        function setInterval_pollFS() {\n"+
  "            var response = getFileSync(fs, cookieFilename);\n"+
  "            if (response) {\n"+
  "                var response_msg = _JSON_parse(response);\n"+
  "                _clearInterval(pollFS);\n"+
  "                opts.when_OK(response_msg);\n"+
  "                return;\n"+
  "            }\n"+
  "            var now = Date.now ? Date.now() : +new Date();\n"+
  "            if (now > timeoutAfter) {\n"+
  "                _clearInterval(pollFS);\n"+
  "                opts.when_timeout();\n"+
  "                return;\n"+
  "            }\n"+
  "        }\n"+
  "        function requestInitSync_onmessage(e) {\n"+
  "            if (e.data.requestInitSync_reject) {\n"+
  "                _clearInterval(pollFS);\n"+
  "                self_onmessage = null;\n"+
  "                var driveSnapshot = e.data.requestInitSync_reject;\n"+
  "                opts.when_requestInitSync_reject(driveSnapshot);\n"+
  "            }\n"+
  "            else {\n"+
  "                reportUnexpectedMessage_whenPolling_syncFS(e);\n"+
  "            }\n"+
  "        }\n"+
  "    }\n"+
  "    function reportUnexpectedMessage_whenPolling_syncFS(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown when polling for SYNCFS_AIDED_CHANNEL: ', e.data, e);\n"+
  "    }\n"+
  "}\n"+
  "function getFileSync(fs, fname) {\n"+
  "    try {\n"+
  "        /*\n"+
  "        var found = true;\n"+
  "        var entries = fs.root.createReader().readEntries();\n"+
  "        for (var i = 0; i < entries.length; i++) {\n"+
  "          if (entries[i].name===fname) {\n"+
  "            found = true;\n"+
  "            break;\n"+
  "          }\n"+
  "        }\n"+
  "        if (!found) return;\n"+
  "        */\n"+
  "        var fentry = fs.root.getFile('/isolation-syncfs-aided--' + fname, { create: false });\n"+
  "        var file = fentry.file();\n"+
  "        var reader = new _FileReaderSync();\n"+
  "        var text = reader.readAsText(file);\n"+
  "        if (!text) {\n"+
  "            return null;\n"+
  "        }\n"+
  "        try {\n"+
  "            // MDN and W3C are ambiguous?\n"+
  "            if (typeof fentry.remove === 'function')\n"+
  "                fentry.remove();\n"+
  "            else if (typeof file.remove === 'function')\n"+
  "                file.remove();\n"+
  "        }\n"+
  "        catch (error) {\n"+
  "        }\n"+
  "        return text;\n"+
  "    }\n"+
  "    catch (err) {\n"+
  "    }\n"+
  "}\n";
    }
})();
/// <reference path="../../persistence/src/API.d.ts"/>
function createErrorSerializer() {
    var dummyError = new Error();
    var knownProps = [
        'message', 'name',
        'stack',
        'fileName', 'lineNumber', 'columnNumber',
        'description', 'number', 'stackTraceLimit'
    ];
    var deserializedCtorCache = {};
    return {
        serialize: serialize_error,
        deserialize: deserialize_error
    };
    function serialize_error(error) {
        if (!error)
            return error;
        var result = {};
        if (typeof error.prototype.constructor === 'function') {
            if (error.constructor.name) {
                result['@constructor'] = error.constructor.name;
            }
            else {
                var nameMatch = /function ([^\(]*)/.exec(error.constructor + '');
                if (nameMatch && nameMatch[1] && nameMatch[1].length < 200) {
                    var ctorName = nameMatch[1].replace(/[\s]+/g, ''); // additionally eliminate possible spaces
                    result['@constructor'] = ctorName;
                }
            }
        }
        for (var i = 0; i < knownProps.length; i++) {
            var p = knownProps[i];
            if (error[p] !== null && typeof error[p] !== 'undefined' && typeof error[p] !== 'function')
                result[p] = error[p];
        }
        for (var p in error) {
            if (p in result)
                continue;
            // this skips those weird upper-case constants from Error
            if (p in dummyError && error[p] === dummyError[p] && p.match(/^[A-Z][A-Z0-9_]+$/))
                continue;
            if (typeof error[p] === 'function')
                continue;
            result[p] = error[p];
        }
        if (error.prototype) {
            for (var p in error.prototype) {
                if (p in result)
                    continue;
                // this skips those weird upper-case constants from Error
                if (p in dummyError && error[p] === dummyError[p] && p.match(/^[A-Z][A-Z0-9_]+$/))
                    continue;
                if (typeof error[p] === 'function')
                    continue;
                result[p] = error[p];
            }
        }
        return result;
    }
    function deserialize_error(err) {
        if (!err)
            return err;
        var result;
        var ctorName = err['@constructor'];
        if (deserializedCtorCache.hasOwnProperty(ctorName)) {
            result = new deserializedCtorCache[ctorName];
        }
        else {
            result = createErrorInstance_uncachedCtorName(ctorName);
        }
        for (var k in err) {
            if (!result[k])
                result[k] = err[k];
        }
        return result;
    }
    function createErrorInstance_uncachedCtorName(ctorName) {
        var result;
        ctorName = validateCtorName(ctorName);
        if (ctorName) {
            try {
                var getFromGlobal = new Function('return typeof ' + ctorName + '==="undefined"?null:' + ctorName);
                var ctor = getFromGlobal();
                if (ctor) {
                    result = new ctor();
                    deserializedCtorCache[ctorName] = ctor;
                }
            }
            catch (error) {
            }
            if (!result) {
                var getCtor = new Function('return ' + ctorName + '; function ' + ctorName + '(){}');
                ctor = getCtor();
                deserializedCtorCache[ctorName] = ctor;
                result = new ctor();
            }
        }
        else {
            result = {};
        }
        return result;
    }
    function validateCtorName(ctorName) {
        if (ctorName) {
            if (!/^A-Za-z0-9_$/.test(ctorName)) {
                for (var i = 0; i < ctorName.length; i++) {
                    var ctorChar = ctorName.charAt(i);
                    if (/^A-Za-z0-9_$/.test(ctorChar))
                        continue;
                    else if (ctorChar.toLowerCase() !== ctorChar.toUpperCase())
                        continue;
                    // no, this is definitely a wrong character for identifier
                    ctorName = null;
                    break;
                }
            }
        }
        return ctorName;
    }
}
function createRequestResponseDispatcher() {
    var diagTimeStart = +new Date();
    var requests = { count: 0 };
    return {
        pushCallback: pushCallback_reqResDispatcher,
        popCallback: popCallback_reqResDispatcher
    };
    function pushCallback_reqResDispatcher(callback) {
        var key = generateKey();
        requests[key] = callback;
        return key;
    }
    function popCallback_reqResDispatcher(key) {
        if (key) {
            var callback = requests[key];
            if (callback)
                delete requests[key];
        }
        return callback;
    }
    function generateKey() {
        var key = (requests.count++).toString();
        // generate a bit of timestamp for the benefit of easier debugging
        if (Date.now)
            key += '-' + (Date.now() - diagTimeStart) + 'ms';
        else
            key += '-' + (+new Date() - diagTimeStart) + 'ms';
        return key;
    }
}
function createPushMessageDispatcher() {
    var registeredPushMessageCallbacks = [];
    var registeredPushMessageCallbacks_length = 0;
    return {
        handlePushMessage: handlePushMessage_pushMessageDispatcher,
        onPushMessage: onPushMessage_pushMessageDispatcher
    };
    function handlePushMessage_pushMessageDispatcher(pushMessage) {
        for (var i = 0; i < registeredPushMessageCallbacks_length; i++) {
            var cb = registeredPushMessageCallbacks[i];
            if (cb)
                cb(pushMessage);
        }
    }
    function onPushMessage_pushMessageDispatcher(callback) {
        var index = registeredPushMessageCallbacks_length;
        registeredPushMessageCallbacks.push(callback);
        registeredPushMessageCallbacks_length++;
        return unregister_pushMessageCallback;
        function unregister_pushMessageCallback() {
            if (index < 0)
                return;
            delete registeredPushMessageCallbacks[index];
            index = -1;
            // adjust the tail (removal of callbacks may run out of order)
            var newLength = registeredPushMessageCallbacks_length;
            while (!registeredPushMessageCallbacks[newLength] && newLength >= 0) {
                newLength--;
            }
            if (newLength !== registeredPushMessageCallbacks_length)
                registeredPushMessageCallbacks_length = newLength;
        }
    }
}
function driveApplyUpdates(tmDrive, msg) {
    tmDrive.timestamp = Math.max(tmDrive.timestamp, msg.timestamp);
    for (var i = 0; i < msg.driveUpdates.length; i++) {
        var up = msg.driveUpdates[i];
        if (up.deleteFile) {
            tmDrive.write(up.deleteFile, null);
        }
        else if (up.updateFile) {
            tmDrive.write(up.updateFile, up.content);
        }
    }
}
/// <reference path="ref.ts"/>
/// <reference path="createErrorSerializer.ts"/>
/// <reference path="createRequestResponseDispatcher.ts"/>
/// <reference path="createPushMessageDispatcher.ts"/>
/// <reference path="driveApplyUpdates.ts"/>
/// <reference path="../shared/all.ts"/>


	isolation.createContextHost = createContextHost;

}



  if (typeof module!=='undefined' && module && module.exports) {

    isolation();
module.exports = isolation;

  }
  else {
    document.body.style.color = 'white';

    isolation();
var tests;
(function (tests) {
    tests.buildMetadata = {
        'not null': function () { return assert(isolation.build); },
        'timestamp>=1462227529476': function () { return assert(isolation.build.timestamp >= 1462227529476); },
        '60000>taken>10': function () { return assert(isolation.build.taken > 10 && isolation.build.taken < 60000); },
        'platform is string': function () { return assert.equal('string', typeof isolation.build.platform); }
    };
})(tests || (tests = {}));
;
var tests;
(function (tests) {
    function driveAs(snapshot) {
        if (!snapshot.timestamp)
            snapshot.timestamp = 1465249756308;
        snapshot.files = function () {
            var result = [];
            for (var k in snapshot)
                if (k && k.charCodeAt(0) === 47)
                    result.push(k);
            return result;
        };
        snapshot.read = function (f) {
            var dt = snapshot[f];
            if (dt || typeof dt === 'string')
                return dt;
            else
                return null;
        };
        snapshot.write = function (f, txt) {
            if (txt || typeof txt === 'string')
                snapshot[f] = txt;
            else
                delete snapshot[f];
        };
        return snapshot;
    }
    tests['createContextHost'] = createTestsWith_createContextHost(isolation);
    tests['createContextHost_iframe'] = createTestsWith_createContextHost({ createContextHost: isolation.createContextHost.iframe });
    tests['createContextHost_worker'] = createTestsWith_createContextHost({ createContextHost: isolation.createContextHost.worker });
    function createTestsWith_createContextHost(isolation) {
        return {
            createContextHost_succeeds: function (callback) {
                isolation.createContextHost(driveAs({}), function (host) {
                    callback();
                    try {
                        if (host)
                            host.terminate();
                    }
                    catch (error) { }
                });
            },
            createContextHost_terminate: function (callback) {
                isolation.createContextHost(driveAs({}), function (host) {
                    try {
                        host.terminate();
                    }
                    catch (error) {
                        callback(error);
                        return;
                    }
                    callback();
                });
            },
            remoteEval_withoutReturn: function (callback) {
                isolation.createContextHost(driveAs({}), function (host) {
                    host.remoteEval('2+2', 0, function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            var _undef;
                            assert.equal(_undef, result, 'no return no result');
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_returns: function (callback) {
                isolation.createContextHost(driveAs({}), function (host) {
                    host.remoteEval('return 2+2', 0, function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(4, result, '2+2 result');
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_terminate: function (callback) {
                isolation.createContextHost(driveAs({}), function (host) {
                    host.remoteEval('return 2+2', 0, function (error, result) {
                        try {
                            host.terminate();
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                    });
                });
            },
            remoteEval_simpleIN: function (callback) {
                var host = isolation.createContextHost(driveAs({}), function (host) {
                    host.remoteEval('return arguments[0]', 56, function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(56, result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_complexIN: function (callback) {
                isolation.createContextHost(driveAs({}), function (host) {
                    host.remoteEval('return arguments[0].value', { value: 97 }, function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(97, result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_complexOUT: function (callback) {
                isolation.createContextHost(driveAs({}), function (host) {
                    host.remoteEval('return { value: 23 }', null, function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(23, result.value);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_complexIN_OUT: function (callback) {
                isolation.createContextHost(driveAs({}), function (host) {
                    host.remoteEval('return { value: arguments[0].x+arguments[0].y }', { x: 2, y: 2 }, function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(4, result.value);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            connection_to_parent: {
                invokeAsync_hits_onmessage: function (callback) {
                    isolation.createContextHost(driveAs({}), function (host) {
                        var key = 'TEST-connection_to_parent_invokeAsync-' + (+new Date()) + '-' + Math.random();
                        host.onmessage = function () {
                            callback();
                            close_clean();
                        };
                        host.remoteEval('connection_to_parent.invokeAsync({TEST_key: "' + key + '"})', null, function () {
                            // nothing
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                invokeAsync_passes_right_message: function (callback) {
                    isolation.createContextHost(driveAs({}), function (host) {
                        var key = 'TEST-connection_to_parent_invokeAsync-' + (+new Date()) + '-' + Math.random();
                        host.onmessage = function (msg) {
                            try {
                                assert.equal(key, msg.TEST_key);
                            }
                            catch (error) {
                                callback(error);
                                close_clean();
                                return;
                            }
                            callback();
                            close_clean();
                        };
                        host.remoteEval('connection_to_parent.invokeAsync({TEST_key: "' + key + '"})', null, function () {
                            // nothing
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                invokeAsync_passes_return_bounce: function (callback) {
                    isolation.createContextHost(driveAs({}), function (host) {
                        var key = 'TEST-connection_to_parent_invokeAsync-' + (+new Date()) + '-' + Math.random();
                        host.onmessage = function (msg, sync, response_callback) {
                            if (msg.TEST_response_after_invoke) {
                                try {
                                    assert.equal(key, msg.TEST_response_after_invoke);
                                }
                                catch (error) {
                                    callback(error);
                                    close_clean();
                                    return;
                                }
                                callback();
                                close_clean();
                            }
                            else if (msg.TEST_key_original_message) {
                                try {
                                    assert.equal(key, msg.TEST_key_original_message);
                                    response_callback(null, { TEST_key_response: key });
                                }
                                catch (error) {
                                    callback(error);
                                    close_clean();
                                    return;
                                }
                            }
                        };
                        host.remoteEval('connection_to_parent.invokeAsync(\n' +
                            '  {TEST_key_original_message: "' + key + '"},\n' +
                            '  function (error, result) {\n' +
                            ' 	 connection_to_parent.invokeAsync({TEST_response_after_invoke: "' + key + '"});\n' +
                            '  })', null, function () {
                            // this execution returns nothing, all conversation is through invokeAsync
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                pushMessage_reply_with_invokeAsync: function (callback) {
                    isolation.createContextHost(driveAs({}), function (host) {
                        var key = 'TEST-connection_to_parent_invokeAsync-' + (+new Date()) + '-' + Math.random();
                        host.onmessage = function (msg) {
                            try {
                                assert.equal(key + '123', msg.TEST_key);
                            }
                            catch (error) {
                                callback(error);
                                close_clean();
                                return;
                            }
                            callback();
                            close_clean();
                        };
                        host.remoteEval('var unsub = connection_to_parent.onPushMessage(function(msg) { connection_to_parent.invokeAsync({TEST_key: msg.key+"123"}); unsub(); }); ', null, function () {
                            // nothing
                        });
                        host.pushMessage({ key: key });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_empty_files_none: function (callback) {
                    isolation.createContextHost(driveAs({}), function (host) {
                        host.remoteEval('return connection_to_parent.drive.files()', null, function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal(0, result.length);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_empty_read_null: function (callback) {
                    isolation.createContextHost(driveAs({}), function (host) {
                        host.remoteEval('return connection_to_parent.drive.read("/temp")', null, function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal(null, result);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_withFile_files: function (callback) {
                    isolation.createContextHost(driveAs({ '/mytext': 'mytext12514' }), function (host) {
                        host.remoteEval('return connection_to_parent.drive.files()', null, function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal(1, result.length);
                                assert.equal('/mytext', result[0]);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_withFile_read_text06053: function (callback) {
                    isolation.createContextHost(driveAs({ '/textfile': 'text06053' }), function (host) {
                        host.remoteEval('return connection_to_parent.drive.read("/textfile")', null, function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal('text06053', result);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_write_read_immediately: function (callback) {
                    isolation.createContextHost(driveAs({}), function (host) {
                        host.remoteEval('connection_to_parent.drive.write("/mytext", "ui4345"); return connection_to_parent.drive.read("/mytext")', null, function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal('ui4345', result);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_write_spinCycle_affectsDrive: function (callback) {
                    var drive = driveAs({});
                    isolation.createContextHost(drive, function (host) {
                        host.remoteEval('connection_to_parent.drive.write("/mytext", "rlrjo45")', null, function (error, result) {
                            if (error) {
                                close_clean();
                                return callback(error);
                            }
                            host.remoteEval('null', null, function (error, result) {
                                close_clean();
                                if (error)
                                    return callback(error);
                                try {
                                    assert.equal('rlrjo45', drive['/mytext']);
                                }
                                catch (error) {
                                    return callback(error);
                                }
                                callback();
                            });
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                }
            }
        };
    }
})(tests || (tests = {}));
/// <reference path="../../persistence/src/API.d.ts"/>
/// <reference path="../host/API.d.ts"/>


    // running tests from HTML page
    var ui = document.createElement('div');
    ui.style.color = 'black';
    ui.innerHTML = '<h2> Tests for submodule... </h2>';
    window.onload = function() {
      runTests(generateTests());
    };

  }

  // # sourceURL=/submodule_script.js </script>
  /* <style>
  .prepared {
    opacity: 0.5;
  }
  .running {
    opacity: 1;
    color: cornflowerblue;
    font-weight: bold;
  }
  .success {
   opacity: 1;
  }
  .fail {
    opacity: 1;
    color: tomato;
  }
  .fail pre {
    font-size: 70%;
    margin: 0px; margin-left: 1em;
    padding: 0px;
  }
  </style><script id=tests_scripts> /* */

  

  function runTests(tests) {

    var testFilter = location.hash;
    if (testFilter && testFilter.charAt(0)==='#') testFilter = testFilter.slice(1);

    var summary = document.createElement('h2');
    summary.style.color = 'black';

    if ('textContent' in summary) summary.textContent = 'Tests (total '+tests.length+'):';
    else summary.innerText = tests.length+'Tests (total '+tests.length+'):';
    var successCount = 0;
    var failCount = 0;
    document.body.appendChild(summary);

    var testList = document.createElement('div');
    testList.style.color = 'black';

    var disabledTestList = document.createElement('div');
    disabledTestList.style.color = 'gold';

    var runIndex = 0;
    var testsToRun = [];
    for (var i = 0; i < tests.length; i++) {
      addTestRow(i);
    }

    document.body.appendChild(testList);
    document.body.appendChild(disabledTestList);

    setTimeout(function() {
      continueRunTests();
    }, 10);

    function continueRunTests() {
      if (runIndex === testsToRun.length) return;
      var t = testsToRun[runIndex];
      runIndex++;

      if (t.disabled) {
        setTimeout(continueRunTests, 1);
        return;
      }

      var start = +new Date();
      t.testEntry.className = 'running';
      t.run(function(error) {
        var finish = +new Date();
        var tm = document.createElement('span');
        if ('textContent' in tm) tm.textContent = ' '+(finish-start)+'ms';
        else tm.innerText = ' '+(finish-start)+'ms';
        tm.style.fontSize = '80%';
        t.testEntry.appendChild(tm);
        if (!error) {
          t.testEntry.className = 'success';
          successCount++;
        }
        else {
          t.testEntry.className = 'fail';
          var errorOutput = document.createElement('pre');
          if ('textContent' in errorOutput) errorOutput.textContent = error;
          else errorOutput.innerText = error;
          t.testEntry.appendChild(errorOutput);
          failCount++;
        }

        var summaryText =
            'Tests ('+
            (failCount?'failed '+failCount:'no fails')+
            ', succeeded '+successCount+
            (testsToRun.length>failCount+successCount?', '+(testsToRun.length-failCount-successCount)+' to finish':'')+'):';

        if ('textContent' in summary) summary.textContent = summaryText;
        else summary.innerText = summaryText;

        setTimeout(continueRunTests, 5);
      });
    }

    function addTestRow(i) {
      var t = tests[i];
      var testEntry = document.createElement('div');
      if (testFilter && t.name.toLowerCase().indexOf(testFilter.toLowerCase())<0) {
      	testEntry.className = 'disabled';
        t.disabled = true;
        disabledTestList.appendChild(testEntry);
      }
      else{
      	testEntry.className = 'prepared';
        testsToRun.push(t);
      	testList.appendChild(testEntry);
      }

      if ('textContent' in testEntry) testEntry.textContent = t.name;
      else testEntry.innerText = t.name;
      t.testEntry = testEntry;
    }
  }


  function assert(condition, message) {
    if (!condition) throw new Error(message||'Failure '+condition);
  }

  assert.equal = (function(){
    function equal(expected, actual, message) {
      if (expected!=actual) throw new Error(message||'Unmatch: '+expected+' != '+actual);
    }
    return equal;
  })();

  function generateTests() {

    var allTests = [];
    var _dummy = {};

    for (var k in tests) if (!(k in _dummy) && tests[k] && /^[a-z]/.test(k)) {
      collectTests(k, tests[k]);
    }

    return allTests;


    function collectTests(prefix, obj) {
      if (!obj) return;
      for (var k in obj) if (!(k in _dummy) && obj[k]) {
        if (/^[A-Z]/.test(k) && typeof obj[k] === 'function') {
          // TODO: should we construct here?
        }
        else if (/^[a-z]/.test(k)) {
          if (typeof obj[k]==='function') {
            if (k==='generateTests') {
              var moreTests = obj.generateTests();
              collectTests(prefix, moreTests);
            }
            else {
              addTest(prefix+'.'+k, obj, k);
            }
          }
          else if (typeof obj[k]==='object' && /^[a-z]/.test(k)) {
            collectTests(prefix+'.'+k, obj[k]);
          }
        }
      }
    }

    function addTest(fullname, thisObj, key) {
      var args = functionArgs(thisObj[key]);
      if (args && /callback/.test(args)) {
        allTests.push({
          name: fullname,
          run: function(callback) {
            try {
              thisObj[key](callback);
            }
            catch (error) {
              callback(error);
            }
          }
        });
      }
      else {
        allTests.push({
          name: fullname,
          run: function(callback) {
            try {
              thisObj[key]();
            }
            catch (error) {
              callback(error);
              return;
            }

            callback(null);
          }
        });
      }
    }

  }

  function functionBody(fn, replacements) {
    // first skip until (
    // then skip until )
    // then skip until {
    // then take everything until the last }
    var match =
        /^[^\(]*\([^\)]*\)[^\{]*\{([\s\S]*)\}[^\}]*$/.exec(fn+'');
        // /^[^\(]*\([^\)]*\)[^\{]*\{([ \t]*\n)([\s\S]*)([ \t]*\n[ \t]*)\}[^\}]*$/.exec(fn+'');
    if (!match) return null;

    var bodyText = match[1];
    if (!replacements) return bodyText;
    else return substitute(bodyText, replacements);
  }
function functionArgs(fn) {
    var match = /^[^\(]*\(\s*([^\)]*)\s*\)/.exec(fn+'');
    return match?match[1]:null;
  }
function jsString(str) {
    if (!str) {
      if (typeof str==='string') return '""';
      else if (typeof str==='undefined') return 'undefined';
      else return 'null';
    }

    var _JSON = typeof JSON!=='undefined'? JSON : typeof window === 'undefined' ? null : window.JSON;
    var result = '"';
    var stretchStart = 0;
    for (var i = 0; i < str.length; i++) {
      var code = str.charCodeAt(i);
      var fix;
      switch (code) {
        case 10: fix = i==str.length-1 ? '\\n' : '\\n"+\n  "'; break;
        case 13: fix = '\\r'; break;
        case 92: fix = '\\\\'; break;
        case 34: fix = '\\\"'; break;
        case 9: fix = '\\t'; break;
        default:
          if (code < 32 || // transcribe control codes
              ((code&0xFF00)===0xFD00) || ((code&0xFF00)==0xFF00)) { // transcribe potentially corrupt Unicode
            fix = '\\u'+(0x10000 + code).toString(16).slice(1);
            break;
          }
          continue;
      }

      if (stretchStart!==i) {
      	result += str.slice(stretchStart, i) + fix;
      }
      else {
        result += fix;
      }

      stretchStart = i+1;
    }

    if (stretchStart)
      result += str.slice(stretchStart)+'"';
    else
      result = '"'+str+'"';

    return result;
  }
function jsStringLong(str) {
    if (str===null) return 'null';
    else if (typeof str==='undefined') return 'undefined';
    var wordCounts = {};
    var wordArray = [];
    str.replace(/[a-zA-Z0-9_]+/g, function(w) {
      var key = '*'+w;
      if (wordCounts[key]) {
        wordCounts[key]++;
      }
      else {
        wordCounts[key] = 1;
        wordArray.push(w);
      }
    });
    wordArray.sort(function(w1, w2) {
      var n1 = wordCounts['*'+w1];
      var n2 = wordCounts['*'+w2];
      return n1 > n2 ? -1 : n2 > 1 ? +1 : 0;
    });
    var replaceTable = {};
    for (var i = 0; i < wordArray.length; i++) {
      replaceTable['*'+wordArray[i]] = toLetterNumber(i);
    }

    var compressed = str.replace(/(\s+)|([a-zA-Z0-9_]+)/g, function(match, whitespace, word) {
      if (word) return replaceTable['*'+word];
      return whitespace.
        replace(/ +/g, function(spaces) {
          if(spaces.length<2) return spaces;
          else return 'Z'+spaces.length;
        }).
        replace(/\n/g, 'Z');
    });

    return [
      '(function(d,c,s,r,m,nn,n) { var k = 0;',
      'return c.replace(/([a-zA-Y]+)|(Z[0-9]*)/g, function(x,t,w) {',
        'if (w=="Z") return "\\n";',
        'else if (w&&w.charCodeAt(0)=='+('Z').charCodeAt(0)+') return s[m=parseInt(w.slice(1))] || (s[m] = Array(m+1).join(" "));',
        'if (r.hasOwnProperty(w)) return r[w];',
        'nn=0,m=1;',
        'for(var i=0;i<t.length;i++){',
          'var n=t.charCodeAt(i);',
          'nn+=m*(n-(n>'+(('a').charCodeAt(0)-1)+' ? '+('a').charCodeAt(0)+':'+(('A').charCodeAt(0)-26)+'));',
          'm*='+(25+26)+';',
        '}',
        'if (nn<100 && !r[nn]) return r[nn] = d[nn];', // cache word lookups for 100 most frequent words
        'else return d[nn];',
      '});\n',
      '}("'+wordArray.join(',')+'".split(","),"'+compressed.replace(/\\/g, '\\\\').replace(/\"/g, '\\"').replace(/\r/g, '\\r')+'",[],{}))'
    ].join('\n');

    function toLetterNumber(num) {
      if (!num) return 'a';
      var base = 26+25; // a-z A-Y (leave out uppercase Z)
      var result = [];
      while (num) {
        var n = num % base;
        if (n<26)
          result.push(String.fromCharCode('a'.charCodeAt(0)+n));
        else
          result.push(String.fromCharCode('A'.charCodeAt(0)+n-26));
        num = (num / base)|0;
      }
      return result.join('');
    }
  }


  // # sourceURL=/tests_scripts.js </script>
