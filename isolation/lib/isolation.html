// <script>document.body.innerHTML = '' </script> <script id=submodule_script>

  

function isolation() {

	isolation.build = {
    timestamp: 1477988698388, // Tue Nov 01 2016 08:24:58 GMT+0000 (GMT Standard Time)
    taken: 25760,
    platform: "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36"
};

(function (module) {
    var srz = createComplexSerializer();
    module.createIsolateHost = createIsolateHost;
    module.createIsolateHost.worker = createWebWorkerHost;
    module.createIsolateHost.iframe = createIFrameHost;
    module.createApiHost = createApiHost;
    return createIsolateHost;
    function createIsolateHost(drive, callback) {
        var tryUseWebWorker = detectWebWorkerHint();
        if (tryUseWebWorker) {
            try {
                createWebWorkerHost(drive, callback);
            }
            catch (webWorkerBarredError) {
                createIFrameHost(drive, callback);
            }
        }
        else {
            createIFrameHost(drive, callback);
        }
    }
    function detectWebWorkerHint() {
        try {
            return typeof Worker === 'function';
        }
        catch (webWorkerBarredError) {
            return false;
        }
    }
    function createWebWorkerHost(drive, callback) {
        var webWorker = createWebWorker();
        var diagTimeStart = +new Date();
        var requests = { count: 0 };
        webWorker.onmessage = webworker_onmessage;
        var initMsg = getInitPlatformMessage();
        webWorker.postMessage({ init_worker_connect: initMsg });
        var hst = {
            type: null,
            remoteEval: remoteEval_webworker,
            pushMessage: pushMessage_webworker,
            terminate: terminate_webworker,
            onerror: null,
            onmessage: null,
            onconsole: null
        };
        var fs;
        var cmpSer = createComplexSerializer();
        function completeIsolatedProcess(type) {
            hst.type = type;
            callback(hst);
        }
        function webworker_onmessage(e) {
            if (e.data.requestInitSync) {
                handleRequestInitSync(e.data.requestInitSync);
            }
            else if (e.data.requestInitSync_completed) {
                handleRequestInitSync_completed(e.data.requestInitSync_completed);
            }
            else if (e.data.requestInitAsync) {
                handleRequestInitAsync(e.data.requestInitAsync);
            }
            else if (e.data.invokeSync) {
                handleInvokeSync(e.data.invokeSync);
            }
            else if (e.data.invokeAsync) {
                handleInvokeAsync(e.data.invokeAsync);
            }
            else if (e.data.remoteResponse) {
                handleRemoteResponse(e.data.remoteResponse);
            }
            else if (e.data.remoteErrorResponse) {
                handleRemoteErrorResponse(e.data.remoteErrorResponse);
            }
            else if (e.data.driveUpdates) {
                handleDriveUpdates(e.data);
            }
            else if (e.data.driveRequest_files) {
                handleDriveRequest_files(e.data.driveRequest_files);
            }
            else if (e.data.driveRequest_read) {
                handleDriveRequest_read(e.data.driveRequest_read);
            }
            else if (e.data.driveRequest_storedSize) {
                handleDriveRequest_storedSize(e.data.driveRequest_storedSize);
            }
            else if (e.data.console_echo) {
                handleConsoleEcho(e.data.console_echo);
            }
            else if (e.data.globalError) {
                handleGlobalError(e.data.globalError);
            }
            else if (e.data.key) {
                var req = requests[e.data.key];
                if (!req)
                    return;
                delete requests[e.data.key];
                req(e.data.error, e.data.result);
            }
            else {
                if (typeof console !== 'undefined' && console && typeof console.log === 'function') {
                    console.log('host: unknown message from webworker: ', e.data);
                }
            }
        }
        function handleRequestInitAsync(requestInitAsync) {
            var driveSnapshot = createDriveSnapshot();
            webWorker.postMessage({ driveSnapshot: driveSnapshot });
            completeIsolatedProcess('worker-async');
        }
        function handleRequestInitSync(requestInitSync) {
            createFS(tryReplyOK_waitForInitSyncOK);
            function tryReplyOK_waitForInitSyncOK(error, createdFS) {
                fs = createdFS;
                try {
                    writeFS(requestInitSync, '{ "driveTimestamp": ' + (drive.timestamp | 0) + ' }', function (error) {
                        if (error) {
                            var driveSnapshot = createDriveSnapshot();
                            webWorker.postMessage({ requestInitSync_reject: driveSnapshot });
                        }
                        // if succeeds, they see the file and know already
                    });
                }
                catch (error) {
                    var driveSnapshot = createDriveSnapshot();
                    webWorker.postMessage({ requestInitSync_reject: driveSnapshot });
                }
            }
        }
        function handleInvokeSync(invokeSync) {
            if (!hst.onmessage)
                return;
            hst.onmessage(invokeSync.msg, /*syncReply*/ true, function (error, response) {
                if (invokeSync.key) {
                    var responseMsg = {
                        error: error,
                        response: response
                    };
                    var responseStr = JSON.stringify(responseMsg);
                    writeFS(invokeSync.key, responseStr);
                }
            });
        }
        function handleInvokeAsync(invokeAsync) {
            if (!hst.onmessage)
                return;
            hst.onmessage(invokeAsync.msg, /*syncReply*/ false, function (error, response) {
                var error_serialized = srz.serialize(error);
                webWorker.postMessage({ asyncResponse: { key: invokeAsync.key, error: error_serialized, response: response } });
            });
        }
        function handleRemoteResponse(remoteResponse) {
            var req = requests[remoteResponse.key];
            if (!req)
                return;
            delete requests[remoteResponse.key];
            req(null, remoteResponse.result);
        }
        function handleRemoteErrorResponse(remoteErrorResponse) {
            var req = requests[remoteErrorResponse.key];
            if (!req)
                return;
            delete requests[remoteErrorResponse.key];
            var error_deserialized = srz.deserialize(remoteErrorResponse.error);
            req(error_deserialized);
        }
        function handleDriveUpdates(driveUpdates) {
            driveApplyUpdates(drive, driveUpdates);
        }
        function handleDriveRequest_files(cookie) {
            writeFS(cookie, JSON.stringify(drive.files()));
        }
        function handleDriveRequest_read(msg) {
            writeFS(msg.key, JSON.stringify(drive.read(msg.file)));
        }
        function handleDriveRequest_storedSize(msg) {
            var size;
            if (drive.storedSize)
                size = drive.storedSize(msg.file);
            else
                size = (drive.read(msg.file) || '').length;
            writeFS(msg.key, '' + size);
        }
        function handleConsoleEcho(console_echo) {
            var deser = cmpSer.deserialize(console_echo.args);
            if (hst.onconsole) {
                var onconsole = hst.onconsole;
                onconsole(console_echo.level, deser);
            }
            else {
                var levelFn = console[console_echo.level];
                levelFn.apply(console, deser);
            }
        }
        function handleGlobalError(globalError) {
            var deser = cmpSer.deserialize(globalError);
            if (hst.onerror) {
                var err = cmpSer.deserialize(globalError);
                var onerror = hst.onerror;
                onerror(err);
            }
        }
        function createDriveSnapshot() {
            var driveSnapshot = { timestamp: drive.timestamp };
            var driveFiles = drive.files();
            for (var i = 0; i < driveFiles.length; i++) {
                driveSnapshot[driveFiles[i]] = drive.read(driveFiles[i]);
            }
            return driveSnapshot;
        }
        function handleRequestInitSync_completed(requestInitSync_completed) {
            completeIsolatedProcess('worker-sync');
        }
        function createFS(callback) {
            try {
                if (typeof requestFileSystem === 'function') {
                    var reqFS = requestFileSystem;
                    var reqFS_name = 'requestFileSystem';
                }
                else if (typeof webkitRequestFileSystem === 'function') {
                    var reqFS = webkitRequestFileSystem;
                    var reqFS_name = 'webkitRequestFileSystem';
                }
                else if (typeof mozRequestFileSystem === 'function') {
                    var reqFS = mozRequestFileSystem;
                    var reqFS_name = 'mozRequestFileSystem';
                }
                else if (typeof oRequestFileSystem === 'function') {
                    var reqFS = oRequestFileSystem;
                    var reqFS_name = 'oRequestFileSystem';
                }
                else if (typeof msRequestFileSystem === 'function') {
                    var reqFS = msRequestFileSystem;
                    var reqFS_name = 'msRequestFileSystem';
                }
                else {
                    callback(new Error('filesystem cannot be found'));
                    return;
                }
                var timeoutReqFS = setTimeout(function () {
                    clearTimeout(timeoutReqFS);
                    timeoutReqFS = 0;
                    callback(new Error('Waiting for ' + reqFS_name + ' timed out.'));
                }, 1000);
                reqFS('TEMPORARY', 1024, function (fs) {
                    if (timeoutReqFS) {
                        clearTimeout(timeoutReqFS);
                    }
                    else {
                        return; // timeout already fired, it's too late
                    }
                    callback(null, fs);
                });
            }
            catch (error) {
                callback(error);
            }
        }
        function writeFS(name, content, callback) {
            try {
                fs.root.getFile('/isolation-syncfs-aided--' + name, { create: true }, getFile_handler, callback);
            }
            catch (error) {
                if (callback)
                    callback(error);
            }
            function getFile_handler(fileEntry) {
                try {
                    fileEntry.createWriter(createWriter_handler, callback);
                }
                catch (error) {
                    if (callback)
                        callback(error);
                }
            }
            function createWriter_handler(fileWriter) {
                try {
                    if (callback) {
                        fileWriter.onwriteend = fileWriter_onwriteend;
                        fileWriter.onerror = callback;
                    }
                    var bb = new Blob([content]);
                    fileWriter.write(bb);
                }
                catch (error) {
                    if (callback)
                        callback(error);
                }
            }
            function fileWriter_onwriteend(e) { callback(); }
        }
        function remoteEval_webworker(fnScript, arg, path, callback) {
            var key = (requests.count++).toString();
            // generate a bit of timestamp for the benefit of easier debugging
            if (Date.now)
                key += '-' + (Date.now() - diagTimeStart) + 'ms';
            else
                key += '-' + (+new Date() - diagTimeStart) + 'ms';
            requests[key] = function (error, result) {
                callback(error, result);
            };
            webWorker.postMessage({ remoteEval: { script: fnScript, arg: arg, path: path, key: key } });
        }
        function pushMessage_webworker(msg) {
            webWorker.postMessage({ pushMessage: msg });
        }
        function terminate_webworker() {
            webWorker.terminate();
        }
        function createWebWorker() {
            var worker_body = getWorkerAgentScript(false /*doNotRun: false, i.e. do run straight away*/);
            if (typeof Blob === 'function') {
                try {
                    return webWorkerFromBlob();
                }
                catch (errWebWorkerBlob) {
                    return webWorkerFromDataURI();
                }
            }
            else {
                try {
                    return webWorkerFromDataURI();
                }
                catch (errWorkerDataURI) {
                    return webWorkerFromBlob();
                }
            }
            function webWorkerFromDataURI() {
                var worker = new Worker('data:application/javascript,' + encodeURIComponent(worker_body));
                return worker;
            }
            function webWorkerFromBlob() {
                var blob = new Blob([worker_body], { type: 'text/javascript' });
                var url = URL.createObjectURL(blob);
                var worker = new Worker(url);
                return worker;
            }
        }
    }
    function createIFrameHost(drive, callback) {
        var cmpSer = createComplexSerializer();
        var frm = createIFrame();
        callback(frm.hst);
        function terminate_iframe() {
            if (frm && frm.ifr.parentElement) {
                frm.ifr.parentElement.removeChild(frm.ifr);
                frm = null;
            }
        }
        function createIFrame() {
            var ifr = document.createElement('iframe');
            ifr.src = 'about:blank'; // TODO: explore loading from Blob/data URI directly
            ifr.style.cssText = 'display: none; position: absolute; left: -50px; top: -50px; width: 0px; height: 0px;';
            document.body.appendChild(ifr);
            var ifrwin = ifr.contentWindow || ifr.window;
            var ifr_script = getWorkerAgentScript(true /*doNotRun*/);
            ifrwin.document.write('<' + 'script>' + ifr_script + '</' + 'script>');
            var hstCalls = ifrwin.window.agentFunction_iframe(drive);
            hstCalls.onerror = hst_onerror_iframe;
            hstCalls.onmessage = hst_onmessage_iframe;
            hstCalls.onconsole = hst_onconsole_iframe;
            var hst = {
                type: 'iframe',
                remoteEval: hst_remoteEval,
                pushMessage: hst_pushMessage,
                terminate: terminate_iframe,
                onerror: null,
                onmessage: null,
                onconsole: null
            };
            return { ifr: ifr, hst: hst };
            function hst_pushMessage(msg) {
                var msg_ser = cmpSer.serialize(msg);
                hstCalls.pushMessage(msg_ser);
            }
            function hst_remoteEval(fnScript, arg, path, callback) {
                var arg_ser = cmpSer.serialize(arg);
                hstCalls.remoteEval(fnScript, arg_ser, path, callback ? hst_remoteEval_callback : null);
                function hst_remoteEval_callback(error, result) {
                    var error_deser = cmpSer.deserialize(error);
                    var result_deser = cmpSer.deserialize(result);
                    callback(error_deser, result_deser);
                }
            }
        }
        function hst_onerror_iframe(err) {
            if (frm.hst.onerror) {
                var err_deser = cmpSer.deserialize(err);
                frm.hst.onerror(err_deser);
            }
        }
        function hst_onmessage_iframe(msg, syncReply, callback) {
            if (frm.hst.onmessage) {
                var msg_deser = cmpSer.deserialize(msg);
                frm.hst.onmessage(msg_deser, syncReply, callback ? hst_onmessage_iframe_callback : null);
            }
            function hst_onmessage_iframe_callback(error, response) {
                var error_deser = cmpSer.deserialize(error);
                var response_deser = cmpSer.deserialize(response);
                callback(error_deser, response_deser);
            }
        }
        function hst_onconsole_iframe(level, args) {
            if (frm.hst.onconsole) {
                var args_deser = cmpSer.deserialize(args);
                frm.hst.onconsole(level, args_deser);
            }
        }
    }
    function getInitPlatformMessage() {
        var initMsg = {
            versions: { navigator: navigator.userAgent },
            platform: (navigator.platform || 'Win32').toLowerCase(),
            vendor: navigator.vendor || (String.fromCharCode(0x47) + 'oo' + String.fromCharCode(0x47).toLowerCase() + 'le ' + ('PCInc').slice(2) + '.'),
            languages: navigator.languages || (navigator.language ? [navigator.language] : ['en-us']),
            cpuCount: navigator.hardwareConcurrency || 1
        };
        return initMsg;
    }
    function createApiHost(drive, options, callback) {
        isolation.createIsolateHost(drive, function (host) {
            var noapiSetupScript = getApiScript() + '\n\n\n\n' +
                'arguments[0].drive = connection_to_parent.drive;\n' +
                'initApiContext(arguments[0]);';
            if (!options.versions) {
                var pltf = getInitPlatformMessage();
                options.versions = pltf.versions;
            }
            host.remoteEval(noapiSetupScript, options, '/isolation_noapi.js', function (error) {
                if (error) {
                    // TODO: console.log??
                    callback(null);
                    return;
                }
                var api_host = host;
                api_host.runGlobal = api_remote_runGlobal;
                api_host.onmessage = api_remote_onmessage;
                api_host.ondispose = null;
                api_host.exitCode = null;
                api_host.keepAlive = api_keepAlive;
                var reqResDispatcher = createRequestResponseDispatcher();
                var keepAliveReqResDispatcher = createRequestResponseDispatcher();
                callback(api_host);
                function api_remote_runGlobal(script, path, callback) {
                    var key = reqResDispatcher.pushCallback(callback);
                    api_host.pushMessage({ noapi_runGlobal: { script: script, path: path, key: key } });
                }
                function api_remote_onmessage(msg) {
                    if (msg.noapi_ondispose) {
                        api_host.exitCode = msg.noapi_ondispose.exitCode;
                        var api_host_ondispose = api_host.ondispose;
                        if (api_host_ondispose)
                            api_host_ondispose();
                    }
                    else if (msg.noapi_runGlobal_error) {
                        var key = msg.noapi_runGlobal_error.key;
                        if (!key) {
                            // TODO: console.log??
                            return;
                        }
                        var callback = reqResDispatcher.popCallback(key);
                        if (!callback) {
                            // TODO: console.log??
                            return;
                        }
                        var err = srz.deserialize(msg.noapi_runGlobal_error.error);
                        callback(err);
                    }
                    else if (msg.noapi_runGlobal_response) {
                        var key = msg.noapi_runGlobal_response.key;
                        if (!key) {
                            // TODO: console.log??
                            return;
                        }
                        var callback = reqResDispatcher.popCallback(key);
                        if (!callback) {
                            // TODO: console.log??
                            return;
                        }
                        var response = srz.deserialize(msg.noapi_runGlobal_response.response);
                        callback(null, response);
                    }
                    else if (msg.keepAlive_addRef_response) {
                        var keepAlive_onToken = keepAliveReqResDispatcher.popCallback(msg.keepAlive_addRef_response.key);
                        keepAlive_onToken(msg.keepAlive_addRef_response.token);
                    }
                    else if (msg.keepAlive_release_response) {
                    }
                }
                function api_keepAlive() {
                    var key = keepAliveReqResDispatcher.pushCallback(api_keepAlive_onToken);
                    var token = null;
                    var releaseCalled = false;
                    api_host.pushMessage({ noapi_keepAlive_addRef: { key: key } });
                    return api_keepAlive_release;
                    function api_keepAlive_release() {
                        if (token) {
                            api_host.pushMessage({ noapi_keepAlive_release: { token: token } });
                        }
                        else {
                            releaseCalled = true;
                        }
                    }
                    function api_keepAlive_onToken(token) {
                        if (releaseCalled) {
                            api_host.pushMessage({ noapi_keepAlive_release: { token: token } });
                        }
                        else {
                            token = token;
                        }
                    }
                }
            });
        });
    }
    function getWorkerAgentScript(doNOTrun) {
        var worker_body = "function RUN_ASYNC_CHANNEL(driveSnapshot) {\n"+
  "    self_onmessage = ASYNC_CHANNEL_webworker_onmessage;\n"+
  "    var pushMessageDispatcher = createPushMessageDispatcher();\n"+
  "    var requestResponseDispatcher = createRequestResponseDispatcher();\n"+
  "    var drive = {\n"+
  "        timestamp: driveSnapshot.timestamp,\n"+
  "        files: files_ASYNC_CHANNEL,\n"+
  "        read: read_ASYNC_CHANNEL,\n"+
  "        write: write_ASYNC_CHANNEL,\n"+
  "        storedSize: storedSize_ASYNC_CHANNEL\n"+
  "    };\n"+
  "    var tmDrive = {\n"+
  "        timestamp: driveSnapshot.timestamp,\n"+
  "        write: driveUpdate_write_ASYNC_CHANNEL\n"+
  "    };\n"+
  "    connection_to_parent = {\n"+
  "        drive: drive,\n"+
  "        onPushMessage: pushMessageDispatcher.onPushMessage,\n"+
  "        invokeAsync: invokeAsync_ASYNC_CHANNEL\n"+
  "    };\n"+
  "    install_console_redirect(postMessageToHost, cmpSer.serialize);\n"+
  "    function invokeAsync_ASYNC_CHANNEL(msg, callback) {\n"+
  "        var msg_ser = cmpSer.serialize(msg);\n"+
  "        if (callback) {\n"+
  "            var key = requestResponseDispatcher.pushCallback(callback);\n"+
  "            postMessageToHost({ invokeAsync: { key: key, msg: msg_ser } });\n"+
  "        }\n"+
  "        else {\n"+
  "            postMessageToHost({ invokeAsync: { msg: msg_ser } });\n"+
  "        }\n"+
  "    }\n"+
  "    function ASYNC_CHANNEL_webworker_onmessage(e) {\n"+
  "        if (e.data.asyncResponse) {\n"+
  "            handleAsyncResponse_ASYNC_CHANNEL(e.data.asyncResponse);\n"+
  "        }\n"+
  "        else if (e.data.remoteEval) {\n"+
  "            handleRemoteEval_EITHER_CHANNEL(e.data.remoteEval);\n"+
  "        }\n"+
  "        else if (e.data.pushMessage) {\n"+
  "            pushMessageDispatcher.handlePushMessage(e.data.pushMessage);\n"+
  "        }\n"+
  "        else if (e.data.driveUpdates) {\n"+
  "            handleDriveUpdates_ASYNC_CHANNEL(e.data.driveUpdates);\n"+
  "        }\n"+
  "        else {\n"+
  "            reportUnknownMessage_ASYNC_CHANNEL(e);\n"+
  "        }\n"+
  "    }\n"+
  "    function handleAsyncResponse_ASYNC_CHANNEL(asyncResponse) {\n"+
  "        if (!asyncResponse.key) {\n"+
  "            reportKeylessResponse(asyncResponse);\n"+
  "            return;\n"+
  "        }\n"+
  "        var callback = requestResponseDispatcher.popCallback(asyncResponse.key);\n"+
  "        callback(asyncResponse.error && cmpSer.serialize(asyncResponse.error), asyncResponse.result);\n"+
  "    }\n"+
  "    function handleDriveUpdates_ASYNC_CHANNEL(driveUpdates) {\n"+
  "        driveSnapshot.timestamp = Math.max(driveSnapshot.timestamp, driveUpdates.timestamp);\n"+
  "        driveApplyUpdates(tmDrive, driveUpdates);\n"+
  "    }\n"+
  "    function reportUnknownMessage_ASYNC_CHANNEL(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown in ASYNC_CHANNEL: ', e.data, e);\n"+
  "    }\n"+
  "    function driveUpdate_write_ASYNC_CHANNEL(file, content) {\n"+
  "        if (content || typeof content === 'string')\n"+
  "            driveSnapshot[file] = content;\n"+
  "        else\n"+
  "            delete driveSnapshot[file];\n"+
  "    }\n"+
  "    function reportKeylessResponse(asyncResponse) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: asyncResponse with no key: ', asyncResponse);\n"+
  "    }\n"+
  "    function createDriveFromSnapshot(snapshot) {\n"+
  "        var tmDrive = {\n"+
  "            timestamp: drive.timestamp,\n"+
  "            write: function (file, content) {\n"+
  "                drive.timestamp = Math.max(drive.timestamp, tmDrive.timestamp);\n"+
  "                if (content || typeof content === 'string')\n"+
  "                    driveSnapshot[file] = content;\n"+
  "                else\n"+
  "                    delete driveSnapshot[file];\n"+
  "            }\n"+
  "        };\n"+
  "        return drive;\n"+
  "    }\n"+
  "    function files_ASYNC_CHANNEL() {\n"+
  "        var result = [];\n"+
  "        for (var k in driveSnapshot) {\n"+
  "            if (k && k.charCodeAt(0) === 47)\n"+
  "                result.push(k);\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function read_ASYNC_CHANNEL(file) {\n"+
  "        var result = driveSnapshot[file];\n"+
  "        if (result || typeof result !== 'undefined')\n"+
  "            return result;\n"+
  "        else\n"+
  "            return null;\n"+
  "    }\n"+
  "    function write_ASYNC_CHANNEL(file, content) {\n"+
  "        var msg;\n"+
  "        if (!content && (content === null || typeof content === 'undefined')) {\n"+
  "            delete driveSnapshot[file];\n"+
  "            msg = { driveUpdates: [{ deleteFile: file }], timestamp: drive.timestamp };\n"+
  "        }\n"+
  "        else {\n"+
  "            driveSnapshot[file] = content;\n"+
  "            msg = { driveUpdates: [{ updateFile: file, content: content }], timestamp: drive.timestamp };\n"+
  "        }\n"+
  "        postMessageToHost(msg);\n"+
  "    }\n"+
  "    function storedSize_ASYNC_CHANNEL(file) {\n"+
  "        var file = read_ASYNC_CHANNEL(file);\n"+
  "        if (file)\n"+
  "            return file.length;\n"+
  "        else\n"+
  "            return 0;\n"+
  "    }\n"+
  "}\n"+
  "function RUN_IFRAME_CHANNEL(drive) {\n"+
  "    var _eval = eval;\n"+
  "    var cmpSer = createComplexSerializer();\n"+
  "    if (typeof addEventListener === 'function') {\n"+
  "        addEventListener('error', iframeGlobal_onerror, true);\n"+
  "    }\n"+
  "    else if (typeof attachEvent === 'function') {\n"+
  "        attachEvent('onerror', iframeGlobal_onerror);\n"+
  "    }\n"+
  "    else {\n"+
  "        window.onerror = iframeGlobal_onerror;\n"+
  "    }\n"+
  "    var hstCalls = {\n"+
  "        remoteEval: remoteEval_iframe,\n"+
  "        pushMessage: pushMessage_iframe,\n"+
  "        onerror: null,\n"+
  "        onmessage: null,\n"+
  "        onconsole: null\n"+
  "    };\n"+
  "    var registeredPushMessageCallbacks = [];\n"+
  "    var registeredPushMessageCallbacks_length = 0;\n"+
  "    installConsoleRedirect();\n"+
  "    connection_to_parent = {\n"+
  "        drive: drive,\n"+
  "        invokeAsync: invokeAsync_toParent,\n"+
  "        invokeSync: invokeSync_toParent,\n"+
  "        onPushMessage: onPushMessage\n"+
  "    };\n"+
  "    return hstCalls;\n"+
  "    function installConsoleRedirect() {\n"+
  "        if (typeof console !== 'undefined' && console) {\n"+
  "            ConsoleRedirect.prototype = console;\n"+
  "        }\n"+
  "        var console_redirect = new ConsoleRedirect();\n"+
  "        console_redirect.log = log_redirect;\n"+
  "        console_redirect.warn = warn_redirect;\n"+
  "        console_redirect.debug = debug_redirect;\n"+
  "        console_redirect.trace = trace_redirect;\n"+
  "        console_redirect.error = error_redirect;\n"+
  "        console = console_redirect;\n"+
  "        function ConsoleRedirect() { }\n"+
  "        function log_redirect() {\n"+
  "            var args = [];\n"+
  "            for (var i = 0; i < arguments.length; i++) {\n"+
  "                args.push(arguments[i]);\n"+
  "            }\n"+
  "            console_level_redirect('log', args);\n"+
  "        }\n"+
  "        function warn_redirect() {\n"+
  "            var args = [];\n"+
  "            for (var i = 0; i < arguments.length; i++) {\n"+
  "                args.push(arguments[i]);\n"+
  "            }\n"+
  "            console_level_redirect('warn', args);\n"+
  "        }\n"+
  "        function debug_redirect() {\n"+
  "            var args = [];\n"+
  "            for (var i = 0; i < arguments.length; i++) {\n"+
  "                args.push(arguments[i]);\n"+
  "            }\n"+
  "            console_level_redirect('debug', args);\n"+
  "        }\n"+
  "        function trace_redirect() {\n"+
  "            var args = [];\n"+
  "            for (var i = 0; i < arguments.length; i++) {\n"+
  "                args.push(arguments[i]);\n"+
  "            }\n"+
  "            console_level_redirect('trace', args);\n"+
  "        }\n"+
  "        function error_redirect() {\n"+
  "            var args = [];\n"+
  "            for (var i = 0; i < arguments.length; i++) {\n"+
  "                args.push(arguments[i]);\n"+
  "            }\n"+
  "            console_level_redirect('error', args);\n"+
  "        }\n"+
  "        function console_level_redirect(level, args) {\n"+
  "            var args_ser = cmpSer.serialize(args);\n"+
  "            if (hstCalls.onconsole) {\n"+
  "                hstCalls.onconsole(level, args_ser);\n"+
  "            }\n"+
  "            else {\n"+
  "                if (ConsoleRedirect.prototype) {\n"+
  "                    var levelFn = ConsoleRedirect.prototype[level] || ConsoleRedirect.prototype.log;\n"+
  "                    if (levelFn)\n"+
  "                        levelFn.apply(console, args_ser);\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "    }\n"+
  "    function invokeAsync_toParent(msg, callback) {\n"+
  "        try {\n"+
  "            var msg_ser = cmpSer.serialize(msg);\n"+
  "            hstCalls.onmessage(msg_ser, /*syncReply*/ true, callback);\n"+
  "        }\n"+
  "        catch (error) {\n"+
  "            var error_ser = cmpSer.serialize(error);\n"+
  "            callback(error_ser, null);\n"+
  "        }\n"+
  "    }\n"+
  "    function invokeSync_toParent(msg) {\n"+
  "        var msg_ser = cmpSer.serialize(msg);\n"+
  "        var reply;\n"+
  "        hstCalls.onmessage(msg_ser, /*syncReply*/ true, function (reply_passed) { return reply = reply_passed; });\n"+
  "        return reply;\n"+
  "    }\n"+
  "    function iframeGlobal_onerror(e) {\n"+
  "        var err = e.error || e;\n"+
  "        hstCalls.onerror(cmpSer.serialize(err));\n"+
  "    }\n"+
  "    function remoteEval_iframe(fnScript, arg, path, callback) {\n"+
  "        try {\n"+
  "            // keep that double-function enclosure, as IE treats a function inside round brackets as a declaration rather than a value\n"+
  "            var fn = (0, _eval)('(function(){ return function(){' + fnScript + '\\n}})()' + (path ? '//# ' + 'sourceURL=' + path : ''));\n"+
  "            var result = fn(arg);\n"+
  "        }\n"+
  "        catch (error) {\n"+
  "            var error_ser = cmpSer.serialize(error);\n"+
  "            callback(error_ser);\n"+
  "            return;\n"+
  "        }\n"+
  "        var result_ser = cmpSer.serialize(result);\n"+
  "        callback(null, result_ser);\n"+
  "    }\n"+
  "    function pushMessage_iframe(msg) {\n"+
  "        for (var i = 0; i < registeredPushMessageCallbacks_length; i++) {\n"+
  "            var cb = registeredPushMessageCallbacks[i];\n"+
  "            if (cb)\n"+
  "                cb(msg);\n"+
  "        }\n"+
  "    }\n"+
  "    function onPushMessage(registerCallback) {\n"+
  "        var index = registeredPushMessageCallbacks_length;\n"+
  "        registeredPushMessageCallbacks.push(registerCallback);\n"+
  "        registeredPushMessageCallbacks_length++;\n"+
  "        return unregister_pushMessageCallback;\n"+
  "        function unregister_pushMessageCallback() {\n"+
  "            if (index < 0)\n"+
  "                return;\n"+
  "            delete registeredPushMessageCallbacks[index];\n"+
  "            index = -1;\n"+
  "            // adjust the tail (removal of callbacks may run out of order)\n"+
  "            var newLength = registeredPushMessageCallbacks_length;\n"+
  "            while (!registeredPushMessageCallbacks[newLength] && newLength >= 0) {\n"+
  "                newLength--;\n"+
  "            }\n"+
  "            if (newLength !== registeredPushMessageCallbacks_length)\n"+
  "                registeredPushMessageCallbacks_length = newLength;\n"+
  "        }\n"+
  "    }\n"+
  "}\n"+
  "function RUN_SYNCFS_AIDED_CHANNEL(fs, msg) {\n"+
  "    var cookieBaseDate = +new Date();\n"+
  "    self_onmessage = SYNCFS_AIDED_CHANNEL_webworker_onmessage;\n"+
  "    var pushMessageDispatcher = createPushMessageDispatcher();\n"+
  "    var requestResponseDispatcher = createRequestResponseDispatcher();\n"+
  "    var drive = {\n"+
  "        timestamp: msg.driveTimestamp,\n"+
  "        files: files_SYNCFS_AIDED_CHANNEL,\n"+
  "        read: read_SYNCFS_AIDED_CHANNEL,\n"+
  "        write: write_SYNCFS_AIDED_CHANNEL,\n"+
  "        storedSize: storedSize_SYNCFS_AIDED_CHANNEL\n"+
  "    };\n"+
  "    connection_to_parent = {\n"+
  "        drive: drive,\n"+
  "        onPushMessage: pushMessageDispatcher.onPushMessage,\n"+
  "        invokeAsync: invokeAsync_SYNCFS_AIDED_CHANNEL,\n"+
  "        invokeSync: invokeSync_SYNCFS_AIDED_CHANNEL\n"+
  "    };\n"+
  "    install_console_redirect(postMessageToHost, cmpSer.serialize);\n"+
  "    function SYNCFS_AIDED_CHANNEL_webworker_onmessage(e) {\n"+
  "        if (e.data.asyncResponse) {\n"+
  "            handleAsyncResponse_SYNCFS_AIDED_CHANNEL(e.data.asyncResponse);\n"+
  "        }\n"+
  "        else if (e.data.remoteEval) {\n"+
  "            handleRemoteEval_EITHER_CHANNEL(e.data.remoteEval);\n"+
  "        }\n"+
  "        else if (e.data.pushMessage) {\n"+
  "            pushMessageDispatcher.handlePushMessage(e.data.pushMessage);\n"+
  "        }\n"+
  "        else if (e.data.driveUpdates) {\n"+
  "            handleDriveUpdates_SYNCFS_AIDED_CHANNEL(e.data.driveUpdates);\n"+
  "        }\n"+
  "        else {\n"+
  "            reportUnknownMessage_SYNCFS_AIDED_CHANNEL(e);\n"+
  "        }\n"+
  "    }\n"+
  "    function handleAsyncResponse_SYNCFS_AIDED_CHANNEL(asyncResponse) {\n"+
  "        if (!asyncResponse.key) {\n"+
  "            reportKeylessResponse(asyncResponse);\n"+
  "            return;\n"+
  "        }\n"+
  "        var callback = requestResponseDispatcher.popCallback(asyncResponse.key);\n"+
  "        callback(asyncResponse.error && cmpSer.serialize(asyncResponse.error), asyncResponse.result);\n"+
  "    }\n"+
  "    function handleDriveUpdates_SYNCFS_AIDED_CHANNEL(driveUpdates) {\n"+
  "        // TODO: support drive watch\n"+
  "    }\n"+
  "    function reportUnknownMessage_SYNCFS_AIDED_CHANNEL(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown in SYNCFS_AIDED_CHANNEL: ', e.data, e);\n"+
  "    }\n"+
  "    function files_SYNCFS_AIDED_CHANNEL() {\n"+
  "        var cookieFilename = generateCookieFilename('drive_files_');\n"+
  "        var files_response = postMessageWaitForResponse({ driveRequest_files: cookieFilename }, cookieFilename, 'drive.files_');\n"+
  "        return files_response;\n"+
  "    }\n"+
  "    function read_SYNCFS_AIDED_CHANNEL(file) {\n"+
  "        var cookieFilename = generateCookieFilename('drive_read_');\n"+
  "        var read_response = postMessageWaitForResponse({ driveRequest_read: { key: cookieFilename, file: file } }, cookieFilename, 'drive.read_');\n"+
  "        return read_response;\n"+
  "    }\n"+
  "    function write_SYNCFS_AIDED_CHANNEL(file, content) {\n"+
  "        var msg;\n"+
  "        if (!content && (content === null || typeof content === 'undefined')) {\n"+
  "            msg = { driveUpdates: [{ deleteFile: file }], timestamp: drive.timestamp };\n"+
  "        }\n"+
  "        else {\n"+
  "            msg = { driveUpdates: [{ updateFile: file, content: content }], timestamp: drive.timestamp };\n"+
  "        }\n"+
  "        postMessageToHost(msg);\n"+
  "    }\n"+
  "    function storedSize_SYNCFS_AIDED_CHANNEL(file) {\n"+
  "        var cookieFilename = generateCookieFilename('drive_storedSize_');\n"+
  "        var storedSize_response = postMessageWaitForResponse({ driveRequest_storedSize: { key: cookieFilename, file: file } }, cookieFilename, 'drive.storedSize_');\n"+
  "        return storedSize_response;\n"+
  "    }\n"+
  "    function reportKeylessResponse(asyncResponse) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: asyncResponse with no key: ', asyncResponse);\n"+
  "    }\n"+
  "    function invokeAsync_SYNCFS_AIDED_CHANNEL(msg, callback) {\n"+
  "        var msg_ser = cmpSer.serialize(msg);\n"+
  "        if (callback) {\n"+
  "            var key = requestResponseDispatcher.pushCallback(callback);\n"+
  "            postMessageToHost({ invokeAsync: { key: key, msg: msg_ser } });\n"+
  "        }\n"+
  "        else {\n"+
  "            postMessageToHost({ invokeAsync: { msg: msg_ser } });\n"+
  "        }\n"+
  "    }\n"+
  "    function invokeSync_SYNCFS_AIDED_CHANNEL(msg) {\n"+
  "        var cookieFilename = generateCookieFilename('invokeSync_');\n"+
  "        var invokeSync_response = postMessageWaitForResponse({ invokeSync: { key: cookieFilename, msg: msg } }, cookieFilename, 'invokeSync_');\n"+
  "        if (invokeSync_response.error) {\n"+
  "            var toThrow = cmpSer.deserialize(invokeSync_response.error);\n"+
  "            throw toThrow;\n"+
  "        }\n"+
  "        return invokeSync_response.response;\n"+
  "    }\n"+
  "    function postMessageWaitForResponse(msg, cookieFile, idle_sping_reason) {\n"+
  "        postMessageToHost(msg);\n"+
  "        var parseFailAfter;\n"+
  "        while (true) {\n"+
  "            var content = getFileSync(fs, cookieFile);\n"+
  "            if (content) {\n"+
  "                var now = Date.now ? Date.now() : +new Date();\n"+
  "                if (parseFailAfter) {\n"+
  "                    if (now > parseFailAfter) {\n"+
  "                        var result = _JSON_parse(content);\n"+
  "                        return result;\n"+
  "                    }\n"+
  "                }\n"+
  "                try {\n"+
  "                    var result = _JSON_parse(content);\n"+
  "                    return result;\n"+
  "                }\n"+
  "                catch (error) {\n"+
  "                    if (!parseFailAfter)\n"+
  "                        parseFailAfter = now + 3000; // 3 seconds to complete the writing\n"+
  "                }\n"+
  "            }\n"+
  "            SYNCFS_idle_spin(idle_sping_reason);\n"+
  "        }\n"+
  "    }\n"+
  "    function generateCookieFilename(hint) {\n"+
  "        var fn = hint + 'T' + ((+new Date()) - cookieBaseDate) + 'R' + Math.random().toString().replace(/\\./g, '');\n"+
  "        return fn;\n"+
  "    }\n"+
  "}\n"+
  "function SYNCFS_idle_spin(reason) {\n"+
  "}\n"+
  "var _addEventListener;\n"+
  "var _setInterval;\n"+
  "var _clearInterval;\n"+
  "var _postMessage;\n"+
  "var _Function;\n"+
  "var _FileReaderSync;\n"+
  "var _eval;\n"+
  "var _console_log;\n"+
  "var _JSON_parse;\n"+
  "function captureGlobalScopeVariables_atStart() {\n"+
  "    _addEventListener = addEventListener;\n"+
  "    _setInterval = setInterval;\n"+
  "    _clearInterval = clearInterval;\n"+
  "    _postMessage = postMessage;\n"+
  "    _Function = Function;\n"+
  "    _FileReaderSync = FileReaderSync;\n"+
  "    _eval = eval;\n"+
  "    if (typeof console !== 'undefined' && console && typeof console.log === 'function') {\n"+
  "        if (console.log.bind)\n"+
  "            _console_log = console.log.bind(console);\n"+
  "    }\n"+
  "    if (typeof JSON !== 'undefined' && JSON && typeof JSON.parse === 'function') {\n"+
  "        if (JSON.parse.bind) {\n"+
  "            _JSON_parse = JSON.parse.bind(JSON);\n"+
  "        }\n"+
  "        else {\n"+
  "            _JSON_parse = function (str) { return _eval('(' + str + ')'); };\n"+
  "        }\n"+
  "    }\n"+
  "}\n"+
  "function postMessageToHost(msg) {\n"+
  "    _postMessage(msg);\n"+
  "}\n"+
  "function addGlobalErrorListener() {\n"+
  "    _addEventListener('error', function (e) {\n"+
  "        var err_ser = cmpSer.serialize(e.error || e);\n"+
  "        postMessageToHost({ globalError: { err_ser: err_ser } });\n"+
  "    });\n"+
  "}\n"+
  "var cmpSer = createComplexSerializer();\n"+
  "function agentFunction_iframe(drive) {\n"+
  "    return RUN_IFRAME_CHANNEL(drive);\n"+
  "}\n"+
  "function agentFunction_webWorker() {\n"+
  "    captureGlobalScopeVariables_atStart();\n"+
  "    addMessageEventListener();\n"+
  "    addGlobalErrorListener();\n"+
  "    expectMessage_init_worker_connect(function (init_worker_connect) {\n"+
  "        if (init_worker_connect) {\n"+
  "            try {\n"+
  "                if (typeof console !== 'undefined' && typeof console.info === 'function') {\n"+
  "                    console.info('worker init: ', init_worker_connect);\n"+
  "                }\n"+
  "            }\n"+
  "            catch (consoleError) { }\n"+
  "        }\n"+
  "        var fs = detectSyncFSAvailable_or_reason();\n"+
  "        if (typeof fs === 'string')\n"+
  "            return requestAsyncMode(fs);\n"+
  "        try {\n"+
  "            trySetupSyncMode(fs);\n"+
  "        }\n"+
  "        catch (error) {\n"+
  "            requestAsyncMode(error.message);\n"+
  "        }\n"+
  "    });\n"+
  "}\n"+
  "function detectSyncFSAvailable_or_reason() {\n"+
  "    var reqFS;\n"+
  "    var reqFS_variant_name;\n"+
  "    try {\n"+
  "        reqFS_variant_name = 'requestFileSystemSync';\n"+
  "        if (typeof requestFileSystemSync === 'function')\n"+
  "            reqFS = requestFileSystemSync;\n"+
  "        else {\n"+
  "            reqFS_variant_name = 'webkitRequestFileSystemSync';\n"+
  "            if (typeof webkitRequestFileSystemSync === 'function')\n"+
  "                reqFS = webkitRequestFileSystemSync;\n"+
  "            else {\n"+
  "                reqFS_variant_name = 'mozRequestFileSystemSync';\n"+
  "                if (typeof mozRequestFileSystemSync === 'function')\n"+
  "                    reqFS = mozRequestFileSystemSync;\n"+
  "                else {\n"+
  "                    reqFS_variant_name = 'oRequestFileSystemSync';\n"+
  "                    if (typeof oRequestFileSystemSync === 'function')\n"+
  "                        reqFS = oRequestFileSystemSync;\n"+
  "                    else {\n"+
  "                        reqFS_variant_name = 'msRequestFileSystemSync';\n"+
  "                        if (typeof msRequestFileSystemSync === 'function')\n"+
  "                            reqFS = msRequestFileSystemSync;\n"+
  "                        else\n"+
  "                            return 'requestFileSystemSync and its prefixed variants are unavailable';\n"+
  "                    }\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        return error.message + ' - probing typeof ' + reqFS_variant_name;\n"+
  "    }\n"+
  "    try {\n"+
  "        var fs = reqFS('TEMPORARY', 1024);\n"+
  "        return fs;\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        return error.message + ' - invoking ' + reqFS_variant_name;\n"+
  "    }\n"+
  "}\n"+
  "function expectMessage_init_worker_connect(callback) {\n"+
  "    self_onmessage = function (e) {\n"+
  "        if (e.data.init_worker_connect) {\n"+
  "            self_onmessage = null;\n"+
  "            callback(e.data.init_worker_connect);\n"+
  "        }\n"+
  "        else {\n"+
  "            reportUnknownMessage_expecting_init_worker_connect(e);\n"+
  "        }\n"+
  "    };\n"+
  "    function reportUnknownMessage_expecting_init_worker_connect(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown expecting init_worker_connect: ', e.data, e);\n"+
  "    }\n"+
  "}\n"+
  "function handleRemoteEval_EITHER_CHANNEL(remoteEval) {\n"+
  "    try {\n"+
  "        var script = remoteEval.script;\n"+
  "        if (remoteEval.path) {\n"+
  "            script += '//# ' + 'sourceURL=' + remoteEval.path;\n"+
  "        }\n"+
  "        var arg = remoteEval.arg;\n"+
  "        var fn = new _Function(script);\n"+
  "        var result = fn(arg);\n"+
  "        if (!remoteEval.key) {\n"+
  "            if (_console_log)\n"+
  "                _console_log('remoteEval: succeeded while no key was passed: ', result, remoteEval);\n"+
  "            return;\n"+
  "        }\n"+
  "        var remoteResponse = {\n"+
  "            key: remoteEval.key,\n"+
  "            result: result\n"+
  "        };\n"+
  "        postMessageToHost({ remoteResponse: remoteResponse });\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        if (!remoteEval.key) {\n"+
  "            if (_console_log)\n"+
  "                _console_log('remoteEval: error while no key was passed: ', error, remoteEval);\n"+
  "            return;\n"+
  "        }\n"+
  "        var remoteErrorResponse = {\n"+
  "            key: remoteEval.key,\n"+
  "            error: cmpSer.serialize(error)\n"+
  "        };\n"+
  "        postMessageToHost({ remoteErrorResponse: remoteErrorResponse });\n"+
  "    }\n"+
  "}\n"+
  "function install_console_redirect(postMessageToHost, serialize) {\n"+
  "    if (typeof console !== 'undefined' && console) {\n"+
  "        ConsoleRedirect.prototype = console;\n"+
  "    }\n"+
  "    var console_redirect = new ConsoleRedirect();\n"+
  "    console_redirect.log = log_redirect;\n"+
  "    console_redirect.warn = warn_redirect;\n"+
  "    console_redirect.debug = debug_redirect;\n"+
  "    console_redirect.trace = trace_redirect;\n"+
  "    console_redirect.error = error_redirect;\n"+
  "    console = console_redirect;\n"+
  "    function ConsoleRedirect() { }\n"+
  "    function log_redirect() {\n"+
  "        var args = [];\n"+
  "        for (var i = 0; i < arguments.length; i++) {\n"+
  "            args.push(arguments[i]);\n"+
  "        }\n"+
  "        console_level_redirect('log', args);\n"+
  "    }\n"+
  "    function warn_redirect() {\n"+
  "        var args = [];\n"+
  "        for (var i = 0; i < arguments.length; i++) {\n"+
  "            args.push(arguments[i]);\n"+
  "        }\n"+
  "        console_level_redirect('warn', args);\n"+
  "    }\n"+
  "    function debug_redirect() {\n"+
  "        var args = [];\n"+
  "        for (var i = 0; i < arguments.length; i++) {\n"+
  "            args.push(arguments[i]);\n"+
  "        }\n"+
  "        console_level_redirect('debug', args);\n"+
  "    }\n"+
  "    function trace_redirect() {\n"+
  "        var args = [];\n"+
  "        for (var i = 0; i < arguments.length; i++) {\n"+
  "            args.push(arguments[i]);\n"+
  "        }\n"+
  "        console_level_redirect('trace', args);\n"+
  "    }\n"+
  "    function error_redirect() {\n"+
  "        var args = [];\n"+
  "        for (var i = 0; i < arguments.length; i++) {\n"+
  "            args.push(arguments[i]);\n"+
  "        }\n"+
  "        console_level_redirect('error', args);\n"+
  "    }\n"+
  "    function console_level_redirect(level, args) {\n"+
  "        postMessageToHost({ console_echo: { level: level, args: serialize(args) } });\n"+
  "    }\n"+
  "}\n"+
  "/// <reference path=\"../../persistence/src/API.d.ts\"/>\n"+
  "function createComplexSerializer(self) {\n"+
  "    if (!self)\n"+
  "        self = (function () { return this; })();\n"+
  "    var maxDepth = 8;\n"+
  "    var dummy = {};\n"+
  "    var dummyArray = [];\n"+
  "    var dummyError = new Error();\n"+
  "    var dummyFunction = function () { };\n"+
  "    var knownErrorProps = [\n"+
  "        'message', 'name',\n"+
  "        'stack',\n"+
  "        'fileName', 'lineNumber', 'columnNumber',\n"+
  "        'description', 'number', 'stackTraceLimit'\n"+
  "    ];\n"+
  "    var deserializedCtorCache = {};\n"+
  "    var deserializedFnCache = {};\n"+
  "    return {\n"+
  "        serialize: serialize,\n"+
  "        deserialize: deserialize\n"+
  "    };\n"+
  "    function serialize(obj) {\n"+
  "        return serializeDepth(obj, 0);\n"+
  "    }\n"+
  "    function serializeDepth(obj, depth) {\n"+
  "        try {\n"+
  "            switch (typeof obj) {\n"+
  "                case 'function':\n"+
  "                    return serializeFunctionDepth(obj, depth);\n"+
  "                case 'object':\n"+
  "                    if (!obj)\n"+
  "                        return null;\n"+
  "                    if (obj instanceof Error)\n"+
  "                        return serialize_error(obj);\n"+
  "                    if ((Array.isArray && Array.isArray(obj)) || obj instanceof Array)\n"+
  "                        return serializeArrayDepth(obj, depth);\n"+
  "                    return serializeObjectDepth(obj, depth);\n"+
  "                default:\n"+
  "                    return obj;\n"+
  "            }\n"+
  "        }\n"+
  "        catch (error) {\n"+
  "            return { '@unserializable': error.message };\n"+
  "        }\n"+
  "    }\n"+
  "    function serializeFunctionDepth(obj, depth) {\n"+
  "        var result = obj.name ?\n"+
  "            {\n"+
  "                '@function': 'function ' + obj.name + '() { /*...*/ }',\n"+
  "                '@function.name': obj.name\n"+
  "            } :\n"+
  "            {\n"+
  "                '@function': 'function() { /*...*/ }'\n"+
  "            };\n"+
  "        for (var k in obj) {\n"+
  "            if (!(k in dummyFunction)) {\n"+
  "                result[k] = serializeObjectDepth(obj[k], depth + 1);\n"+
  "            }\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function serializeObjectDepth(obj, depth) {\n"+
  "        var srz = {};\n"+
  "        if (obj.constructor && obj.constructor.name && obj.constructor.name) {\n"+
  "            var ctorName = obj.constructor.name;\n"+
  "            if (ctorName !== 'Object')\n"+
  "                srz['@constructor'] = ctorName;\n"+
  "        }\n"+
  "        var propCount = 0;\n"+
  "        for (var k in obj)\n"+
  "            if (!(k in dummy)) {\n"+
  "                if (depth > maxDepth) {\n"+
  "                    propCount++;\n"+
  "                    continue;\n"+
  "                }\n"+
  "                var fail = false;\n"+
  "                try {\n"+
  "                    var kval = obj[k];\n"+
  "                }\n"+
  "                catch (error) {\n"+
  "                    srz[k] = { '@unserializable': error.message };\n"+
  "                    fail = true;\n"+
  "                }\n"+
  "                if (!fail)\n"+
  "                    srz[k] = serializeDepth(obj[k], depth + 1);\n"+
  "            }\n"+
  "        if (depth > maxDepth && propCount) {\n"+
  "            srz['...'] = propCount;\n"+
  "        }\n"+
  "        return srz;\n"+
  "    }\n"+
  "    function serializeArrayDepth(arr, depth) {\n"+
  "        if (depth > maxDepth && arr.length) {\n"+
  "            return ['...'];\n"+
  "        }\n"+
  "        var result = [];\n"+
  "        for (var i = 0; i < arr.length; i++) {\n"+
  "            var srz = serializeDepth(arr[i], depth + 1);\n"+
  "            if (typeof srz === 'undefined')\n"+
  "                continue;\n"+
  "            result[i] = srz;\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function serialize_error(error) {\n"+
  "        var result = {};\n"+
  "        if (typeof error.constructor === 'function') {\n"+
  "            if (error.constructor.name) {\n"+
  "                result['@constructor'] = error.constructor.name;\n"+
  "            }\n"+
  "            else {\n"+
  "                var nameMatch = /function ([^\\(]*)/.exec(error.constructor + '');\n"+
  "                if (nameMatch && nameMatch[1] && nameMatch[1].length < 200) {\n"+
  "                    var ctorName = nameMatch[1].replace(/[\\s]+/g, ''); // additionally eliminate possible spaces\n"+
  "                    result['@constructor'] = ctorName;\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "        for (var i = 0; i < knownErrorProps.length; i++) {\n"+
  "            var p = knownErrorProps[i];\n"+
  "            if (error[p] !== null && typeof error[p] !== 'undefined' && typeof error[p] !== 'function')\n"+
  "                result[p] = error[p];\n"+
  "        }\n"+
  "        for (var p in error) {\n"+
  "            if (p in result)\n"+
  "                continue;\n"+
  "            // this skips those weird upper-case constants from Error\n"+
  "            if (p in dummyError && error[p] === dummyError[p] && p.match(/^[A-Z][A-Z0-9_]+$/))\n"+
  "                continue;\n"+
  "            if (typeof error[p] === 'function')\n"+
  "                continue;\n"+
  "            result[p] = error[p];\n"+
  "        }\n"+
  "        if (error.prototype) {\n"+
  "            for (var p in error.prototype) {\n"+
  "                if (p in result)\n"+
  "                    continue;\n"+
  "                // this skips those weird upper-case constants from Error\n"+
  "                if (p in dummyError && error[p] === dummyError[p] && p.match(/^[A-Z][A-Z0-9_]+$/))\n"+
  "                    continue;\n"+
  "                if (typeof error[p] === 'function')\n"+
  "                    continue;\n"+
  "                result[p] = error[p];\n"+
  "            }\n"+
  "        }\n"+
  "        if (result.stack) {\n"+
  "            var lines = result.stack.split('\\n');\n"+
  "            for (var i = lines.length - 1; i >= 0; i--) {\n"+
  "                if (/\\beval\\b/.test(lines[i])) {\n"+
  "                    if (i)\n"+
  "                        result.stack = lines.slice(0, i).join('\\n');\n"+
  "                    else\n"+
  "                        result.stack = lines.slice(0, i + 1).join('\\n');\n"+
  "                    break;\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function deserialize(obj) {\n"+
  "        if (typeof obj !== 'object' || obj === null)\n"+
  "            return obj;\n"+
  "        if ((Array.isArray && Array.isArray(obj)) || obj instanceof Array)\n"+
  "            return deserializeArray(obj);\n"+
  "        return deserializeObject(obj);\n"+
  "    }\n"+
  "    function deserializeObject(obj) {\n"+
  "        var fnDeclText = obj['@function'];\n"+
  "        var fnDeclName = obj['@function.name'];\n"+
  "        if (fnDeclText) {\n"+
  "            var fnDecl = deserializedFnCache[fnDeclText];\n"+
  "            if (fnDecl)\n"+
  "                return fnDecl;\n"+
  "            try {\n"+
  "                if (fnDeclName)\n"+
  "                    var fnDeclFn = Function('return ' + fnDeclName + ';\\n' + fnDeclText);\n"+
  "                else\n"+
  "                    var fnDeclFn = Function('return ' + fnDeclText);\n"+
  "                fnDecl = fnDeclFn();\n"+
  "                deserializedFnCache[fnDeclText] = fnDecl;\n"+
  "                return fnDecl;\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "            }\n"+
  "        }\n"+
  "        var ctorName = obj['@constructor'];\n"+
  "        var result = createInstance_uncachedCtorName(ctorName);\n"+
  "        for (var k in obj) {\n"+
  "            if (k !== '@constructor' && !(k in dummy))\n"+
  "                result[k] = obj[k];\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function deserializeArray(obj) {\n"+
  "        var result = [];\n"+
  "        for (var k in obj)\n"+
  "            if (!(k in dummyArray)) {\n"+
  "                result[k] = obj[k];\n"+
  "            }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function createInstance_uncachedCtorName(ctorName) {\n"+
  "        var result;\n"+
  "        ctorName = validateCtorName(ctorName);\n"+
  "        if (ctorName) {\n"+
  "            try {\n"+
  "                var getFromGlobal = new Function('return typeof ' + ctorName + '===\"undefined\"?null:' + ctorName);\n"+
  "                var ctor = getFromGlobal();\n"+
  "                if (ctor) {\n"+
  "                    result = new ctor();\n"+
  "                    deserializedCtorCache[ctorName] = ctor;\n"+
  "                }\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "            }\n"+
  "            if (!result) {\n"+
  "                var getCtor = new Function('return ' + ctorName + '; function ' + ctorName + '(){}');\n"+
  "                ctor = getCtor();\n"+
  "                deserializedCtorCache[ctorName] = ctor;\n"+
  "                result = new ctor();\n"+
  "            }\n"+
  "        }\n"+
  "        else {\n"+
  "            result = {};\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function validateCtorName(ctorName) {\n"+
  "        if (ctorName) {\n"+
  "            if (!/^A-Za-z0-9_$/.test(ctorName)) {\n"+
  "                for (var i = 0; i < ctorName.length; i++) {\n"+
  "                    var ctorChar = ctorName.charAt(i);\n"+
  "                    if (/^A-Za-z0-9_$/.test(ctorChar))\n"+
  "                        continue;\n"+
  "                    else if (ctorChar.toLowerCase() !== ctorChar.toUpperCase())\n"+
  "                        continue;\n"+
  "                    // no, this is definitely a wrong character for identifier\n"+
  "                    ctorName = null;\n"+
  "                    break;\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "        return ctorName;\n"+
  "    }\n"+
  "}\n"+
  "function createRequestResponseDispatcher() {\n"+
  "    var diagTimeStart = +new Date();\n"+
  "    var requests = { count: 0 };\n"+
  "    return {\n"+
  "        pushCallback: pushCallback_reqResDispatcher,\n"+
  "        popCallback: popCallback_reqResDispatcher\n"+
  "    };\n"+
  "    function pushCallback_reqResDispatcher(callback) {\n"+
  "        var key = generateKey();\n"+
  "        requests[key] = callback;\n"+
  "        return key;\n"+
  "    }\n"+
  "    function popCallback_reqResDispatcher(key) {\n"+
  "        if (key) {\n"+
  "            var callback = requests[key];\n"+
  "            if (callback)\n"+
  "                delete requests[key];\n"+
  "        }\n"+
  "        return callback;\n"+
  "    }\n"+
  "    function generateKey() {\n"+
  "        var key = (requests.count++).toString();\n"+
  "        // generate a bit of timestamp for the benefit of easier debugging\n"+
  "        if (Date.now)\n"+
  "            key += '-' + (Date.now() - diagTimeStart) + 'ms';\n"+
  "        else\n"+
  "            key += '-' + (+new Date() - diagTimeStart) + 'ms';\n"+
  "        return key;\n"+
  "    }\n"+
  "}\n"+
  "function createPushMessageDispatcher() {\n"+
  "    var registeredPushMessageCallbacks = [];\n"+
  "    var registeredPushMessageCallbacks_length = 0;\n"+
  "    return {\n"+
  "        handlePushMessage: handlePushMessage_pushMessageDispatcher,\n"+
  "        onPushMessage: onPushMessage_pushMessageDispatcher\n"+
  "    };\n"+
  "    function handlePushMessage_pushMessageDispatcher(pushMessage) {\n"+
  "        for (var i = 0; i < registeredPushMessageCallbacks_length; i++) {\n"+
  "            var cb = registeredPushMessageCallbacks[i];\n"+
  "            if (cb)\n"+
  "                cb(pushMessage);\n"+
  "        }\n"+
  "    }\n"+
  "    function onPushMessage_pushMessageDispatcher(callback) {\n"+
  "        var index = registeredPushMessageCallbacks_length;\n"+
  "        registeredPushMessageCallbacks.push(callback);\n"+
  "        registeredPushMessageCallbacks_length++;\n"+
  "        return unregister_pushMessageCallback;\n"+
  "        function unregister_pushMessageCallback() {\n"+
  "            if (index < 0)\n"+
  "                return;\n"+
  "            delete registeredPushMessageCallbacks[index];\n"+
  "            index = -1;\n"+
  "            // adjust the tail (removal of callbacks may run out of order)\n"+
  "            var newLength = registeredPushMessageCallbacks_length;\n"+
  "            while (!registeredPushMessageCallbacks[newLength] && newLength >= 0) {\n"+
  "                newLength--;\n"+
  "            }\n"+
  "            if (newLength !== registeredPushMessageCallbacks_length)\n"+
  "                registeredPushMessageCallbacks_length = newLength;\n"+
  "        }\n"+
  "    }\n"+
  "}\n"+
  "function driveApplyUpdates(tmDrive, msg) {\n"+
  "    tmDrive.timestamp = Math.max(tmDrive.timestamp, msg.timestamp);\n"+
  "    for (var i = 0; i < msg.driveUpdates.length; i++) {\n"+
  "        var up = msg.driveUpdates[i];\n"+
  "        if (up.deleteFile) {\n"+
  "            tmDrive.write(up.deleteFile, null);\n"+
  "        }\n"+
  "        else if (up.updateFile) {\n"+
  "            tmDrive.write(up.updateFile, up.content);\n"+
  "        }\n"+
  "    }\n"+
  "}\n"+
  "/// <reference path=\"ref.ts\"/>\n"+
  "/// <reference path=\"createComplexSerializer.ts\"/>\n"+
  "/// <reference path=\"createRequestResponseDispatcher.ts\"/>\n"+
  "/// <reference path=\"createPushMessageDispatcher.ts\"/>\n"+
  "/// <reference path=\"driveApplyUpdates.ts\"/>\n"+
  "/// <reference path=\"../shared/all.ts\"/>\n"+
  "function requestAsyncMode(fs_reason) {\n"+
  "    self_onmessage = expect_driveSnapshot_thenStart_ASYNC_CHANNEL;\n"+
  "    postMessageToHost({ requestInitAsync: fs_reason });\n"+
  "    function expect_driveSnapshot_thenStart_ASYNC_CHANNEL(e) {\n"+
  "        if (e.data.driveSnapshot) {\n"+
  "            RUN_ASYNC_CHANNEL(e.data.driveSnapshot);\n"+
  "        }\n"+
  "        else {\n"+
  "            report_unexpectedMessage_whenExpecting_driveSnapshot(e);\n"+
  "        }\n"+
  "    }\n"+
  "    function report_unexpectedMessage_whenExpecting_driveSnapshot(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown expecting driveSnapshot for ASYNC_CHANNEL: ', e.data, e);\n"+
  "    }\n"+
  "}\n"+
  "var self_onmessage;\n"+
  "function addMessageEventListener() {\n"+
  "    _addEventListener('message', function (e) {\n"+
  "        if (!self_onmessage) {\n"+
  "            if (_console_log)\n"+
  "                _console_log('onmessage: self_onmessage is null: ', e.data, e); // but let it throw too\n"+
  "        }\n"+
  "        self_onmessage(e);\n"+
  "    }, true);\n"+
  "}\n"+
  "function trySetupSyncMode(fs) {\n"+
  "    var cookieFilename = generateCookieFilename();\n"+
  "    pollForFile_or_expectMessage_requestInitSync_reject({\n"+
  "        file: cookieFilename,\n"+
  "        when_OK: function (msg) {\n"+
  "            postMessageToHost({ requestInitSync_completed: 'done' });\n"+
  "            return RUN_SYNCFS_AIDED_CHANNEL(fs, msg);\n"+
  "        },\n"+
  "        when_requestInitSync_reject: function (driveSnapshot) {\n"+
  "            return RUN_ASYNC_CHANNEL(driveSnapshot);\n"+
  "        },\n"+
  "        when_timeout: function () {\n"+
  "            return requestAsyncMode('wait for cookie file timed out: ' + cookieFilename);\n"+
  "        }\n"+
  "    });\n"+
  "    function generateCookieFilename() {\n"+
  "        var fn = 'T' + (+new Date()) + 'R' + Math.random().toString().replace(/\\./g, '');\n"+
  "        return fn;\n"+
  "    }\n"+
  "    function pollForFile_or_expectMessage_requestInitSync_reject(opts) {\n"+
  "        var cookieFilename = opts.file;\n"+
  "        var timeoutAfter = +new Date() + 1000 * 88888; // TODO: DEBUGDEBUG\n"+
  "        self_onmessage = requestInitSync_onmessage;\n"+
  "        var pollFS = _setInterval(setInterval_pollFS, 5);\n"+
  "        postMessageToHost({ requestInitSync: opts.file });\n"+
  "        function setInterval_pollFS() {\n"+
  "            var response = getFileSync(fs, cookieFilename);\n"+
  "            if (response) {\n"+
  "                var response_msg = _JSON_parse(response);\n"+
  "                _clearInterval(pollFS);\n"+
  "                opts.when_OK(response_msg);\n"+
  "                return;\n"+
  "            }\n"+
  "            var now = Date.now ? Date.now() : +new Date();\n"+
  "            if (now > timeoutAfter) {\n"+
  "                _clearInterval(pollFS);\n"+
  "                opts.when_timeout();\n"+
  "                return;\n"+
  "            }\n"+
  "        }\n"+
  "        function requestInitSync_onmessage(e) {\n"+
  "            if (e.data.requestInitSync_reject) {\n"+
  "                _clearInterval(pollFS);\n"+
  "                self_onmessage = null;\n"+
  "                var driveSnapshot = e.data.requestInitSync_reject;\n"+
  "                opts.when_requestInitSync_reject(driveSnapshot);\n"+
  "            }\n"+
  "            else {\n"+
  "                reportUnexpectedMessage_whenPolling_syncFS(e);\n"+
  "            }\n"+
  "        }\n"+
  "    }\n"+
  "    function reportUnexpectedMessage_whenPolling_syncFS(e) {\n"+
  "        if (_console_log)\n"+
  "            _console_log('onmessage: unknown when polling for SYNCFS_AIDED_CHANNEL: ', e.data, e);\n"+
  "    }\n"+
  "}\n"+
  "function getFileSync(fs, fname) {\n"+
  "    try {\n"+
  "        /*\n"+
  "        var found = true;\n"+
  "        var entries = fs.root.createReader().readEntries();\n"+
  "        for (var i = 0; i < entries.length; i++) {\n"+
  "          if (entries[i].name===fname) {\n"+
  "            found = true;\n"+
  "            break;\n"+
  "          }\n"+
  "        }\n"+
  "        if (!found) return;\n"+
  "        */\n"+
  "        var fentry = fs.root.getFile('/isolation-syncfs-aided--' + fname, { create: false });\n"+
  "        var file = fentry.file();\n"+
  "        var reader = new _FileReaderSync();\n"+
  "        var text = reader.readAsText(file);\n"+
  "        if (!text) {\n"+
  "            return null;\n"+
  "        }\n"+
  "        try {\n"+
  "            // MDN and W3C are ambiguous?\n"+
  "            if (typeof fentry.remove === 'function')\n"+
  "                fentry.remove();\n"+
  "            else if (typeof file.remove === 'function')\n"+
  "                file.remove();\n"+
  "        }\n"+
  "        catch (error) {\n"+
  "        }\n"+
  "        return text;\n"+
  "    }\n"+
  "    catch (err) {\n"+
  "    }\n"+
  "}\n";
        if (doNOTrun) {
            worker_body = worker_body + '\n //# ' + 'sourceURL=/isolation_iframe_body.js';
        }
        else {
            worker_body = '(function() {    ' + worker_body + '\n\n\n' + 'agentFunction_webWorker(); })() //# ' + 'sourceURL=/isolation_worker_body.js';
        }
        return worker_body;
    }
    function getApiScript() {
        var script = "var __extends = (this && this.__extends) || function (d, b) {\n"+
  "    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n"+
  "    function __() { this.constructor = d; }\n"+
  "    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n"+
  "};\n"+
  "var Buffer;\n"+
  "Buffer = (function () {\n"+
  "    return Buffer;\n"+
  "    function Buffer(data, encoding, offset) {\n"+
  "        var buf;\n"+
  "        if (typeof data === 'number') {\n"+
  "            buf = new Uint8Array(data);\n"+
  "        }\n"+
  "        else if (typeof data === 'string') {\n"+
  "            if (encoding == 'base64') {\n"+
  "                var len = decodeBase64(data, null, 0);\n"+
  "                buf = new Uint8Array(len);\n"+
  "                decodeBase64(data, buf, 0);\n"+
  "            }\n"+
  "            else if (encoding == 'utf8' || !encoding) {\n"+
  "                var len = encodeUTF8(data, null, 0);\n"+
  "                buf = new Uint8Array(len);\n"+
  "                encodeUTF8(data, buf, 0);\n"+
  "            }\n"+
  "        }\n"+
  "        else if (typeof data === 'object' && data && typeof data.length === 'number') {\n"+
  "            buf = new Uint8Array(data.length);\n"+
  "            for (var i = 0; i < data.length; i++) {\n"+
  "                buf[i] = data[i];\n"+
  "            }\n"+
  "        }\n"+
  "        else {\n"+
  "            throw new Error('Buffer only supports initialization from length, array or string at the moment.');\n"+
  "        }\n"+
  "        buf.toString = toString;\n"+
  "        // TODO: add Buffer methods\n"+
  "        return buf;\n"+
  "    }\n"+
  "    function encodeUTF8(text, buf, start) {\n"+
  "        var pos = start | 0;\n"+
  "        for (var i = 0; i < text.length; i++) {\n"+
  "            var ch = text.charCodeAt(i);\n"+
  "            if (ch < 0x80) {\n"+
  "                if (buf)\n"+
  "                    buf[pos] = ch;\n"+
  "                pos++;\n"+
  "            }\n"+
  "            else if (ch < 0x800) {\n"+
  "                if (buf) {\n"+
  "                    buf[pos] = 0xC0 | ((ch >> 6) & 0xFF);\n"+
  "                    buf[pos + 1] = 0x80 | (ch & 0xFF);\n"+
  "                }\n"+
  "                pos += 2;\n"+
  "            }\n"+
  "            else {\n"+
  "                // TODO: treat Unicode surrogate pair stuff\n"+
  "                if (buf) {\n"+
  "                    buf[pos] = 0xE0 | ((ch >> 12) & 0xFF);\n"+
  "                    buf[pos + 1] = 0x80 | ((ch >> 6) & 0xFF);\n"+
  "                    buf[pos + 2] = 0x80 | (ch & 0xFF);\n"+
  "                }\n"+
  "                pos += 3;\n"+
  "            }\n"+
  "        }\n"+
  "        return pos;\n"+
  "    }\n"+
  "    function decodeUTF8(data) {\n"+
  "        var result = '';\n"+
  "        for (var i = 0; i < data.length; i++) {\n"+
  "            var b = data[i];\n"+
  "            var ch;\n"+
  "            if (!(b & 0x80)) {\n"+
  "                ch = b;\n"+
  "            }\n"+
  "            else {\n"+
  "                if ((b & 0xE0) === 0xC0) {\n"+
  "                    ch = (b << 6) | (data[i + 1] & 0xC0);\n"+
  "                    i++;\n"+
  "                }\n"+
  "                else {\n"+
  "                    ch = (b << 12) | ((data[i + 1] & 0xC0) << 6) | (data[i + 2] & 0xC0);\n"+
  "                    i += 2;\n"+
  "                }\n"+
  "            }\n"+
  "            result += String.fromCharCode(ch);\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function b64Code(ch) {\n"+
  "        if (ch >= 65 /*A*/ && ch <= 90 /*Z*/)\n"+
  "            return ch - 65;\n"+
  "        if (ch >= 97 /*a*/ && ch <= 122 /*z*/)\n"+
  "            return ch - 97 + 26;\n"+
  "        if (ch >= 48 /*0*/ && ch <= 57 /*9*/)\n"+
  "            return ch - 48 + 26 + 26;\n"+
  "        if (ch == 43 /*+*/ || ch == 45 /*-*/)\n"+
  "            return 62;\n"+
  "        if (ch == 47 /*/*/ || ch == 95 /*_*/)\n"+
  "            return 63;\n"+
  "        if (ch == 61 /*=*/)\n"+
  "            return -1;\n"+
  "        else if (ch == 32 || ch == 9 || ch == 13 || ch == 10 || /\\s/.test(String.fromCharCode(ch)))\n"+
  "            return -2; // whitespace\n"+
  "        else\n"+
  "            return -3; // invalid\n"+
  "    }\n"+
  "    function decodeBase64(b64, buf, start) {\n"+
  "        var phase = 0;\n"+
  "        var accum = 0;\n"+
  "        var pos = start | 0;\n"+
  "        for (var i = 0; i < b64.length; i++) {\n"+
  "            var ch = b64.charCodeAt(i);\n"+
  "            var co = b64Code(ch);\n"+
  "            if (phase >= 0) {\n"+
  "                if (co >= 0) {\n"+
  "                    phase = (phase + 1) % 4;\n"+
  "                    accum = (accum << 6) | co;\n"+
  "                    if (!phase) {\n"+
  "                        if (buf) {\n"+
  "                            buf[pos] = (accum >> 16) & 0xFF;\n"+
  "                            buf[pos + 1] = (accum >> 8) & 0xFF;\n"+
  "                            buf[pos + 2] = accum & 0xFF;\n"+
  "                        }\n"+
  "                        pos += 3;\n"+
  "                        accum = 0;\n"+
  "                    }\n"+
  "                }\n"+
  "                else if (co == -1)\n"+
  "                    phase = -1; // TODO: enforce block size before setting\n"+
  "                else if (co == -3)\n"+
  "                    throw new Error('The string to be decoded is not correctly encoded.');\n"+
  "            }\n"+
  "            else if (phase == -1) {\n"+
  "                if (co == -1)\n"+
  "                    phase = -2;\n"+
  "                else if (co != -2)\n"+
  "                    throw new Error('The string to be decoded is not correctly encoded.');\n"+
  "            }\n"+
  "            else if (phase == -2) {\n"+
  "                if (co != -2)\n"+
  "                    throw new Error('The string to be decoded is not correctly encoded.');\n"+
  "            }\n"+
  "        }\n"+
  "        if (phase == -1) {\n"+
  "            if (buf) {\n"+
  "                buf[pos] = (accum >> 10) & 0xFF;\n"+
  "                buf[pos + 1] = (accum >> 2) & 0xFF;\n"+
  "            }\n"+
  "            pos += 2;\n"+
  "        }\n"+
  "        else if (phase == -2) {\n"+
  "            if (buf) {\n"+
  "                buf[pos] = (accum >> 4) & 0xFF;\n"+
  "            }\n"+
  "            pos++;\n"+
  "        }\n"+
  "        else if (phase)\n"+
  "            throw new Error('The string to be decoded is not correctly encoded.');\n"+
  "        return pos;\n"+
  "    }\n"+
  "    function toString(encoding) {\n"+
  "        if (!encoding || encoding === 'utf8') {\n"+
  "            return decodeUTF8(this);\n"+
  "        }\n"+
  "        throw new Error('Parameters are too weird.');\n"+
  "    }\n"+
  "})();\n"+
  "function initApiContext(options) {\n"+
  "    var _this = this;\n"+
  "    var _connection_to_parent = connection_to_parent;\n"+
  "    var _setTimeout = setTimeout;\n"+
  "    var _setInterval = setInterval;\n"+
  "    var _clearTimeout = clearTimeout;\n"+
  "    var _clearInterval = clearInterval;\n"+
  "    var _eval = eval;\n"+
  "    var _self = typeof self !== 'undefined' ? self : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : (function () { return this; })();\n"+
  "    var _nativeObjects = getNativeObjects();\n"+
  "    var _waitFor = 0;\n"+
  "    var _fs_onfilesChanged;\n"+
  "    var _moduleCache = {};\n"+
  "    options.dispose = dispose;\n"+
  "    options.keepAlive = keepAlive;\n"+
  "    options.runGlobal = runGlobal;\n"+
  "    if (!options.global)\n"+
  "        options.global = { global: _self };\n"+
  "    if (!options.coreModules)\n"+
  "        options.coreModules = {\n"+
  "            fs: null,\n"+
  "            os: null,\n"+
  "            path: null,\n"+
  "            events: null,\n"+
  "            http: null,\n"+
  "            child_process: null\n"+
  "        };\n"+
  "    if (!options.scriptPath)\n"+
  "        options.scriptPath = '/repl.js';\n"+
  "    if (!options.argv)\n"+
  "        options.argv = ['/node', options.scriptPath];\n"+
  "    if (!options.cwd)\n"+
  "        options.cwd = dirname(options.scriptPath);\n"+
  "    var processExtra = {\n"+
  "        exitCode: null,\n"+
  "        shutdown: process_shutdown\n"+
  "    };\n"+
  "    options.global.process = options.process = createProcess(options.coreModules, options, processExtra);\n"+
  "    options.global.module = options.mainModule = createModule({}, 'repl' /*id*/, null /*filename*/, null /*parent*/, require);\n"+
  "    options.requireModule = requireModule;\n"+
  "    function require(moduleName) {\n"+
  "        if (options.finished)\n"+
  "            throw new Error('Process is terminated'); // TODO: check if this is intended behaviour\n"+
  "        return options.requireModule(moduleName, dirname(options.scriptPath), null);\n"+
  "    }\n"+
  "    options.global.require = (function (moduleName) { return require(moduleName); });\n"+
  "    options.global.require.resolve = function (id) { return options.resolve(id, options.cwd); };\n"+
  "    options.global.require.main = options.mainModule;\n"+
  "    options.global.__filename = options.scriptPath;\n"+
  "    options.global.__dirname = dirname(options.scriptPath);\n"+
  "    options.resolve = resolve;\n"+
  "    //options.global.console = this.console;\n"+
  "    var fsTuple = createFS(options.drive, options.coreModules);\n"+
  "    var _fs_onfilesChanged = fsTuple.filesChanged;\n"+
  "    options.coreModules.fs = fsTuple.fs;\n"+
  "    options.coreModules.os = createOS(options.global);\n"+
  "    options.coreModules.path = createPath(options.process);\n"+
  "    options.coreModules.http = createHTTP();\n"+
  "    options.coreModules.events = createEvents();\n"+
  "    options.coreModules.child_process = createChildProcess(_connection_to_parent, {\n"+
  "        fs: options.coreModules.fs,\n"+
  "        path: options.coreModules.path,\n"+
  "        process: options.global.process\n"+
  "    });\n"+
  "    options.process.exit = function (code) {\n"+
  "        options.exitCode = code || 0;\n"+
  "        dispose();\n"+
  "    };\n"+
  "    options.process.abort = function () {\n"+
  "        dispose();\n"+
  "    };\n"+
  "    var timeouts = [];\n"+
  "    options.global.setTimeout = function (fun, time) {\n"+
  "        var args = [];\n"+
  "        for (var _i = 2; _i < arguments.length; _i++) {\n"+
  "            args[_i - 2] = arguments[_i];\n"+
  "        }\n"+
  "        if (options.finished)\n"+
  "            return 0;\n"+
  "        var wait = keepAlive();\n"+
  "        var complete = function () {\n"+
  "            delete timeouts[result];\n"+
  "            wait();\n"+
  "            fun();\n"+
  "        };\n"+
  "        var passArgs = [];\n"+
  "        passArgs.push(complete);\n"+
  "        passArgs.push(time);\n"+
  "        for (var i = 0; i < args.length; i++) {\n"+
  "            passArgs.push(args[i]);\n"+
  "        }\n"+
  "        var result = _setTimeout.apply(_self, passArgs);\n"+
  "        timeouts[result] = wait;\n"+
  "        return result;\n"+
  "    };\n"+
  "    options.global.clearTimeout = function (tout) {\n"+
  "        var wait = timeouts[tout];\n"+
  "        if (wait)\n"+
  "            wait();\n"+
  "        delete timeouts[tout];\n"+
  "        _clearTimeout(tout);\n"+
  "    };\n"+
  "    var intervals = [];\n"+
  "    options.global.setInterval = function (fun, time) {\n"+
  "        var args = [];\n"+
  "        for (var _i = 2; _i < arguments.length; _i++) {\n"+
  "            args[_i - 2] = arguments[_i];\n"+
  "        }\n"+
  "        if (options.finished)\n"+
  "            return 0;\n"+
  "        var wait = keepAlive();\n"+
  "        var passArgs = [];\n"+
  "        passArgs.push(fun);\n"+
  "        passArgs.push(time);\n"+
  "        for (var i = 0; i < args.length; i++) {\n"+
  "            passArgs.push(args[i]);\n"+
  "        }\n"+
  "        var result = _setInterval.apply(_self, passArgs);\n"+
  "        intervals[result] = wait;\n"+
  "        return result;\n"+
  "    };\n"+
  "    options.global.clearInterval = function (intv) {\n"+
  "        var wait = intervals[intv];\n"+
  "        if (wait)\n"+
  "            wait();\n"+
  "        delete intervals[intv];\n"+
  "        _clearInterval(intv);\n"+
  "    };\n"+
  "    options.process.nextTick = function (fun) {\n"+
  "        if (options.finished)\n"+
  "            return;\n"+
  "        var wait = _this.keepAlive();\n"+
  "        _setTimeout(function () {\n"+
  "            wait();\n"+
  "            fun();\n"+
  "        }, 1);\n"+
  "    };\n"+
  "    var _keepAlive_releases = [];\n"+
  "    _connection_to_parent.onPushMessage(noapi_context_onPushMessage);\n"+
  "    function process_shutdown() {\n"+
  "        dispose();\n"+
  "    }\n"+
  "    function dispose() {\n"+
  "        if (options.finished)\n"+
  "            return;\n"+
  "        options.finished = true;\n"+
  "        if (typeof options.ondispose === 'function')\n"+
  "            options.ondispose();\n"+
  "        _connection_to_parent.invokeAsync({ noapi_ondispose: { exitCode: options.exitCode } });\n"+
  "    }\n"+
  "    function keepAlive() {\n"+
  "        if (options.finished)\n"+
  "            return function () { };\n"+
  "        _waitFor++;\n"+
  "        return function () {\n"+
  "            _waitFor--;\n"+
  "            if (_waitFor <= 0) {\n"+
  "                _setTimeout(function () {\n"+
  "                    if (_waitFor <= 0)\n"+
  "                        dispose();\n"+
  "                }, 150);\n"+
  "            }\n"+
  "        };\n"+
  "    }\n"+
  "    function resolve(id, modulePath) {\n"+
  "        var tryPath = id.charAt(0) === '/' ? options.coreModules.path.resolve(id) : options.coreModules.path.resolve(modulePath, id);\n"+
  "        if (id.charAt(0) === '/' || id.charAt(0) === '.') {\n"+
  "            if (!options.coreModules.fs.existsSync(tryPath))\n"+
  "                return null;\n"+
  "            else if (options.coreModules.fs.statSync(tryPath).isFile())\n"+
  "                return tryPath;\n"+
  "            else\n"+
  "                return _tryResolveModuleFromDir(tryPath);\n"+
  "        }\n"+
  "        else {\n"+
  "            var firstSlash = id.indexOf('/', 1); // definitely not pick on leading character\n"+
  "            var moduleDir = firstSlash >= 0 ? id.slice(0, firstSlash) : id;\n"+
  "            var moduleFileExact = firstSlash >= 0 ? id.slice(firstSlash + 1) : null;\n"+
  "            tryPath = options.coreModules.path.resolve(modulePath);\n"+
  "            while (true) {\n"+
  "                var resolveDir = options.coreModules.path.join(tryPath, 'node_modules', moduleDir);\n"+
  "                if (options.coreModules.fs.existsSync(resolveDir)) {\n"+
  "                    if (moduleFileExact) {\n"+
  "                        var resolvedFile = options.coreModules.path.join(resolveDir, moduleFileExact);\n"+
  "                        if (options.coreModules.fs.existsSync(resolvedFile) && options.coreModules.fs.statSync(resolvedFile).isFile())\n"+
  "                            return resolvedFile;\n"+
  "                    }\n"+
  "                    else {\n"+
  "                        var resolved = _tryResolveModuleFromDir(resolveDir);\n"+
  "                        if (resolved)\n"+
  "                            return resolved;\n"+
  "                    }\n"+
  "                }\n"+
  "                if (!tryPath || tryPath === '/')\n"+
  "                    break;\n"+
  "                var newTryPath = options.coreModules.path.dirname(tryPath);\n"+
  "                if (newTryPath === tryPath || !newTryPath)\n"+
  "                    break;\n"+
  "                tryPath = newTryPath;\n"+
  "            }\n"+
  "        }\n"+
  "    }\n"+
  "    function requireModule(moduleName, parentModulePath, parentModule) {\n"+
  "        if (options.coreModules.hasOwnProperty(moduleName))\n"+
  "            return options.coreModules[moduleName];\n"+
  "        var resolvedPath = resolve(moduleName, parentModulePath);\n"+
  "        if (resolvedPath) {\n"+
  "            var existingLoaded = _moduleCache[resolvedPath];\n"+
  "            if (resolvedPath in _moduleCache)\n"+
  "                return existingLoaded;\n"+
  "            existingLoaded = {};\n"+
  "            _moduleCache[resolvedPath] = existingLoaded;\n"+
  "            var content = options.coreModules.fs.readFileSync(resolvedPath);\n"+
  "            if (content) {\n"+
  "                var moduleDir = dirname(resolvedPath);\n"+
  "                var loadedModule = createModule(existingLoaded, moduleName, resolvedPath, parentModule, function (moduleName) { return requireModule(moduleName, moduleDir, loadedModule); });\n"+
  "                var moduleScope = (function () {\n"+
  "                    var ModuleContext = function () { };\n"+
  "                    ModuleContext.prototype = options.global;\n"+
  "                    var moduleScope = new ModuleContext();\n"+
  "                    moduleScope.global = moduleScope;\n"+
  "                    moduleScope.require = function (moduleName) { return loadedModule.require(moduleName); };\n"+
  "                    moduleScope.require.resolve = function (id) { return resolve(id, moduleDir); };\n"+
  "                    moduleScope.require.main = options.mainModule;\n"+
  "                    moduleScope.exports = loadedModule.exports;\n"+
  "                    moduleScope.global.__filename = resolvedPath;\n"+
  "                    moduleScope.global.__dirname = dirname(resolvedPath);\n"+
  "                    if (options.console) {\n"+
  "                        options.global.console = options.console;\n"+
  "                        moduleScope.console = options.console;\n"+
  "                    }\n"+
  "                    moduleScope.module = loadedModule;\n"+
  "                    return moduleScope;\n"+
  "                })();\n"+
  "                var contentScript = String(content);\n"+
  "                if (contentScript.charAt(0) === '#') {\n"+
  "                    var posLineEnd = contentScript.indexOf('\\n');\n"+
  "                    if (posLineEnd > 0) {\n"+
  "                        var firstLine = contentScript.slice(0, posLineEnd);\n"+
  "                        if (firstLine.length > 2)\n"+
  "                            firstLine = '//' + firstLine.slice(0, firstLine.length - 2);\n"+
  "                        contentScript = firstLine + contentScript.slice(posLineEnd);\n"+
  "                    }\n"+
  "                }\n"+
  "                runScope(contentScript, resolvedPath, moduleScope, _self, _eval);\n"+
  "                if (loadedModule.exports !== existingLoaded && loadedModule.exports) {\n"+
  "                    for (var k in loadedModule.exports)\n"+
  "                        if (typeof loadedModule.exports.hasOwnProperty === 'function' && loadedModule.exports.hasOwnProperty(k)) {\n"+
  "                            existingLoaded[k] = loadedModule.exports[k];\n"+
  "                        }\n"+
  "                }\n"+
  "                _moduleCache[resolvedPath] = loadedModule.exports;\n"+
  "                return loadedModule.exports;\n"+
  "            }\n"+
  "        }\n"+
  "        throw new Error('Cannot find module \\'' + moduleName + '\\'');\n"+
  "    }\n"+
  "    function _tryResolveModuleFromDir(resolveDir) {\n"+
  "        var packageFile = options.coreModules.path.join(resolveDir, 'package.json');\n"+
  "        if (options.coreModules.fs.existsSync(packageFile) && options.coreModules.fs.statSync(packageFile).isFile()) {\n"+
  "            var packageJson = options.coreModules.fs.readFileSync(packageFile) + '';\n"+
  "            try {\n"+
  "                var packageObj = JSON.parse(packageJson);\n"+
  "                var mainFile = options.coreModules.path.resolve(resolveDir, packageObj.main);\n"+
  "                if (options.coreModules.fs.existsSync(mainFile) && options.coreModules.fs.statSync(mainFile).isFile())\n"+
  "                    return mainFile;\n"+
  "                else\n"+
  "                    return null;\n"+
  "            }\n"+
  "            catch (packageJsonError) { }\n"+
  "        }\n"+
  "        var indexFile = options.coreModules.path.join(resolveDir, 'index.js');\n"+
  "        if (options.coreModules.fs.existsSync(indexFile) && options.coreModules.fs.statSync(indexFile).isFile())\n"+
  "            return indexFile;\n"+
  "        else\n"+
  "            return null;\n"+
  "    }\n"+
  "    function getNativeObjects() {\n"+
  "        return {\n"+
  "            setTimeout: 1, setInterval: 1, clearTimeout: 1, clearInterval: 1,\n"+
  "            eval: 1,\n"+
  "            console: 1,\n"+
  "            undefined: 1,\n"+
  "            Object: 1, Array: 1, Date: 1, Function: 1, String: 1, Boolean: 1, Number: 1,\n"+
  "            Infinity: 1, NaN: 1, isNaN: 1, isFinite: 1, parseInt: 1, parseFloat: 1,\n"+
  "            escape: 1, unescape: 1,\n"+
  "            Int32Array: 1, Int8Array: 1, Int16Array: 1,\n"+
  "            Uint32Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Uint16Array: 1,\n"+
  "            Float32Array: 1, Float64Array: 1, ArrayBuffer: 1, DataView: 1,\n"+
  "            Math: 1, JSON: 1, RegExp: 1,\n"+
  "            Error: 1, SyntaxError: 1, EvalError: 1, RangeError: 1, ReferenceError: 1,\n"+
  "            toString: 1, toJSON: 1, toValue: 1,\n"+
  "            Map: 1, Promise: 1, Symbol: 1\n"+
  "        };\n"+
  "    }\n"+
  "    function runScope(code, path, scope, globalScope, eval) {\n"+
  "        var argNames = [];\n"+
  "        var argValues = [];\n"+
  "        for (var k in scope)\n"+
  "            if (scope.hasOwnProperty(k)) {\n"+
  "                argNames.push(k);\n"+
  "                argValues.push(scope[k]);\n"+
  "            }\n"+
  "        var obscureNameCache = {};\n"+
  "        for (var k in globalScope) {\n"+
  "            try {\n"+
  "                if (typeof globalScope[k] === 'undefined')\n"+
  "                    continue;\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "            }\n"+
  "            if (k in scope || _nativeObjects[k] || obscureNameCache[k])\n"+
  "                continue;\n"+
  "            argNames.push(k);\n"+
  "            obscureNameCache[k] = true;\n"+
  "        }\n"+
  "        if (typeof Object.getOwnPropertyNames === 'function') {\n"+
  "            var allProps = Object.getOwnPropertyNames(globalScope);\n"+
  "            for (var i = 0; i < allProps.length; i++) {\n"+
  "                var k = allProps[i];\n"+
  "                try {\n"+
  "                    if (typeof globalScope[k] === 'undefined')\n"+
  "                        continue;\n"+
  "                }\n"+
  "                catch (error) {\n"+
  "                }\n"+
  "                if (k in scope || _nativeObjects[k] || obscureNameCache[k])\n"+
  "                    continue;\n"+
  "                argNames.push(k);\n"+
  "                obscureNameCache[k] = true;\n"+
  "            }\n"+
  "        }\n"+
  "        var extendedCode = '(function() { return function (' + argNames.join(',') + '){    ' + code + '\\n} })() //# ' + 'sourceURL=' + path;\n"+
  "        var fn = eval(extendedCode);\n"+
  "        return fn.apply(this, argValues);\n"+
  "    }\n"+
  "    var globalScopeSanitized;\n"+
  "    function runGlobal(script, path) {\n"+
  "        if (!globalScopeSanitized) {\n"+
  "            globalScopeSanitized = true;\n"+
  "            sanitizeGlobalScope(_self);\n"+
  "        }\n"+
  "        if (path) {\n"+
  "            options.scriptPath = path;\n"+
  "            options.global.__filename = path;\n"+
  "            options.global.__dirname = dirname(path);\n"+
  "        }\n"+
  "        // impose global\n"+
  "        for (var k in options.global)\n"+
  "            if (options.global.hasOwnProperty(k)) {\n"+
  "                try {\n"+
  "                    _self[k] = options.global[k];\n"+
  "                }\n"+
  "                catch (error) {\n"+
  "                }\n"+
  "            }\n"+
  "        var scriptWrapped = path ?\n"+
  "            script + '\\n//# ' + 'sourceURL=' + path :\n"+
  "            script;\n"+
  "        return (0, _eval)(scriptWrapped);\n"+
  "    }\n"+
  "    function sanitizeGlobalScope(globalScope) {\n"+
  "        var obscureNames = [];\n"+
  "        var obscureNameCache = {};\n"+
  "        for (var k in globalScope) {\n"+
  "            if (k === 'caches')\n"+
  "                continue;\n"+
  "            try {\n"+
  "                if (typeof globalScope[k] === 'undefined')\n"+
  "                    continue;\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "            }\n"+
  "            if (k in obscureNameCache || _nativeObjects[k])\n"+
  "                continue;\n"+
  "            obscureNames.push(k);\n"+
  "            obscureNameCache[k] = true;\n"+
  "        }\n"+
  "        if (typeof Object.getOwnPropertyNames === 'function') {\n"+
  "            var allProps = Object.getOwnPropertyNames(globalScope);\n"+
  "            for (var i = 0; i < allProps.length; i++) {\n"+
  "                var k = allProps[i];\n"+
  "                if (k === 'caches')\n"+
  "                    continue;\n"+
  "                try {\n"+
  "                    if (typeof globalScope[k] === 'undefined')\n"+
  "                        continue;\n"+
  "                }\n"+
  "                catch (error) {\n"+
  "                }\n"+
  "                if (k in obscureNameCache || _nativeObjects[k])\n"+
  "                    continue;\n"+
  "                obscureNames.push(k);\n"+
  "                obscureNameCache[k] = true;\n"+
  "            }\n"+
  "        }\n"+
  "        for (var i = 0; i < obscureNames.length; i++) {\n"+
  "            var _undef;\n"+
  "            var k = obscureNames[i];\n"+
  "            if (k === 'caches')\n"+
  "                continue; // it tends to fail, let it be\n"+
  "            try {\n"+
  "                globalScope[k] = _undef;\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "            }\n"+
  "            try {\n"+
  "                delete globalScope[k];\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "            }\n"+
  "        }\n"+
  "    }\n"+
  "    function noapi_context_onPushMessage(msg) {\n"+
  "        if (msg.noapi_runGlobal) {\n"+
  "            handleRunGlobal(msg.noapi_runGlobal);\n"+
  "        }\n"+
  "        else if (msg.noapi_keepAlive_addRef) {\n"+
  "            handleKeepAliveAddRef(msg.noapi_keepAlive_addRef);\n"+
  "        }\n"+
  "        else if (msg.noapi_keepAlive_release) {\n"+
  "            handleKeepAliveRelease(msg.noapi_keepAlive_release);\n"+
  "        }\n"+
  "    }\n"+
  "    function handleRunGlobal(noapi_runGlobal) {\n"+
  "        try {\n"+
  "            var keepa = keepAlive();\n"+
  "            var result = runGlobal(noapi_runGlobal.script, noapi_runGlobal.path);\n"+
  "        }\n"+
  "        catch (error) {\n"+
  "            _connection_to_parent.invokeAsync({ noapi_runGlobal_error: { error: error, key: noapi_runGlobal.key } });\n"+
  "            keepa();\n"+
  "            return;\n"+
  "        }\n"+
  "        _connection_to_parent.invokeAsync({ noapi_runGlobal_response: { response: result, key: noapi_runGlobal.key } });\n"+
  "        keepa();\n"+
  "    }\n"+
  "    function handleKeepAliveAddRef(addRef) {\n"+
  "        var releaseCall = keepAlive();\n"+
  "        var token = _keepAlive_releases.length;\n"+
  "        _keepAlive_releases.push(releaseCall);\n"+
  "        _connection_to_parent.invokeAsync({ keepAlive_addRef_response: { key: addRef.key, token: token } });\n"+
  "    }\n"+
  "    function handleKeepAliveRelease(release) {\n"+
  "        var releaseCall = _keepAlive_releases[release.token];\n"+
  "        if (releaseCall) {\n"+
  "            _keepAlive_releases[release.key] = null;\n"+
  "            releaseCall();\n"+
  "        }\n"+
  "        _connection_to_parent.invokeAsync({ keepAlive_release_response: { key: release.key, token: release.token } });\n"+
  "    }\n"+
  "}\n"+
  "function nextTick(callback) {\n"+
  "    function fire() {\n"+
  "        if (fired)\n"+
  "            return;\n"+
  "        fired = true;\n"+
  "        callback();\n"+
  "    }\n"+
  "    var fired = false;\n"+
  "    setTimeout(fire, 0);\n"+
  "    if (typeof requestAnimationFrame !== 'undefined') {\n"+
  "        requestAnimationFrame(fire);\n"+
  "    }\n"+
  "    else if (typeof msRequestAnimationFrame !== 'undefined') {\n"+
  "        msRequestAnimationFrame(fire);\n"+
  "    }\n"+
  "}\n"+
  "function wrapAsync(fn) {\n"+
  "    return function () {\n"+
  "        var args = [];\n"+
  "        for (var i = 0; i < arguments.length - 1; i++) {\n"+
  "            args.push(arguments[i]);\n"+
  "        }\n"+
  "        var callback = arguments[arguments.length - 1];\n"+
  "        nextTick(function () {\n"+
  "            try {\n"+
  "                var result = fn.apply(null, args);\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "                callback(error);\n"+
  "            }\n"+
  "            callback(null, result);\n"+
  "        });\n"+
  "    };\n"+
  "}\n"+
  "function wrapAsyncNoError(fn) {\n"+
  "    return function () {\n"+
  "        var args = [];\n"+
  "        for (var i = 0; i < arguments.length - 1; i++) {\n"+
  "            args.push(arguments[i]);\n"+
  "        }\n"+
  "        var callback = arguments[arguments.length - 1];\n"+
  "        nextTick(function () {\n"+
  "            try {\n"+
  "                var result = fn.apply(null, args);\n"+
  "            }\n"+
  "            catch (error) {\n"+
  "                callback(error);\n"+
  "            }\n"+
  "            callback(result);\n"+
  "        });\n"+
  "    };\n"+
  "}\n"+
  "function createChildProcess(connection_to_parent, statics) {\n"+
  "    var pidCounter = 827;\n"+
  "    return {\n"+
  "        spawn: spawn\n"+
  "    };\n"+
  "    function spawn(options) {\n"+
  "        var sanitizedOptions = {};\n"+
  "        connection_to_parent.invokeAsync({ spawnChildProcess: sanitizedOptions }, function (error, result) {\n"+
  "            // TODO: invokeAsync-based implementation\n"+
  "        });\n"+
  "    }\n"+
  "}\n"+
  "function createEvents() {\n"+
  "    return {\n"+
  "        EventEmitter: EventEmitter\n"+
  "    };\n"+
  "}\n"+
  "var EventEmitter = (function () {\n"+
  "    function EventEmitter() {\n"+
  "        this._listeners = {};\n"+
  "    }\n"+
  "    EventEmitter.prototype.addListener = function (event, listener) {\n"+
  "        var key = '*' + event;\n"+
  "        var list = this._listeners[key] || (this._listeners[key] = []);\n"+
  "        list.push({ callback: listener });\n"+
  "        return this;\n"+
  "    };\n"+
  "    EventEmitter.prototype.removeListener = function (event, listener) {\n"+
  "        var key = '*' + event;\n"+
  "        var list = this._listeners[key];\n"+
  "        if (list) {\n"+
  "            for (var i = 0; i < list.length; i++) {\n"+
  "                if (list[i].callback === listener) {\n"+
  "                    list.splice(i, 1);\n"+
  "                    break;\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "        return this;\n"+
  "    };\n"+
  "    EventEmitter.prototype.removeAllListeners = function (event) {\n"+
  "        var key = '*' + event;\n"+
  "        delete this._listeners[key];\n"+
  "        return this;\n"+
  "    };\n"+
  "    EventEmitter.prototype.setMaxListeners = function (n) {\n"+
  "        // too complicated for now, ignore\n"+
  "    };\n"+
  "    EventEmitter.prototype.listeners = function (event) {\n"+
  "        var key = '*' + event;\n"+
  "        var list = this._listeners[key];\n"+
  "        if (!list)\n"+
  "            return [];\n"+
  "        var result = [];\n"+
  "        for (var i = 0; i < list.length; i++)\n"+
  "            result.push(list[i].callback);\n"+
  "        return result;\n"+
  "    };\n"+
  "    EventEmitter.prototype.emit = function (event) {\n"+
  "        var args = [];\n"+
  "        for (var _i = 1; _i < arguments.length; _i++) {\n"+
  "            args[_i - 1] = arguments[_i];\n"+
  "        }\n"+
  "        var key = '*' + event;\n"+
  "        var list = this._listeners[key];\n"+
  "        if (!list)\n"+
  "            return false;\n"+
  "        for (var i = 0; i < list.length; i++) {\n"+
  "            var item = list[i];\n"+
  "            if (args.length) {\n"+
  "                item.callback.apply(null, args);\n"+
  "            }\n"+
  "            else {\n"+
  "                var cb = item.callback;\n"+
  "                cb(); // direct calling can be quicker\n"+
  "            }\n"+
  "            if (item.once) {\n"+
  "                list.splice(i, 1);\n"+
  "                i--;\n"+
  "            }\n"+
  "        }\n"+
  "        return true;\n"+
  "    };\n"+
  "    EventEmitter.prototype.on = function (event, listener) {\n"+
  "        return this.addListener(event, listener);\n"+
  "    };\n"+
  "    EventEmitter.prototype.once = function (event, listener) {\n"+
  "        var key = '*' + event;\n"+
  "        var list = this._listeners[key] || (this._listeners[key] = []);\n"+
  "        list.push({ callback: listener, once: true });\n"+
  "        return this;\n"+
  "    };\n"+
  "    return EventEmitter;\n"+
  "}());\n"+
  "var fs_cache;\n"+
  "(function (fs_cache) {\n"+
  "    function fs_cache_structure(files) {\n"+
  "        var all = {};\n"+
  "        var root = { name: '/', files: null };\n"+
  "        files.sort();\n"+
  "        for (var i = 0; i < files.length; i++) {\n"+
  "            var fi = files[i];\n"+
  "            pushFile(fi, all, root);\n"+
  "        }\n"+
  "        return { all: all, root: root };\n"+
  "    }\n"+
  "    fs_cache.fs_cache_structure = fs_cache_structure;\n"+
  "    function pushFile(fi, all, root) {\n"+
  "        var parent = root;\n"+
  "        var parentSlash = 0;\n"+
  "        if (fi.charCodeAt(0) !== 47)\n"+
  "            fi = '/' + fi;\n"+
  "        while (true) {\n"+
  "            var nextSlash = fi.indexOf('/', parentSlash + 1);\n"+
  "            if (nextSlash < 0) {\n"+
  "                if (parentSlash < fi.length - 1)\n"+
  "                    all[fi] = parent[fi] = fi.slice(parentSlash + 1);\n"+
  "                return;\n"+
  "            }\n"+
  "            var dirPath = fi.slice(0, nextSlash);\n"+
  "            if (typeof parent[dirPath] !== 'object')\n"+
  "                parent[dirPath] = { name: fi.slice(parentSlash + 1, nextSlash), files: null };\n"+
  "            parent = all[dirPath] = parent[dirPath];\n"+
  "            parentSlash = nextSlash;\n"+
  "        }\n"+
  "    }\n"+
  "})(fs_cache || (fs_cache = {}));\n"+
  "function createFS(drive, modules) {\n"+
  "    var fs = {\n"+
  "        renameSync: renameSync,\n"+
  "        rename: wrapAsync(renameSync),\n"+
  "        statSync: statSync,\n"+
  "        lstatSync: statSync,\n"+
  "        stat: wrapAsync(statSync),\n"+
  "        lstat: wrapAsync(statSync),\n"+
  "        fstat: null, fstatSync: null,\n"+
  "        existsSync: existsSync,\n"+
  "        exists: wrapAsyncNoError(existsSync),\n"+
  "        openSync: openSync,\n"+
  "        open: wrapAsync(openSync),\n"+
  "        close: null, closeSync: function () { },\n"+
  "        fsync: null, fsyncSync: null,\n"+
  "        readFileSync: readFileSync,\n"+
  "        readFile: wrapAsync(readFileSync),\n"+
  "        createReadStream: null,\n"+
  "        writeFileSync: writeFileSync,\n"+
  "        writeFile: wrapAsync(writeFileSync),\n"+
  "        appendFile: null, appendFileSync: null,\n"+
  "        createWriteStream: null,\n"+
  "        readSync: readSync,\n"+
  "        read: wrapAsync(readSync),\n"+
  "        writeSync: writeSync,\n"+
  "        write: wrapAsync(writeSync),\n"+
  "        truncate: null, truncateSync: null,\n"+
  "        ftruncate: null, ftruncateSync: null,\n"+
  "        chown: null, chownSync: null,\n"+
  "        fchown: null, fchownSync: null,\n"+
  "        lchown: null, lchownSync: null,\n"+
  "        chmod: null, chmodSync: null,\n"+
  "        fchmod: null, fchmodSync: null,\n"+
  "        lchmod: null, lchmodSync: null,\n"+
  "        link: null, linkSync: null,\n"+
  "        readlink: null, readlinkSync: null,\n"+
  "        symlink: null, symlinkSync: null,\n"+
  "        unlink: null, unlinkSync: null,\n"+
  "        realpath: null, realpathSync: null,\n"+
  "        mkdir: wrapAsync(mkdirSync), mkdirSync: mkdirSync,\n"+
  "        rmdir: null, rmdirSync: null,\n"+
  "        readdir: wrapAsync(readdirSync), readdirSync: readdirSync,\n"+
  "        utimes: null, utimesSync: null,\n"+
  "        futimes: null, futimesSync: null,\n"+
  "        watch: watch, watchFile: watchFile, unwatchFile: unwatchFile\n"+
  "    };\n"+
  "    return { fs: fs, filesChanged: onfilesChanged };\n"+
  "    var _cache;\n"+
  "    var _cache_timestamp;\n"+
  "    function get_cache() {\n"+
  "        if (!_cache || _cache_timestamp !== drive.timestamp) {\n"+
  "            _cache = fs_cache.fs_cache_structure(drive.files());\n"+
  "            _cache_timestamp = drive.timestamp;\n"+
  "        }\n"+
  "        return _cache;\n"+
  "    }\n"+
  "    function readdirSync(path) {\n"+
  "        var fullPath = modules.path.resolve(path);\n"+
  "        var fsch = get_cache();\n"+
  "        var fno;\n"+
  "        if (fullPath === '/') {\n"+
  "            fno = fsch.root;\n"+
  "        }\n"+
  "        else {\n"+
  "            var fullPathDirName = fullPath;\n"+
  "            if (/.\\/$/.test(fullPath))\n"+
  "                fullPathDirName = fullPath.slice(0, fullPath.length - 1);\n"+
  "            else\n"+
  "                fullPath += '/';\n"+
  "            fno = fsch.all[fullPathDirName];\n"+
  "        }\n"+
  "        if (!fno)\n"+
  "            throw new Error('ENOENT: no such file or directory, scandir \\'' + path + '\\'');\n"+
  "        if (typeof fno === 'string')\n"+
  "            throw new Error('ENOTDIR: not a directory, scandir \\'' + path + '\\'');\n"+
  "        var result = fno.files; // cached file list (from previous calls of this function\n"+
  "        if (result)\n"+
  "            return result.slice(0);\n"+
  "        result = [];\n"+
  "        for (var k in fno)\n"+
  "            if (fno.hasOwnProperty(k)) {\n"+
  "                if (k.charCodeAt(0) !== 47)\n"+
  "                    continue; // not slash = not a fnode entry in the map\n"+
  "                var chno = fno[k];\n"+
  "                if (typeof chno === 'string')\n"+
  "                    result.push(chno);\n"+
  "                else\n"+
  "                    result.push(chno.name);\n"+
  "            }\n"+
  "        fno.files = result;\n"+
  "        return result.slice(0);\n"+
  "    }\n"+
  "    function readdirSync_old(path) {\n"+
  "        var fullPath = modules.path.resolve(path);\n"+
  "        var plusSlash = fullPath.charCodeAt(fullPath.length - 1) === 47 ? 0 : 1; // 47 is forwardslash\n"+
  "        var result = [];\n"+
  "        var files = drive.files();\n"+
  "        var resultMap = [];\n"+
  "        for (var i = 0; i < files.length; i++) {\n"+
  "            var fname = files[i];\n"+
  "            if (fname.length <= path.length\n"+
  "                || (fullPath.length > 1 && fname.charCodeAt(1) !== fullPath.charCodeAt(1)) // first letter doesn't match (where more than 1 letter)\n"+
  "                || fname.charCodeAt(fullPath.length + plusSlash - 1) !== 47\n"+
  "                || fname.slice(0, fullPath.length) !== fullPath)\n"+
  "                continue;\n"+
  "            var nextSlash = fname.indexOf('/', fullPath.length + plusSlash);\n"+
  "            if (nextSlash > 0)\n"+
  "                fname = fname.slice(0, nextSlash);\n"+
  "            fname = fname.slice(fullPath.length + plusSlash);\n"+
  "            if (resultMap[fname])\n"+
  "                continue;\n"+
  "            resultMap[fname] = 1;\n"+
  "            result.push(fname);\n"+
  "        }\n"+
  "        return result;\n"+
  "    }\n"+
  "    function onfilesChanged(files) {\n"+
  "        _cache = null;\n"+
  "        // TODO: fire watches!\n"+
  "    }\n"+
  "    function existsSync(file) {\n"+
  "        var fileFull = modules.path.resolve(file);\n"+
  "        return !!fileOrDir(fileFull);\n"+
  "    }\n"+
  "    function fileOrDir(file) {\n"+
  "        var content = drive.read(file);\n"+
  "        if (content || (content !== null && typeof content === 'undefined'))\n"+
  "            return 1;\n"+
  "        var files = drive.files();\n"+
  "        var normPath = modules.path.normalize(file);\n"+
  "        if (normPath.slice(-1) !== '/')\n"+
  "            normPath += '/';\n"+
  "        var leadMatch = getStartMatcher(file);\n"+
  "        for (var i = 0; i < files.length; i++) {\n"+
  "            if (leadMatch(files[i]))\n"+
  "                return 2; // directory exists\n"+
  "        }\n"+
  "        return 0;\n"+
  "    }\n"+
  "    function mkdirSync(path, mode) {\n"+
  "        var normPath = modules.path.resolve(path);\n"+
  "        if (normPath.slice(-1) !== '/')\n"+
  "            normPath += '/';\n"+
  "        if (existsSync(path))\n"+
  "            throw new Error('Directory \\'' + path + '\\'');\n"+
  "        setDriveTimestamp();\n"+
  "        drive.write(normPath, '');\n"+
  "    }\n"+
  "    function renameSync(oldPath, newPath) {\n"+
  "        var norm_oldPath = modules.path.resolve(oldPath);\n"+
  "        var norm_newPath = modules.path.resolve(newPath);\n"+
  "        var oldContent = drive.read(norm_oldPath);\n"+
  "        if (oldContent !== null) {\n"+
  "            // TODO: check if directory is in the way\n"+
  "            // if (nofs\n"+
  "            setDriveTimestamp();\n"+
  "            drive.write(norm_newPath, oldContent);\n"+
  "            drive.write(norm_oldPath, null);\n"+
  "            return;\n"+
  "        }\n"+
  "        if (drive.read(norm_newPath) !== null) {\n"+
  "            // node actually reports oldPath here, but let's be reasonable\n"+
  "            throw new Error('ENOTDIR, not a directory \\'' + newPath + '\\'');\n"+
  "        }\n"+
  "        if (norm_oldPath === '/')\n"+
  "            throw new Error('EBUSY, resource busy or locked \\'/\\'');\n"+
  "        else\n"+
  "            norm_oldPath += '/';\n"+
  "        if (norm_newPath === '/')\n"+
  "            throw new Error('EBUSY, resource busy or locked \\'/\\'');\n"+
  "        else\n"+
  "            norm_newPath += '/';\n"+
  "        var files = drive.files();\n"+
  "        var startAsOld = getStartMatcher(norm_oldPath);\n"+
  "        for (var i = 0; i < files.length; i++) {\n"+
  "            var fi = files[i];\n"+
  "            if (startAsOld(fi)) {\n"+
  "                var oldContent = drive.read(fi);\n"+
  "                var restPath = fi.slice(norm_newPath.length);\n"+
  "                var newFiPath = norm_newPath + restPath;\n"+
  "                setDriveTimestamp();\n"+
  "                drive.write(newFiPath, oldContent);\n"+
  "                drive.write(newFiPath, null);\n"+
  "            }\n"+
  "        }\n"+
  "    }\n"+
  "    function statSync(path) {\n"+
  "        var norm_path = modules.path.resolve(path);\n"+
  "        if (/.\\/$/.test(norm_path))\n"+
  "            norm_path = norm_path.slice(0, norm_path.length - 1);\n"+
  "        var cache = get_cache();\n"+
  "        var fnode = cache.all[norm_path];\n"+
  "        if (!fnode)\n"+
  "            throw new Error('ENOENT, no such file or directory \\'' + path + '\\'');\n"+
  "        var isDir = typeof fnode === 'object';\n"+
  "        var sz = isDir ? 0 : (drive.storedSize ? drive.storedSize(norm_path) : (drive.read(norm_path) || '').length);\n"+
  "        var tm = new Date(drive.timestamp);\n"+
  "        var st = {\n"+
  "            isFile: function () { return !isDir; },\n"+
  "            isDirectory: function () { return isDir; },\n"+
  "            isBlockDevice: function () { return false; },\n"+
  "            isCharacterDevice: function () { return true; },\n"+
  "            isSymbolicLink: function () { return false; },\n"+
  "            isFIFO: function () { return false; },\n"+
  "            isSocket: function () { return false; },\n"+
  "            dev: 234245,\n"+
  "            ino: 938450,\n"+
  "            mode: 0,\n"+
  "            nlink: 1,\n"+
  "            uid: 430534953,\n"+
  "            gid: 348274,\n"+
  "            rdev: 50953455,\n"+
  "            size: sz,\n"+
  "            blksize: -1,\n"+
  "            blocks: -1,\n"+
  "            atime: tm,\n"+
  "            mtime: tm,\n"+
  "            ctime: tm\n"+
  "        };\n"+
  "        return st;\n"+
  "    }\n"+
  "    /*\n"+
  "        stat(path: string, callback?: (err: no_ErrnoError, stats: nofs_Stats) => any): void;\n"+
  "        lstat(path: string, callback?: (err: no_ErrnoError, stats: nofs_Stats) => any): void;\n"+
  "        fstat(fd: number, callback?: (err: no_ErrnoError, stats: nofs_Stats) => any): void;\n"+
  "        statSync(path: string): nofs_Stats;\n"+
  "        lstatSync(path: string): nofs_Stats;\n"+
  "        fstatSync(fd: number): nofs_Stats;\n"+
  "      */\n"+
  "    function readFileSync(filename, options) {\n"+
  "        // TODO: handle encoding and other\n"+
  "        var result = drive.read(modules.path.resolve(filename));\n"+
  "        if (result || typeof result === 'string')\n"+
  "            return result;\n"+
  "        else\n"+
  "            throw new Error('ENOENT: no such file or directory, open \\'' + filename + '\\'');\n"+
  "    }\n"+
  "    function readSync(fd, buffer, offset, length, position) {\n"+
  "        // TODO: consider also std handles\n"+
  "        //var path = nofs_fdtable()[fd];\n"+
  "        throw new Error('Buffer-aware API fs.readSync is not implemented.');\n"+
  "    }\n"+
  "    function setDriveTimestamp() {\n"+
  "        drive.timestamp = Date.now ? Date.now() : +new Date();\n"+
  "    }\n"+
  "    function writeFileSync(filename, content) {\n"+
  "        setDriveTimestamp();\n"+
  "        drive.write(modules.path.resolve(filename), content);\n"+
  "    }\n"+
  "    function writeSync(fd, buffer, offset, length, position) {\n"+
  "        if (fd === 1) {\n"+
  "            if (typeof console !== 'undefined')\n"+
  "                console.log(buffer);\n"+
  "            return length;\n"+
  "        }\n"+
  "        var path = get_fdtable()[fd];\n"+
  "        writeFileSync(path, buffer);\n"+
  "    }\n"+
  "    function openSync(path, flags, mode) {\n"+
  "        var fdtable = get_fdtable();\n"+
  "        for (var fd in fdtable) {\n"+
  "            var fpath = fdtable[fd];\n"+
  "            if (fpath === path) {\n"+
  "                return Number(fd);\n"+
  "            }\n"+
  "        }\n"+
  "        var newFD = _fdbase_++;\n"+
  "        fdtable[newFD] = path;\n"+
  "        return newFD;\n"+
  "    }\n"+
  "    var _fdbase_;\n"+
  "    var _fdtable_;\n"+
  "    function get_fdtable() {\n"+
  "        if (!_fdtable_) {\n"+
  "            _fdtable_ = [];\n"+
  "            _fdbase_ = 34957346;\n"+
  "        }\n"+
  "        return _fdtable_;\n"+
  "    }\n"+
  "}\n"+
  "function getStartMatcher(oldPath) {\n"+
  "    if (!oldPath)\n"+
  "        return function (txt) { return !txt; };\n"+
  "    return function (txt) {\n"+
  "        if (!txt)\n"+
  "            return false;\n"+
  "        if (txt.length < oldPath.length)\n"+
  "            return false;\n"+
  "        return txt.slice(0, oldPath.length) === oldPath;\n"+
  "    };\n"+
  "}\n"+
  "var _watchFileListener;\n"+
  "function watchFile(filename, arg1, arg2) {\n"+
  "    throw new Error('not implemented');\n"+
  "}\n"+
  "function unwatchFile(filename, listener) {\n"+
  "    throw new Error('not implemented');\n"+
  "}\n"+
  "function watch(filename, arg1, arg2) {\n"+
  "    throw new Error('not implemented');\n"+
  "}\n"+
  "var createXHR = (function () {\n"+
  "    if (typeof XDomainRequest !== 'undefined') {\n"+
  "        var cachedXDomainRequest = XDomainRequest;\n"+
  "        return function () {\n"+
  "            var xdreq = new cachedXDomainRequest();\n"+
  "            return xdreq;\n"+
  "        };\n"+
  "    }\n"+
  "    else if (typeof ActiveXObject !== 'undefined') {\n"+
  "        var cachedActiveXObject = ActiveXObject;\n"+
  "        return function () {\n"+
  "            var axreq = new cachedActiveXObject('Microsoft.XMLHTTP');\n"+
  "            return axreq;\n"+
  "        };\n"+
  "    }\n"+
  "    else if (typeof XMLHttpRequest !== 'undefined') {\n"+
  "        var cachedXMLHttpRequest = XMLHttpRequest;\n"+
  "        return function () {\n"+
  "            var xhr = new cachedXMLHttpRequest();\n"+
  "            xhr.withCredentials = true; // is it right?\n"+
  "            return xhr;\n"+
  "        };\n"+
  "    }\n"+
  "})();\n"+
  "function createHTTP() {\n"+
  "    var ClientRequest = (function (_super) {\n"+
  "        __extends(ClientRequest, _super);\n"+
  "        function ClientRequest(options, callback) {\n"+
  "            _super.call(this);\n"+
  "            this._finished = false;\n"+
  "            if (typeof options === 'string') {\n"+
  "                this._url = options;\n"+
  "                this._options = {};\n"+
  "            }\n"+
  "            else {\n"+
  "                this._url =\n"+
  "                    (options.protocol || 'http') + '://' +\n"+
  "                        (options.host || options.hostname || 'localhost') +\n"+
  "                        (options.port ? ':' + options.port : '') +\n"+
  "                        (options.path || '/');\n"+
  "                this._options = options;\n"+
  "            }\n"+
  "            this._method = options.method || 'GET';\n"+
  "            this._callback = callback || options.callback;\n"+
  "        }\n"+
  "        ClientRequest.prototype.end = function () {\n"+
  "            var _this = this;\n"+
  "            var res;\n"+
  "            var req_callback = function (error, status, chunk, finish) {\n"+
  "                if (!res)\n"+
  "                    res = new IncomingMessage(_this);\n"+
  "                res._handleStatus(error, status, chunk, finish);\n"+
  "            };\n"+
  "            xhr_request({\n"+
  "                url: this._url,\n"+
  "                method: this._method,\n"+
  "                statusChanged: req_callback,\n"+
  "                fallback: function (xhrError) {\n"+
  "                    corsProxy_request({\n"+
  "                        url: _this._url,\n"+
  "                        method: _this._method,\n"+
  "                        withCredentials: false,\n"+
  "                        statusChanged: req_callback,\n"+
  "                        fallback: function (corsError) {\n"+
  "                            yqlProxy_request({\n"+
  "                                url: _this._url,\n"+
  "                                method: _this._method,\n"+
  "                                withCredentials: false,\n"+
  "                                statusChanged: req_callback,\n"+
  "                                fallback: function (corsError) {\n"+
  "                                    req_callback(xhrError, null, null, true);\n"+
  "                                }\n"+
  "                            });\n"+
  "                        }\n"+
  "                    });\n"+
  "                }\n"+
  "            });\n"+
  "            ;\n"+
  "        };\n"+
  "        return ClientRequest;\n"+
  "    }(EventEmitter));\n"+
  "    var IncomingMessage = (function (_super) {\n"+
  "        __extends(IncomingMessage, _super);\n"+
  "        function IncomingMessage(_req) {\n"+
  "            _super.call(this);\n"+
  "            this._req = _req;\n"+
  "            this._responseReported = false;\n"+
  "            this._offset = 0;\n"+
  "            this.statusCode = 0;\n"+
  "        }\n"+
  "        IncomingMessage.prototype._handleStatus = function (error, status, chunk, finish) {\n"+
  "            this.statusCode = status;\n"+
  "            this._ensureReported();\n"+
  "            if (chunk)\n"+
  "                this.emit('data', chunk);\n"+
  "            if (error) {\n"+
  "                this.emit('error', chunk);\n"+
  "            }\n"+
  "            if (finish) {\n"+
  "                if (!error)\n"+
  "                    this.emit('end');\n"+
  "                this.emit('close');\n"+
  "            }\n"+
  "        };\n"+
  "        IncomingMessage.prototype._ensureReported = function () {\n"+
  "            if (!this._responseReported) {\n"+
  "                this._responseReported = true;\n"+
  "                this._req.emit('response', this);\n"+
  "            }\n"+
  "        };\n"+
  "        return IncomingMessage;\n"+
  "    }(EventEmitter));\n"+
  "    return {\n"+
  "        request: function (options, callback) { return new ClientRequest(options, callback); },\n"+
  "        get: function (options, callback) {\n"+
  "            var req = new ClientRequest(options, callback);\n"+
  "            req.end();\n"+
  "            return req;\n"+
  "        },\n"+
  "        METHODS: [\n"+
  "            'ACL',\n"+
  "            'BIND',\n"+
  "            'CHECKOUT',\n"+
  "            'CONNECT',\n"+
  "            'COPY',\n"+
  "            'DELETE',\n"+
  "            'GET',\n"+
  "            'HEAD',\n"+
  "            'LINK',\n"+
  "            'LOCK',\n"+
  "            'M-SEARCH',\n"+
  "            'MERGE',\n"+
  "            'MKACTIVITY',\n"+
  "            'MKCALENDAR',\n"+
  "            'MKCOL',\n"+
  "            'MOVE',\n"+
  "            'NOTIFY',\n"+
  "            'OPTIONS',\n"+
  "            'PATCH',\n"+
  "            'POST',\n"+
  "            'PROPFIND',\n"+
  "            'PROPPATCH',\n"+
  "            'PURGE',\n"+
  "            'PUT',\n"+
  "            'REBIND',\n"+
  "            'REPORT',\n"+
  "            'SEARCH',\n"+
  "            'SUBSCRIBE',\n"+
  "            'TRACE',\n"+
  "            'UNBIND',\n"+
  "            'UNLINK',\n"+
  "            'UNLOCK',\n"+
  "            'UNSUBSCRIBE'],\n"+
  "        STATUS_CODES: {\n"+
  "            '100': 'Continue',\n"+
  "            '101': 'Switching Protocols',\n"+
  "            '102': 'Processing',\n"+
  "            '200': 'OK',\n"+
  "            '201': 'Created',\n"+
  "            '202': 'Accepted',\n"+
  "            '203': 'Non-Authoritative Information',\n"+
  "            '204': 'No Content',\n"+
  "            '205': 'Reset Content',\n"+
  "            '206': 'Partial Content',\n"+
  "            '207': 'Multi-Status',\n"+
  "            '208': 'Already Reported',\n"+
  "            '226': 'IM Used',\n"+
  "            '300': 'Multiple Choices',\n"+
  "            '301': 'Moved Permanently',\n"+
  "            '302': 'Found',\n"+
  "            '303': 'See Other',\n"+
  "            '304': 'Not Modified',\n"+
  "            '305': 'Use Proxy',\n"+
  "            '307': 'Temporary Redirect',\n"+
  "            '308': 'Permanent Redirect',\n"+
  "            '400': 'Bad Request',\n"+
  "            '401': 'Unauthorized',\n"+
  "            '402': 'Payment Required',\n"+
  "            '403': 'Forbidden',\n"+
  "            '404': 'Not Found',\n"+
  "            '405': 'Method Not Allowed',\n"+
  "            '406': 'Not Acceptable',\n"+
  "            '407': 'Proxy Authentication Required',\n"+
  "            '408': 'Request Timeout',\n"+
  "            '409': 'Conflict',\n"+
  "            '410': 'Gone',\n"+
  "            '411': 'Length Required',\n"+
  "            '412': 'Precondition Failed',\n"+
  "            '413': 'Payload Too Large',\n"+
  "            '414': 'URI Too Long',\n"+
  "            '415': 'Unsupported Media Type',\n"+
  "            '416': 'Range Not Satisfiable',\n"+
  "            '417': 'Expectation Failed',\n"+
  "            '418': 'I\\'m a teapot',\n"+
  "            '421': 'Misdirected Request',\n"+
  "            '422': 'Unprocessable Entity',\n"+
  "            '423': 'Locked',\n"+
  "            '424': 'Failed Dependency',\n"+
  "            '425': 'Unordered Collection',\n"+
  "            '426': 'Upgrade Required',\n"+
  "            '428': 'Precondition Required',\n"+
  "            '429': 'Too Many Requests',\n"+
  "            '431': 'Request Header Fields Too Large',\n"+
  "            '451': 'Unavailable For Legal Reasons',\n"+
  "            '500': 'Internal Server Error',\n"+
  "            '501': 'Not Implemented',\n"+
  "            '502': 'Bad Gateway',\n"+
  "            '503': 'Service Unavailable',\n"+
  "            '504': 'Gateway Timeout',\n"+
  "            '505': 'HTTP Version Not Supported',\n"+
  "            '506': 'Variant Also Negotiates',\n"+
  "            '507': 'Insufficient Storage',\n"+
  "            '508': 'Loop Detected',\n"+
  "            '509': 'Bandwidth Limit Exceeded',\n"+
  "            '510': 'Not Extended',\n"+
  "            '511': 'Network Authentication Required' },\n"+
  "        createClient: function (port, host) {\n"+
  "            var req = new ClientRequest({ port: port, host: host }, null);\n"+
  "            return req;\n"+
  "        },\n"+
  "        createServer: function () {\n"+
  "            throw new Error('HTTP server is not emulated.');\n"+
  "        }\n"+
  "    };\n"+
  "}\n"+
  "function xhr_request(options) {\n"+
  "    var canFallback = true;\n"+
  "    try {\n"+
  "        var xhr = createXHR();\n"+
  "        if ('withCredentials' in options && 'withCredentials' in xhr) {\n"+
  "            xhr.withCredentials = options.withCredentials;\n"+
  "        }\n"+
  "        if ('responseType' in xhr) {\n"+
  "            xhr.responseType = 'arraybuffer';\n"+
  "        }\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        reportStatusChanged(error, null, null, true);\n"+
  "        return;\n"+
  "    }\n"+
  "    /*\n"+
  "    try {\n"+
  "          if (skipCredentials && xhr.withCredentials) xhr.withCredentials = false;\n"+
  "    }\n"+
  "    catch (error) { }\n"+
  "    */\n"+
  "    var lastState = {\n"+
  "        status: 0,\n"+
  "        readyState: -1,\n"+
  "        offset: -1,\n"+
  "        finished: false\n"+
  "    };\n"+
  "    try {\n"+
  "        xhr.onreadystatechange = xhr_onreadystatechange;\n"+
  "        xhr.onload = xhr_onload;\n"+
  "        xhr.onloadend = xhr_onload;\n"+
  "        xhr.onprogress = xhr_onprogress;\n"+
  "        xhr.onabort = xhr_onabort;\n"+
  "        xhr.onerror = xhr_onerror;\n"+
  "        xhr.open(options.method, options.url, true);\n"+
  "        if (options.headers) {\n"+
  "            for (var k in options.headers)\n"+
  "                if (options.headers.hasOwnProperty(k)) {\n"+
  "                    xhr.setRequestHeader(k, options.headers[k]);\n"+
  "                }\n"+
  "        }\n"+
  "        var finished;\n"+
  "        var reportedReadyState;\n"+
  "        // TODO: set body\n"+
  "        xhr.send();\n"+
  "    }\n"+
  "    catch (error) {\n"+
  "        reportStatusChanged(error, null, null, true);\n"+
  "        return;\n"+
  "    }\n"+
  "    function reportStatusChanged(error, status, chunk, finish) {\n"+
  "        if (error || finish) {\n"+
  "            if (error || !status) {\n"+
  "                if (canFallback || options.fallback) {\n"+
  "                    canFallback = false;\n"+
  "                    options.fallback(error);\n"+
  "                    return;\n"+
  "                }\n"+
  "            }\n"+
  "        }\n"+
  "        canFallback = false;\n"+
  "        options.statusChanged(error, status, chunk, finish);\n"+
  "    }\n"+
  "    function update_callback(finish, error) {\n"+
  "        if (lastState.finished)\n"+
  "            return;\n"+
  "        if (xhr.readyState === 4)\n"+
  "            finish = true;\n"+
  "        if (error)\n"+
  "            finish = true;\n"+
  "        var chunk = getChunk();\n"+
  "        if ((xhr.readyState | 0) !== lastState.readyState) {\n"+
  "        }\n"+
  "        if ((chunk && chunk.length)\n"+
  "            || (xhr.status | 0) !== lastState.status\n"+
  "            || finish) {\n"+
  "            lastState.status = xhr.status | 0;\n"+
  "            lastState.readyState = xhr.readyState | 0;\n"+
  "            lastState.finished = finish;\n"+
  "            reportStatusChanged(error, lastState.status, chunk, finish);\n"+
  "        }\n"+
  "    }\n"+
  "    function getChunk() {\n"+
  "        var response = xhr.responseBlob || xhr.response || xhr.responseText;\n"+
  "        if (!response || response.length <= lastState.offset)\n"+
  "            return null;\n"+
  "        if (typeof response === 'string') {\n"+
  "            var chunk = new Buffer(response.slice(lastState.offset), 'utf8');\n"+
  "        }\n"+
  "        else {\n"+
  "            var chunk = new Buffer(response, lastState.offset);\n"+
  "        }\n"+
  "        lastState.offset = response.length;\n"+
  "        return chunk;\n"+
  "    }\n"+
  "    function xhr_onreadystatechange() {\n"+
  "        update_callback(false, null);\n"+
  "    }\n"+
  "    function xhr_onload() {\n"+
  "        update_callback(true, null);\n"+
  "    }\n"+
  "    function xhr_onprogress() {\n"+
  "        update_callback(false, null);\n"+
  "    }\n"+
  "    function xhr_onabort() {\n"+
  "        update_callback(true, new Error('Request aborted.'));\n"+
  "    }\n"+
  "    function xhr_onerror(event) {\n"+
  "        if (!event)\n"+
  "            event = window['event'];\n"+
  "        var error = !event ? new Error('XHR error') :\n"+
  "            event.error && 'message' in event.error ? event.error :\n"+
  "                event;\n"+
  "        update_callback(true, error);\n"+
  "    }\n"+
  "}\n"+
  "function corsProxy_request(options) {\n"+
  "    xhr_request({\n"+
  "        method: options.method,\n"+
  "        url: 'https://crossorigin.me/' + options.url,\n"+
  "        headers: options.headers,\n"+
  "        body: options.body,\n"+
  "        withCredentials: options.withCredentials,\n"+
  "        statusChanged: options.statusChanged,\n"+
  "        fallback: options.fallback\n"+
  "    });\n"+
  "}\n"+
  "function jsonpProxy_request(options) {\n"+
  "    options.fallback(null);\n"+
  "}\n"+
  "function yqlProxy_request(options) {\n"+
  "    options.fallback(null);\n"+
  "}\n"+
  "function createModule(existingLoaded, id, filename, parent, requireForModule) {\n"+
  "    var module = {\n"+
  "        exports: existingLoaded,\n"+
  "        id: id,\n"+
  "        filename: filename,\n"+
  "        loaded: false,\n"+
  "        parent: parent,\n"+
  "        children: [],\n"+
  "        require: require\n"+
  "    };\n"+
  "    return module;\n"+
  "    var _moduleCache;\n"+
  "    var _resolveCache;\n"+
  "    function require(moduleName) {\n"+
  "        var key = '*' + moduleName;\n"+
  "        if (_moduleCache && key in _moduleCache)\n"+
  "            return _moduleCache[key];\n"+
  "        var mod = requireForModule(moduleName);\n"+
  "        (_moduleCache || (_moduleCache = {}))[key] = mod;\n"+
  "        return mod;\n"+
  "    }\n"+
  "}\n"+
  "function createOS(global) {\n"+
  "    return {\n"+
  "        EOL: '\\n',\n"+
  "        tmpdir: function () { return '/.tmp'; },\n"+
  "        hostname: function () { return 'localhost'; },\n"+
  "        type: function () { return 'Linux'; },\n"+
  "        arch: function () { return global.process.arch; },\n"+
  "        platform: function () { return global.process.platform; },\n"+
  "        release: function () { return '3.16.0-38-generic'; },\n"+
  "        uptime: function () { return global.process.uptime(); },\n"+
  "        loadavg: function () { return [0.7275390625, 0.65576171875, 0.4658203125]; },\n"+
  "        totalmem: function () { return 3680739328 + ((Math.random() * 1000) | 0); },\n"+
  "        freemem: function () { return 2344873984 - ((Math.random() * 1000) | 0); },\n"+
  "        cpus: function () { return [\n"+
  "            { model: 'AMD A4-1250 APU with Radeon(TM) HD Graphics', speed: 800, times: { user: 8058000, nice: 29600, sys: 1079400, idle: 128185400, irq: 0 } },\n"+
  "            { model: 'AMD A4-1250 APU with Radeon(TM) HD Graphics', speed: 800, times: { user: 7779400, nice: 33000, sys: 1069200, idle: 127970900, irq: 0 } }\n"+
  "        ]; },\n"+
  "        networkInterfaces: function () {\n"+
  "            return {\n"+
  "                lo: [\n"+
  "                    { address: '127.0.0.1', family: 'IPv4', internal: true },\n"+
  "                    { address: '::1', family: 'IPv6', internal: true }\n"+
  "                ],\n"+
  "                wlan0: [\n"+
  "                    { address: '192.168.1.3', family: 'IPv4', internal: false },\n"+
  "                    { address: 'fe80::8256:f2ff:fe04:3d29', family: 'IPv6', internal: false }\n"+
  "                ]\n"+
  "            };\n"+
  "        }\n"+
  "    };\n"+
  "}\n"+
  "function createPath(process) {\n"+
  "    var result = {\n"+
  "        basename: basename, extname: extname,\n"+
  "        dirname: dirname,\n"+
  "        isAbsolute: isAbsolute,\n"+
  "        normalize: normalize,\n"+
  "        join: join,\n"+
  "        relative: relative, resolve: resolve,\n"+
  "        sep: '/',\n"+
  "        delimiter: ':'\n"+
  "    };\n"+
  "    return result;\n"+
  "    function isAbsolute(p) {\n"+
  "        return /^\\//.test(p);\n"+
  "    }\n"+
  "    function extname(p) {\n"+
  "        var base = basename(p);\n"+
  "        var lastDot = base.lastIndexOf('.');\n"+
  "        if (lastDot >= 0)\n"+
  "            return base.slice(lastDot);\n"+
  "        else\n"+
  "            return '';\n"+
  "    }\n"+
  "    function join() {\n"+
  "        var paths = [];\n"+
  "        for (var _i = 0; _i < arguments.length; _i++) {\n"+
  "            paths[_i - 0] = arguments[_i];\n"+
  "        }\n"+
  "        return join_core(paths);\n"+
  "    }\n"+
  "    function join_core(paths) {\n"+
  "        if (paths.length === 1)\n"+
  "            return paths[0];\n"+
  "        var parts = [];\n"+
  "        var trailSlash = false;\n"+
  "        for (var i = 0; i < paths.length; i++) {\n"+
  "            var part = paths[i];\n"+
  "            if (!part)\n"+
  "                continue;\n"+
  "            if (parts.length) {\n"+
  "                var wlead = part;\n"+
  "                part = part.replace(/^\\/+/, '');\n"+
  "                if (!part)\n"+
  "                    continue;\n"+
  "            }\n"+
  "            else {\n"+
  "                part = part.replace(/^\\/+/, '/'); // leading slash in first part should be preserved\n"+
  "                if (part === '/') {\n"+
  "                    parts.push('');\n"+
  "                    continue;\n"+
  "                }\n"+
  "            }\n"+
  "            var wtrail = part;\n"+
  "            part = part.replace(/\\/+$/, '');\n"+
  "            if (!part)\n"+
  "                continue;\n"+
  "            parts.push(part);\n"+
  "            trailSlash = wtrail.length > part.length;\n"+
  "        }\n"+
  "        if (trailSlash)\n"+
  "            parts.push('');\n"+
  "        return parts.join('/');\n"+
  "    }\n"+
  "    function relative(from, to) {\n"+
  "        throw new Error('path/relative is not implemented');\n"+
  "    }\n"+
  "    function resolve() {\n"+
  "        var pathSegments = [];\n"+
  "        for (var _i = 0; _i < arguments.length; _i++) {\n"+
  "            pathSegments[_i - 0] = arguments[_i];\n"+
  "        }\n"+
  "        var path = join_core(pathSegments);\n"+
  "        if (typeof path !== 'string')\n"+
  "            throw new Error('Path must be a string. Received ' + typeof path);\n"+
  "        if (!path || path === '.' || path === './')\n"+
  "            return process.cwd();\n"+
  "        if (path === '/')\n"+
  "            return '/';\n"+
  "        if (/^\\.\\//.test(path))\n"+
  "            path = path.replace(/^\\.\\//, '');\n"+
  "        if (path.charCodeAt(0) !== 47) {\n"+
  "            var cwd = process.cwd();\n"+
  "            if (cwd.slice(-1) === '/')\n"+
  "                path = cwd + path;\n"+
  "            else\n"+
  "                path = cwd + '/' + path;\n"+
  "        }\n"+
  "        if (!/^\\.+$/.test(path) && !/^\\.+\\//.test(path) && !/\\/\\.+\\//.test(path) && !/\\/\\.+$/.test(path))\n"+
  "            return path; // has no dot-directories such as . or ..  ?\n"+
  "        var trailingSlash = path.length && path.charCodeAt(path.length - 1) === 47;\n"+
  "        var parts = path.split('/');\n"+
  "        var newParts = [];\n"+
  "        for (var i = 0; i < parts.length; i++) {\n"+
  "            if (!parts[i])\n"+
  "                continue;\n"+
  "            if (parts[i] === '.')\n"+
  "                continue;\n"+
  "            if (parts[i] === '..') {\n"+
  "                if (newParts.length)\n"+
  "                    newParts.pop(); // going up beyond root returns root\n"+
  "            }\n"+
  "            else {\n"+
  "                newParts.push(parts[i]);\n"+
  "            }\n"+
  "        }\n"+
  "        return '/' + newParts.join('/') + (trailingSlash ? '/' : '');\n"+
  "    }\n"+
  "}\n"+
  "function basename(p, ext) {\n"+
  "    p = normalize(p);\n"+
  "    if (p === '/')\n"+
  "        return '';\n"+
  "    var result;\n"+
  "    var lastSlash = p.lastIndexOf('/');\n"+
  "    if (lastSlash === p.length - 1) {\n"+
  "        var prevSlash = p.lastIndexOf('/', lastSlash - 1);\n"+
  "        if (prevSlash < 0)\n"+
  "            prevSlash = 0;\n"+
  "        result = p.slice(prevSlash + 1, lastSlash);\n"+
  "    }\n"+
  "    else {\n"+
  "        result = p.slice(lastSlash + 1);\n"+
  "    }\n"+
  "    if (ext && result.length >= ext.length && result.slice(-ext.length) === ext)\n"+
  "        result = result.slice(0, result.length - ext.length);\n"+
  "    return result;\n"+
  "}\n"+
  "function dirname(p) {\n"+
  "    var p = normalize(p);\n"+
  "    if (p === '/')\n"+
  "        return '/';\n"+
  "    var lastSlash = p.lastIndexOf('/');\n"+
  "    if (lastSlash === p.length - 1)\n"+
  "        lastSlash = p.lastIndexOf('/', lastSlash - 1);\n"+
  "    return p.slice(0, lastSlash + 1);\n"+
  "}\n"+
  "function normalize(p) {\n"+
  "    return p;\n"+
  "}\n"+
  "/// <reference path=\"../../isolation/noapi/def.d.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/stream.d.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/events.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/module_def.d.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/process_def.d.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/asyncUtils.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/path.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/path_def.d.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/fs.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/fs_def.d.ts\"/>\n"+
  "/// <reference path=\"../../isolation/noapi/fs-cache.ts\"/>\n"+
  "function createProcess(modules, options, extra) {\n"+
  "    var evt = new EventEmitter();\n"+
  "    return {\n"+
  "        abort: abort, exit: exit, kill: kill,\n"+
  "        nextTick: nextTick,\n"+
  "        chdir: chdir, cwd: cwd,\n"+
  "        title: 'node',\n"+
  "        arch: 'ia32',\n"+
  "        platform: 'linux',\n"+
  "        execPath: '/usr/bin/nodejs',\n"+
  "        getgid: getgid, setgid: setgid, getuid: getuid, setuid: setuid,\n"+
  "        stdout: load_stdout(), stderr: load_stderr(), stdin: load_stdin(),\n"+
  "        memoryUsage: memoryUsage,\n"+
  "        uptime: load_uptime(),\n"+
  "        hrtime: function () { throw new Error('High resultion time is not implemenetd yet.'); },\n"+
  "        pid: load_pid(),\n"+
  "        umask: load_umask(),\n"+
  "        config: load_config(),\n"+
  "        versions: load_versions(),\n"+
  "        version: load_versions().node,\n"+
  "        argv: options.argv,\n"+
  "        env: options.env,\n"+
  "        addListener: function (e, c) { return evt.addListener(e, c); },\n"+
  "        on: function (e, c) { return evt.on(e, c); },\n"+
  "        once: function (e, c) { return evt.once(e, c); },\n"+
  "        removeListener: function (e, c) { return evt.removeListener(e, c); },\n"+
  "        removeAllListeners: function (e) { return evt.removeAllListeners(e); },\n"+
  "        setMaxListeners: function (n) { return evt.setMaxListeners(n); },\n"+
  "        listeners: function (e) { return evt.listeners(e); },\n"+
  "        emit: function (e, v) { return evt.emit(e, v); }\n"+
  "    };\n"+
  "    function abort() {\n"+
  "        if (extra.shutdown)\n"+
  "            extra.shutdown();\n"+
  "    }\n"+
  "    function exit(code) {\n"+
  "        extra.exitCode = code;\n"+
  "        if (extra.shutdown)\n"+
  "            extra.shutdown();\n"+
  "    }\n"+
  "    function kill(pid, signal) {\n"+
  "        // when we emulate processes, implement process termination\n"+
  "    }\n"+
  "    function chdir(directory) {\n"+
  "        var normDirectory = modules.path.normalize(directory);\n"+
  "        var dirStat = modules.fs.statSync(normDirectory);\n"+
  "        if (dirStat && dirStat.isDirectory()) {\n"+
  "            if (normDirectory !== cwd()) {\n"+
  "                options.cwd = normDirectory;\n"+
  "            }\n"+
  "        }\n"+
  "        else {\n"+
  "            // TODO: throw a node-shaped error instead\n"+
  "            throw new Error('ENOENT, no such file or directory');\n"+
  "        }\n"+
  "    }\n"+
  "    function cwd() {\n"+
  "        return options.cwd;\n"+
  "    }\n"+
  "    function getgid() {\n"+
  "        // taken from node running on ubuntu\n"+
  "        return 1000;\n"+
  "    }\n"+
  "    function setgid(id) {\n"+
  "        // TODO: use node-shaped error\n"+
  "        throw new Error('EPERM, Operation not permitted');\n"+
  "    }\n"+
  "    function getuid() {\n"+
  "        // taken from node running on ubuntu\n"+
  "        return 1000;\n"+
  "    }\n"+
  "    function setuid(id) {\n"+
  "        // TODO: use node-shaped error\n"+
  "        throw new Error('EPERM, Operation not permitted');\n"+
  "    }\n"+
  "    function load_uptime() {\n"+
  "        var _uptime_start_ = typeof Date.now === 'function' ? Date.now() : +(new Date());\n"+
  "        return uptime;\n"+
  "        function uptime() {\n"+
  "            var now = typeof Date.now === 'function' ? Date.now() : +(new Date());\n"+
  "            return now - _uptime_start_;\n"+
  "        }\n"+
  "    }\n"+
  "    function load_stdout() {\n"+
  "        return {\n"+
  "            write: function (msg) {\n"+
  "                options.console.log(msg);\n"+
  "            }\n"+
  "        };\n"+
  "    }\n"+
  "    function load_stderr() {\n"+
  "        return {};\n"+
  "    }\n"+
  "    function load_stdin() {\n"+
  "        return {};\n"+
  "    }\n"+
  "    function memoryUsage() {\n"+
  "        return {\n"+
  "            rss: 13225984 + ((Math.random() * 3000) | 0),\n"+
  "            heapTotal: 7130752 + ((Math.random() * 3000) | 0),\n"+
  "            heapUsed: 2449612 + ((Math.random() * 3000) | 0)\n"+
  "        };\n"+
  "    }\n"+
  "    function load_pid() {\n"+
  "        return 32754 + ((Math.random() * 500) | 0);\n"+
  "    }\n"+
  "    function load_umask() {\n"+
  "        var _umask_;\n"+
  "        return umask;\n"+
  "        function umask(mask) {\n"+
  "            if (typeof _umask_ !== 'number') {\n"+
  "                _umask_ = 2;\n"+
  "            }\n"+
  "            if (typeof mask === 'number') {\n"+
  "                var res = _umask_;\n"+
  "                _umask_ = mask;\n"+
  "                return res;\n"+
  "            }\n"+
  "            return _umask_;\n"+
  "        }\n"+
  "    }\n"+
  "    function load_versions() {\n"+
  "        // real node running on ubuntu as of Friday 22 of May 2015\n"+
  "        // (these might not be properly implemented when hosted in browser)\n"+
  "        var versions = {\n"+
  "            http_parser: '1.0',\n"+
  "            node: '0.10.38',\n"+
  "            v8: '3.14.5.9',\n"+
  "            ares: '1.9.0-DEV',\n"+
  "            uv: '0.10.36',\n"+
  "            zlib: '1.2.8',\n"+
  "            modules: '11',\n"+
  "            openssl: '1.0.1m',\n"+
  "            mi: '0.71n'\n"+
  "        };\n"+
  "        if (options.versions) {\n"+
  "            for (var k in options.versions)\n"+
  "                if (options.versions.hasOwnProperty(k)) {\n"+
  "                    versions[k] = options.versions[k];\n"+
  "                }\n"+
  "        }\n"+
  "        return versions;\n"+
  "    }\n"+
  "    function load_config() {\n"+
  "        return {\n"+
  "            target_defaults: {\n"+
  "                cflags: [],\n"+
  "                default_configuration: 'Release',\n"+
  "                defines: [],\n"+
  "                include_dirs: [],\n"+
  "                libraries: []\n"+
  "            },\n"+
  "            variables: {\n"+
  "                clang: 0,\n"+
  "                gcc_version: 48,\n"+
  "                host_arch: 'ia32',\n"+
  "                node_install_npm: true,\n"+
  "                node_prefix: '/usr',\n"+
  "                node_shared_cares: false,\n"+
  "                node_shared_http_parser: false,\n"+
  "                node_shared_libuv: false,\n"+
  "                node_shared_openssl: false,\n"+
  "                node_shared_v8: false,\n"+
  "                node_shared_zlib: false,\n"+
  "                node_tag: '',\n"+
  "                node_unsafe_optimizations: 0,\n"+
  "                node_use_dtrace: false,\n"+
  "                node_use_etw: false,\n"+
  "                node_use_openssl: true,\n"+
  "                node_use_perfctr: false,\n"+
  "                node_use_systemtap: false,\n"+
  "                openssl_no_asm: 0,\n"+
  "                python: '/usr/bin/python',\n"+
  "                target_arch: 'ia32',\n"+
  "                v8_enable_gdbjit: 0,\n"+
  "                v8_no_strict_aliasing: 1,\n"+
  "                v8_use_snapshot: false,\n"+
  "                want_separate_host_toolset: 0\n"+
  "            }\n"+
  "        };\n"+
  "    }\n"+
  "}\n"+
  "/// <reference path=\"../agent/API.d.ts\"/>\n"+
  "/// <reference path=\"../../persistence/src/API.d.ts\"/>\n";
        script += '\n\nconnection_to_parent.initApiContext = initApiContext;';
        return script;
    }
})(isolation);
/// <reference path="../../persistence/src/API.d.ts"/>
function createComplexSerializer(self) {
    if (!self)
        self = (function () { return this; })();
    var maxDepth = 8;
    var dummy = {};
    var dummyArray = [];
    var dummyError = new Error();
    var dummyFunction = function () { };
    var knownErrorProps = [
        'message', 'name',
        'stack',
        'fileName', 'lineNumber', 'columnNumber',
        'description', 'number', 'stackTraceLimit'
    ];
    var deserializedCtorCache = {};
    var deserializedFnCache = {};
    return {
        serialize: serialize,
        deserialize: deserialize
    };
    function serialize(obj) {
        return serializeDepth(obj, 0);
    }
    function serializeDepth(obj, depth) {
        try {
            switch (typeof obj) {
                case 'function':
                    return serializeFunctionDepth(obj, depth);
                case 'object':
                    if (!obj)
                        return null;
                    if (obj instanceof Error)
                        return serialize_error(obj);
                    if ((Array.isArray && Array.isArray(obj)) || obj instanceof Array)
                        return serializeArrayDepth(obj, depth);
                    return serializeObjectDepth(obj, depth);
                default:
                    return obj;
            }
        }
        catch (error) {
            return { '@unserializable': error.message };
        }
    }
    function serializeFunctionDepth(obj, depth) {
        var result = obj.name ?
            {
                '@function': 'function ' + obj.name + '() { /*...*/ }',
                '@function.name': obj.name
            } :
            {
                '@function': 'function() { /*...*/ }'
            };
        for (var k in obj) {
            if (!(k in dummyFunction)) {
                result[k] = serializeObjectDepth(obj[k], depth + 1);
            }
        }
        return result;
    }
    function serializeObjectDepth(obj, depth) {
        var srz = {};
        if (obj.constructor && obj.constructor.name && obj.constructor.name) {
            var ctorName = obj.constructor.name;
            if (ctorName !== 'Object')
                srz['@constructor'] = ctorName;
        }
        var propCount = 0;
        for (var k in obj)
            if (!(k in dummy)) {
                if (depth > maxDepth) {
                    propCount++;
                    continue;
                }
                var fail = false;
                try {
                    var kval = obj[k];
                }
                catch (error) {
                    srz[k] = { '@unserializable': error.message };
                    fail = true;
                }
                if (!fail)
                    srz[k] = serializeDepth(obj[k], depth + 1);
            }
        if (depth > maxDepth && propCount) {
            srz['...'] = propCount;
        }
        return srz;
    }
    function serializeArrayDepth(arr, depth) {
        if (depth > maxDepth && arr.length) {
            return ['...'];
        }
        var result = [];
        for (var i = 0; i < arr.length; i++) {
            var srz = serializeDepth(arr[i], depth + 1);
            if (typeof srz === 'undefined')
                continue;
            result[i] = srz;
        }
        return result;
    }
    function serialize_error(error) {
        var result = {};
        if (typeof error.constructor === 'function') {
            if (error.constructor.name) {
                result['@constructor'] = error.constructor.name;
            }
            else {
                var nameMatch = /function ([^\(]*)/.exec(error.constructor + '');
                if (nameMatch && nameMatch[1] && nameMatch[1].length < 200) {
                    var ctorName = nameMatch[1].replace(/[\s]+/g, ''); // additionally eliminate possible spaces
                    result['@constructor'] = ctorName;
                }
            }
        }
        for (var i = 0; i < knownErrorProps.length; i++) {
            var p = knownErrorProps[i];
            if (error[p] !== null && typeof error[p] !== 'undefined' && typeof error[p] !== 'function')
                result[p] = error[p];
        }
        for (var p in error) {
            if (p in result)
                continue;
            // this skips those weird upper-case constants from Error
            if (p in dummyError && error[p] === dummyError[p] && p.match(/^[A-Z][A-Z0-9_]+$/))
                continue;
            if (typeof error[p] === 'function')
                continue;
            result[p] = error[p];
        }
        if (error.prototype) {
            for (var p in error.prototype) {
                if (p in result)
                    continue;
                // this skips those weird upper-case constants from Error
                if (p in dummyError && error[p] === dummyError[p] && p.match(/^[A-Z][A-Z0-9_]+$/))
                    continue;
                if (typeof error[p] === 'function')
                    continue;
                result[p] = error[p];
            }
        }
        if (result.stack) {
            var lines = result.stack.split('\n');
            for (var i = lines.length - 1; i >= 0; i--) {
                if (/\beval\b/.test(lines[i])) {
                    if (i)
                        result.stack = lines.slice(0, i).join('\n');
                    else
                        result.stack = lines.slice(0, i + 1).join('\n');
                    break;
                }
            }
        }
        return result;
    }
    function deserialize(obj) {
        if (typeof obj !== 'object' || obj === null)
            return obj;
        if ((Array.isArray && Array.isArray(obj)) || obj instanceof Array)
            return deserializeArray(obj);
        return deserializeObject(obj);
    }
    function deserializeObject(obj) {
        var fnDeclText = obj['@function'];
        var fnDeclName = obj['@function.name'];
        if (fnDeclText) {
            var fnDecl = deserializedFnCache[fnDeclText];
            if (fnDecl)
                return fnDecl;
            try {
                if (fnDeclName)
                    var fnDeclFn = Function('return ' + fnDeclName + ';\n' + fnDeclText);
                else
                    var fnDeclFn = Function('return ' + fnDeclText);
                fnDecl = fnDeclFn();
                deserializedFnCache[fnDeclText] = fnDecl;
                return fnDecl;
            }
            catch (error) {
            }
        }
        var ctorName = obj['@constructor'];
        var result = createInstance_uncachedCtorName(ctorName);
        for (var k in obj) {
            if (k !== '@constructor' && !(k in dummy))
                result[k] = obj[k];
        }
        return result;
    }
    function deserializeArray(obj) {
        var result = [];
        for (var k in obj)
            if (!(k in dummyArray)) {
                result[k] = obj[k];
            }
        return result;
    }
    function createInstance_uncachedCtorName(ctorName) {
        var result;
        ctorName = validateCtorName(ctorName);
        if (ctorName) {
            try {
                var getFromGlobal = new Function('return typeof ' + ctorName + '==="undefined"?null:' + ctorName);
                var ctor = getFromGlobal();
                if (ctor) {
                    result = new ctor();
                    deserializedCtorCache[ctorName] = ctor;
                }
            }
            catch (error) {
            }
            if (!result) {
                var getCtor = new Function('return ' + ctorName + '; function ' + ctorName + '(){}');
                ctor = getCtor();
                deserializedCtorCache[ctorName] = ctor;
                result = new ctor();
            }
        }
        else {
            result = {};
        }
        return result;
    }
    function validateCtorName(ctorName) {
        if (ctorName) {
            if (!/^A-Za-z0-9_$/.test(ctorName)) {
                for (var i = 0; i < ctorName.length; i++) {
                    var ctorChar = ctorName.charAt(i);
                    if (/^A-Za-z0-9_$/.test(ctorChar))
                        continue;
                    else if (ctorChar.toLowerCase() !== ctorChar.toUpperCase())
                        continue;
                    // no, this is definitely a wrong character for identifier
                    ctorName = null;
                    break;
                }
            }
        }
        return ctorName;
    }
}
function createRequestResponseDispatcher() {
    var diagTimeStart = +new Date();
    var requests = { count: 0 };
    return {
        pushCallback: pushCallback_reqResDispatcher,
        popCallback: popCallback_reqResDispatcher
    };
    function pushCallback_reqResDispatcher(callback) {
        var key = generateKey();
        requests[key] = callback;
        return key;
    }
    function popCallback_reqResDispatcher(key) {
        if (key) {
            var callback = requests[key];
            if (callback)
                delete requests[key];
        }
        return callback;
    }
    function generateKey() {
        var key = (requests.count++).toString();
        // generate a bit of timestamp for the benefit of easier debugging
        if (Date.now)
            key += '-' + (Date.now() - diagTimeStart) + 'ms';
        else
            key += '-' + (+new Date() - diagTimeStart) + 'ms';
        return key;
    }
}
function createPushMessageDispatcher() {
    var registeredPushMessageCallbacks = [];
    var registeredPushMessageCallbacks_length = 0;
    return {
        handlePushMessage: handlePushMessage_pushMessageDispatcher,
        onPushMessage: onPushMessage_pushMessageDispatcher
    };
    function handlePushMessage_pushMessageDispatcher(pushMessage) {
        for (var i = 0; i < registeredPushMessageCallbacks_length; i++) {
            var cb = registeredPushMessageCallbacks[i];
            if (cb)
                cb(pushMessage);
        }
    }
    function onPushMessage_pushMessageDispatcher(callback) {
        var index = registeredPushMessageCallbacks_length;
        registeredPushMessageCallbacks.push(callback);
        registeredPushMessageCallbacks_length++;
        return unregister_pushMessageCallback;
        function unregister_pushMessageCallback() {
            if (index < 0)
                return;
            delete registeredPushMessageCallbacks[index];
            index = -1;
            // adjust the tail (removal of callbacks may run out of order)
            var newLength = registeredPushMessageCallbacks_length;
            while (!registeredPushMessageCallbacks[newLength] && newLength >= 0) {
                newLength--;
            }
            if (newLength !== registeredPushMessageCallbacks_length)
                registeredPushMessageCallbacks_length = newLength;
        }
    }
}
function driveApplyUpdates(tmDrive, msg) {
    tmDrive.timestamp = Math.max(tmDrive.timestamp, msg.timestamp);
    for (var i = 0; i < msg.driveUpdates.length; i++) {
        var up = msg.driveUpdates[i];
        if (up.deleteFile) {
            tmDrive.write(up.deleteFile, null);
        }
        else if (up.updateFile) {
            tmDrive.write(up.updateFile, up.content);
        }
    }
}
/// <reference path="ref.ts"/>
/// <reference path="createComplexSerializer.ts"/>
/// <reference path="createRequestResponseDispatcher.ts"/>
/// <reference path="createPushMessageDispatcher.ts"/>
/// <reference path="driveApplyUpdates.ts"/>
/// <reference path="../shared/all.ts"/>


}



  if (typeof module!=='undefined' && module && module.exports) {

    isolation();
module.exports = isolation;

  }
  else {
    document.body.style.color = 'white';

    isolation();
var tests;
(function (tests) {
    tests.buildMetadata = {
        'not null': function () { return assert(isolation.build); },
        'timestamp>=1462227529476': function () { return assert(isolation.build.timestamp >= 1462227529476); },
        '60000>taken>10': function () { return assert(isolation.build.taken > 10 && isolation.build.taken < 60000); },
        'platform is string': function () { return assert.equal('string', typeof isolation.build.platform); }
    };
})(tests || (tests = {}));
;
var tests;
(function (tests) {
    function driveAs(snapshot) {
        if (!snapshot.timestamp)
            snapshot.timestamp = 1465249756308;
        snapshot.files = function () {
            var result = [];
            for (var k in snapshot)
                if (k && k.charCodeAt(0) === 47)
                    result.push(k);
            return result;
        };
        snapshot.read = function (f) {
            var dt = snapshot[f];
            if (dt || typeof dt === 'string')
                return dt;
            else
                return null;
        };
        snapshot.write = function (f, txt) {
            if (txt || typeof txt === 'string')
                snapshot[f] = txt;
            else
                delete snapshot[f];
        };
        return snapshot;
    }
    tests['console'] = createTestsWith_createIsolateHost(isolation.createIsolateHost);
    tests['console_iframe'] = createTestsWith_createIsolateHost(isolation.createIsolateHost.iframe);
    tests['console_worker'] = createTestsWith_createIsolateHost(isolation.createIsolateHost.worker);
    function createTestsWith_createIsolateHost(createIsolateHost) {
        function testConsole(script, sourcePath, onconsole) {
            var host = createIsolateHost(driveAs({}), function (host) {
                host.onconsole = function (level, args) {
                    onconsole(level, args, close_clean);
                };
                host.remoteEval(script, null, sourcePath, function (error, result) {
                    try {
                        assert(!error, 'error ' + error);
                    }
                    catch (err) {
                        onconsole(null, null, null);
                        close_clean();
                    }
                });
                function close_clean() {
                    try {
                        if (host)
                            host.terminate();
                    }
                    catch (error) { }
                }
            });
        }
        return {
            console_log_3987345: function (callback) {
                testConsole('console.log(3987345)', '/tests/remoteEval_console_log.js', function (level, args, close_clean) {
                    try {
                        assert.equal('log', level);
                        assert.equal(1, args.length);
                        assert.equal(3987345, args[0]);
                    }
                    catch (error) {
                        callback(error);
                        close_clean();
                    }
                    callback();
                    close_clean();
                });
            },
            console_error_20495: function (callback) {
                testConsole('console.error(20495)', '/tests/remoteEval_console_log.js', function (level, args, close_clean) {
                    try {
                        assert.equal('error', level);
                        assert.equal(1, args.length);
                        assert.equal(20495, args[0]);
                    }
                    catch (error) {
                        callback(error);
                        close_clean();
                    }
                    callback();
                    close_clean();
                });
            },
            console_warn_abc_1_2: function (callback) {
                testConsole('console.warn("abc", [1,2])', '/tests/remoteEval_console_log.js', function (level, args, close_clean) {
                    try {
                        assert.equal('warn', level);
                        assert.equal(2, args.length);
                        assert.equal("abc", args[0]);
                        assert.equal(2, args[1].length);
                        assert.equal(1, args[1][0]);
                        assert.equal(2, args[1][1]);
                    }
                    catch (error) {
                        callback(error);
                        close_clean();
                    }
                    callback();
                    close_clean();
                });
            },
            console_trace_obj_a1_b456: function (callback) {
                testConsole('console.trace({a:1,b:456})', '/tests/remoteEval_console_log.js', function (level, args, close_clean) {
                    try {
                        assert.equal('trace', level);
                        assert.equal(1, args.length);
                        assert.equal(1, args[0].a);
                        assert.equal(456, args[0].b);
                    }
                    catch (error) {
                        callback(error);
                        close_clean();
                    }
                    callback();
                    close_clean();
                });
            },
            console_trace_obj_a1_bObject: function (callback) {
                testConsole('console.trace({a:1,b:Object})', '/tests/remoteEval_console_log.js', function (level, args, close_clean) {
                    try {
                        assert.equal('trace', level);
                        assert.equal(1, args.length);
                        assert.equal(1, args[0].a);
                        assert.equal('function Object() { /*...*/ }', args[0].b['@function']);
                    }
                    catch (error) {
                        callback(error);
                        close_clean();
                    }
                    callback();
                    close_clean();
                });
            }
        };
    }
})(tests || (tests = {}));
function driveAs(snapshot) {
    if (!snapshot.timestamp)
        snapshot.timestamp = 1465249756308;
    snapshot.files = function () {
        var result = [];
        for (var k in snapshot)
            if (k && k.charCodeAt(0) === 47)
                result.push(k);
        return result;
    };
    snapshot.read = function (f) {
        var dt = snapshot[f];
        if (dt || typeof dt === 'string')
            return dt;
        else
            return null;
    };
    snapshot.write = function (f, txt) {
        if (txt || typeof txt === 'string')
            snapshot[f] = txt;
        else
            delete snapshot[f];
    };
    return snapshot;
}
var tests;
(function (tests) {
    tests['createIsolateHost'] = createTestsWith_createIsolateHost(isolation.createIsolateHost);
    tests['createIsolateHost_iframe'] = createTestsWith_createIsolateHost(isolation.createIsolateHost.iframe);
    tests['createIsolateHost_worker'] = createTestsWith_createIsolateHost(isolation.createIsolateHost.worker);
    function createTestsWith_createIsolateHost(createIsolateHost) {
        return {
            createIsolateHost_succeeds: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    callback();
                    try {
                        if (host)
                            host.terminate();
                    }
                    catch (error) { }
                });
            },
            createIsolateHost_terminate: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    try {
                        host.terminate();
                    }
                    catch (error) {
                        callback(error);
                        return;
                    }
                    callback();
                });
            },
            remoteEval_withoutReturn: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('2+2', 0, '/tests/remoteEval_withoutReturn.js', function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            var _undef;
                            assert.equal(_undef, result, 'no return no result');
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_returns: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('return 2+2', 0, '/tests/remoteEval_returns.js', function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(4, result, '2+2 result');
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_terminate: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('return 2+2', 0, '/tests/remoteEval_terminate.js', function (error, result) {
                        try {
                            host.terminate();
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                    });
                });
            },
            remoteEval_throw: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('throw new Error("Abc34534")', 0, '/tests/remoteEval_throw.js', function (error, result) {
                        try {
                            assert(error, 'error ' + error);
                            assert.equal('Abc34534', error.message);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_throw_CustomError: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('throw new SyntaxError("DUTYFREE4")', 0, '/tests/remoteEval_throw_CustomError', function (error, result) {
                        try {
                            assert(error, 'error ' + error);
                            assert((error + '').indexOf('SyntaxError') >= 0, 'indexOf(SyntaxError) in ' + error);
                            assert((error + '').indexOf('DUTYFREE4') >= 0, 'indexOf(DUTYFREE4) in ' + error);
                            assert.equal('DUTYFREE4', error.message);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_simpleIN: function (callback) {
                var host = createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('return arguments[0]', 56, '/tests/remoteEval_simpleIN.js', function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(56, result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_complexIN: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('return arguments[0].value', { value: 97 }, '/tests/remoteEval_complexIN.js', function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(97, result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_complexOUT: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('return { value: 23 }', null, '/tests/remoteEval_complexOUT.js', function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(23, result.value);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            remoteEval_complexIN_OUT: function (callback) {
                createIsolateHost(driveAs({}), function (host) {
                    host.remoteEval('return { value: arguments[0].x+arguments[0].y }', { x: 2, y: 2 }, '/tests/remoteEval_complexIN_OUT.js', function (error, result) {
                        try {
                            assert(!error, 'error ' + error);
                            assert.equal(4, result.value);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                    function close_clean() {
                        try {
                            if (host)
                                host.terminate();
                        }
                        catch (error) { }
                    }
                });
            },
            connection_to_parent: {
                invokeAsync_hits_onmessage: function (callback) {
                    createIsolateHost(driveAs({}), function (host) {
                        var key = 'TEST-connection_to_parent_invokeAsync-' + (+new Date()) + '-' + Math.random();
                        host.onmessage = function () {
                            callback();
                            close_clean();
                        };
                        host.remoteEval('connection_to_parent.invokeAsync({TEST_key: "' + key + '"})', null, '/tests/connection_to_parent.js', function () {
                            // nothing
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                invokeAsync_passes_right_message: function (callback) {
                    createIsolateHost(driveAs({}), function (host) {
                        var key = 'TEST-connection_to_parent_invokeAsync-' + (+new Date()) + '-' + Math.random();
                        host.onmessage = function (msg) {
                            try {
                                assert.equal(key, msg.TEST_key);
                            }
                            catch (error) {
                                callback(error);
                                close_clean();
                                return;
                            }
                            callback();
                            close_clean();
                        };
                        host.remoteEval('connection_to_parent.invokeAsync({TEST_key: "' + key + '"})', null, '/tests/invokeAsync_passes_right_message.js', function () {
                            // nothing
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                invokeAsync_passes_return_bounce: function (callback) {
                    createIsolateHost(driveAs({}), function (host) {
                        var key = 'TEST-connection_to_parent_invokeAsync-' + (+new Date()) + '-' + Math.random();
                        host.onmessage = function (msg, sync, response_callback) {
                            if (msg.TEST_response_after_invoke) {
                                try {
                                    assert.equal(key, msg.TEST_response_after_invoke);
                                }
                                catch (error) {
                                    callback(error);
                                    close_clean();
                                    return;
                                }
                                callback();
                                close_clean();
                            }
                            else if (msg.TEST_key_original_message) {
                                try {
                                    assert.equal(key, msg.TEST_key_original_message);
                                    response_callback(null, { TEST_key_response: key });
                                }
                                catch (error) {
                                    callback(error);
                                    close_clean();
                                    return;
                                }
                            }
                        };
                        host.remoteEval('connection_to_parent.invokeAsync(\n' +
                            '  {TEST_key_original_message: "' + key + '"},\n' +
                            '  function (error, result) {\n' +
                            ' 	 connection_to_parent.invokeAsync({TEST_response_after_invoke: "' + key + '"});\n' +
                            '  })', null, '/tests/invokeAsync_passes_return_bounce.js', function () {
                            // this execution returns nothing, all conversation is through invokeAsync
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                pushMessage_reply_with_invokeAsync: function (callback) {
                    createIsolateHost(driveAs({}), function (host) {
                        var key = 'TEST-connection_to_parent_invokeAsync-' + (+new Date()) + '-' + Math.random();
                        host.onmessage = function (msg) {
                            try {
                                assert.equal(key + '123', msg.TEST_key);
                            }
                            catch (error) {
                                callback(error);
                                close_clean();
                                return;
                            }
                            callback();
                            close_clean();
                        };
                        host.remoteEval('var unsub = connection_to_parent.onPushMessage(function(msg) { connection_to_parent.invokeAsync({TEST_key: msg.key+"123"}); unsub(); }); ', null, '/tests/pushMessage_reply_with_invokeAsync.js', function () {
                            // nothing
                        });
                        host.pushMessage({ key: key });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_empty_files_none: function (callback) {
                    createIsolateHost(driveAs({}), function (host) {
                        host.remoteEval('return connection_to_parent.drive.files()', null, '/tests/drive_empty_files_none.js', function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal(0, result.length);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_empty_read_null: function (callback) {
                    createIsolateHost(driveAs({}), function (host) {
                        host.remoteEval('return connection_to_parent.drive.read("/temp")', null, '/tests/drive_empty_read_null', function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal(null, result);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_withFile_files: function (callback) {
                    createIsolateHost(driveAs({ '/mytext': 'mytext12514' }), function (host) {
                        host.remoteEval('return connection_to_parent.drive.files()', null, '/tests/drive_withFiles.js', function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal(1, result.length);
                                assert.equal('/mytext', result[0]);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_withFile_read_text06053: function (callback) {
                    createIsolateHost(driveAs({ '/textfile': 'text06053' }), function (host) {
                        host.remoteEval('return connection_to_parent.drive.read("/textfile")', null, '/tests/drive_withFile_read_text06053.js', function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal('text06053', result);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_write_read_immediately: function (callback) {
                    createIsolateHost(driveAs({}), function (host) {
                        host.remoteEval('connection_to_parent.drive.write("/mytext", "ui4345"); return connection_to_parent.drive.read("/mytext")', null, '/tests/drive_write_read_immediately.js', function (error, result) {
                            close_clean();
                            if (error)
                                return callback(error);
                            try {
                                assert.equal('ui4345', result);
                            }
                            catch (error) {
                                return callback(error);
                            }
                            callback();
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                },
                drive_write_spinCycle_affectsDrive: function (callback) {
                    var drive = driveAs({});
                    createIsolateHost(drive, function (host) {
                        host.remoteEval('connection_to_parent.drive.write("/mytext", "rlrjo45")', null, '/tests/drive_write_spinCycle_affectsDrive.js', function (error, result) {
                            if (error) {
                                close_clean();
                                return callback(error);
                            }
                            host.remoteEval('null', null, '/tests/drive_write_spinCycle_affectsDrive__null.js', function (error, result) {
                                close_clean();
                                if (error)
                                    return callback(error);
                                try {
                                    assert.equal('rlrjo45', drive['/mytext']);
                                }
                                catch (error) {
                                    return callback(error);
                                }
                                callback();
                            });
                        });
                        function close_clean() {
                            try {
                                if (host)
                                    host.terminate();
                            }
                            catch (error) { }
                        }
                    });
                }
            }
        };
    }
})(tests || (tests = {}));
var tests;
(function (tests) {
    function driveAs(snapshot) {
        if (!snapshot.timestamp)
            snapshot.timestamp = 1465249756308;
        snapshot.files = function () {
            var result = [];
            for (var k in snapshot)
                if (k && k.charCodeAt(0) === 47)
                    result.push(k);
            return result;
        };
        snapshot.read = function (f) {
            var dt = snapshot[f];
            if (dt || typeof dt === 'string')
                return dt;
            else
                return null;
        };
        snapshot.write = function (f, txt) {
            if (txt || typeof txt === 'string')
                snapshot[f] = txt;
            else
                delete snapshot[f];
        };
        return snapshot;
    }
    tests['noapi'] = createTestsWith_createIsolateHost(isolation.createIsolateHost);
    tests['noapi_iframe'] = createTestsWith_createIsolateHost(isolation.createIsolateHost.iframe);
    tests['noapi_worker'] = createTestsWith_createIsolateHost(isolation.createIsolateHost.worker);
    function createTestsWith_createIsolateHost(createIsolateHost) {
        function initNoapi(drive, callback) {
            isolation.createApiHost(driveAs(drive), {}, function (host) {
                callback(host, close_clean);
                function close_clean() {
                    try {
                        if (host)
                            host.terminate();
                    }
                    catch (error) { }
                }
            });
        }
        return {
            initApiContext_succeeds: function (callback) {
                initNoapi({}, function (host, close_clean) {
                    host.remoteEval('connection_to_parent.initApiContext({ drive: connection_to_parent.drive })', null, '/tests/initApiContext_succeeds.js', function (error, result) {
                        try {
                            assert(!error, error);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            },
            initApiContext_process_someProperties: function (callback) {
                initNoapi({}, function (host, close_clean) {
                    host.remoteEval('var opts = { drive: connection_to_parent.drive }; connection_to_parent.initApiContext(opts);\n ' +
                        'return {execPath: opts.process.execPath, platform: opts.process.platform, version: opts.process.version }; ', null, '/tests/initApiContext_process_someProperties.js', function (error, result) {
                        try {
                            assert(!error, error);
                            assert.equal('/usr/bin/nodejs', result.execPath);
                            assert.equal('linux', result.platform);
                            assert.equal('0.10.38', result.version);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            },
            initApiContext_runGlobal: function (callback) {
                initNoapi({}, function (host, close_clean) {
                    host.remoteEval('var opts = { drive: connection_to_parent.drive }; connection_to_parent.initApiContext(opts);\n ' +
                        'return opts.runGlobal("2+4594");', null, '/tests/initApiContext_runGlobal.js', function (error, result) {
                        try {
                            assert(!error, error);
                            assert.equal(4596, result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            },
            initApiContext_fs_existsSync_false: function (callback) {
                initNoapi({}, function (host, close_clean) {
                    host.remoteEval('var opts = { drive: connection_to_parent.drive }; connection_to_parent.initApiContext(opts);\n ' +
                        'return opts.coreModules.fs.existsSync("/tmp"); ', null, '/tests/initApiContext_fs_existsSync_false.js', function (error, result) {
                        try {
                            assert(!error, error);
                            assert.equal(false, result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            },
            initApiContext_fs_readFileSync: function (callback) {
                initNoapi({ "/tmp": "dummy" }, function (host, close_clean) {
                    host.remoteEval('var opts = { drive: connection_to_parent.drive }; connection_to_parent.initApiContext(opts);\n ' +
                        'return opts.coreModules.fs.readFileSync("/tmp"); ', null, '/tests/initApiContext_fs_readFileSync.js', function (error, result) {
                        try {
                            assert(!error, error);
                            assert.equal('dummy', result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            },
            initApiContext_require_moduleJS: function (callback) {
                initNoapi({ "/module.js": "module.exports = 2891279123;" }, function (host, close_clean) {
                    host.remoteEval('var opts = { drive: connection_to_parent.drive }; connection_to_parent.initApiContext(opts);\n ' +
                        'return opts.global.require("/module.js"); ', null, '/tests/initApiContext_require_moduleJS.js', function (error, result) {
                        try {
                            assert(!error, error);
                            assert.equal(2891279123, result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            },
            initApiContext_inModule_global_connection_to_parent_isUndefined: function (callback) {
                initNoapi({ "/module.js": "module.exports = typeof connection_to_parent;" }, function (host, close_clean) {
                    host.remoteEval('var opts = { drive: connection_to_parent.drive }; connection_to_parent.initApiContext(opts);\n ' +
                        'return opts.global.require("/module.js"); ', null, '/tests/initApiContext_inModule_global_connection_to_parent_isUndefined.js', function (error, result) {
                        try {
                            assert(!error, error);
                            assert.equal('undefined', result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            },
            initApiContext_inModule_global_XMLHttpRequest_isUndefined: function (callback) {
                initNoapi({ "/module.js": "module.exports = typeof XMLHttpRequest;" }, function (host, close_clean) {
                    host.remoteEval('var opts = { drive: connection_to_parent.drive }; connection_to_parent.initApiContext(opts);\n ' +
                        'return opts.global.require("/module.js"); ', null, '/tests/initApiContext_inModule_global_XMLHttpRequest_isUndefined.js', function (error, result) {
                        try {
                            assert(!error, error);
                            assert.equal('undefined', result);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            },
            initApiContext_http_get_returnsNotnull: function (callback) {
                initNoapi({}, function (host, close_clean) {
                    host.remoteEval('var opts = { drive: connection_to_parent.drive }; connection_to_parent.initApiContext(opts);\n ' +
                        'var http = opts.coreModules.http;\n' +
                        'var req = http.get({host:\'google.com\', path: \'/\'}, function(req) { var body = \'\'; req.on(\'data\', function(dt) { console.log(\'>\'+dt); }); });\n' +
                        'console.log(req)', null, '/tests/initApiContext_http_get_returnsNotnull.js', function (error, result) {
                        try {
                            assert(!error, error);
                            callback();
                        }
                        catch (err) {
                            callback(err);
                        }
                        close_clean();
                    });
                });
            }
        };
    }
})(tests || (tests = {}));
var Buffer;
Buffer = (function () {
    return Buffer;
    function Buffer(data, encoding, offset) {
        var buf;
        if (typeof data === 'number') {
            buf = new Uint8Array(data);
        }
        else if (typeof data === 'string') {
            if (encoding == 'base64') {
                var len = decodeBase64(data, null, 0);
                buf = new Uint8Array(len);
                decodeBase64(data, buf, 0);
            }
            else if (encoding == 'utf8' || !encoding) {
                var len = encodeUTF8(data, null, 0);
                buf = new Uint8Array(len);
                encodeUTF8(data, buf, 0);
            }
        }
        else if (typeof data === 'object' && data && typeof data.length === 'number') {
            buf = new Uint8Array(data.length);
            for (var i = 0; i < data.length; i++) {
                buf[i] = data[i];
            }
        }
        else {
            throw new Error('Buffer only supports initialization from length, array or string at the moment.');
        }
        buf.toString = toString;
        // TODO: add Buffer methods
        return buf;
    }
    function encodeUTF8(text, buf, start) {
        var pos = start | 0;
        for (var i = 0; i < text.length; i++) {
            var ch = text.charCodeAt(i);
            if (ch < 0x80) {
                if (buf)
                    buf[pos] = ch;
                pos++;
            }
            else if (ch < 0x800) {
                if (buf) {
                    buf[pos] = 0xC0 | ((ch >> 6) & 0xFF);
                    buf[pos + 1] = 0x80 | (ch & 0xFF);
                }
                pos += 2;
            }
            else {
                // TODO: treat Unicode surrogate pair stuff
                if (buf) {
                    buf[pos] = 0xE0 | ((ch >> 12) & 0xFF);
                    buf[pos + 1] = 0x80 | ((ch >> 6) & 0xFF);
                    buf[pos + 2] = 0x80 | (ch & 0xFF);
                }
                pos += 3;
            }
        }
        return pos;
    }
    function decodeUTF8(data) {
        var result = '';
        for (var i = 0; i < data.length; i++) {
            var b = data[i];
            var ch;
            if (!(b & 0x80)) {
                ch = b;
            }
            else {
                if ((b & 0xE0) === 0xC0) {
                    ch = (b << 6) | (data[i + 1] & 0xC0);
                    i++;
                }
                else {
                    ch = (b << 12) | ((data[i + 1] & 0xC0) << 6) | (data[i + 2] & 0xC0);
                    i += 2;
                }
            }
            result += String.fromCharCode(ch);
        }
        return result;
    }
    function b64Code(ch) {
        if (ch >= 65 /*A*/ && ch <= 90 /*Z*/)
            return ch - 65;
        if (ch >= 97 /*a*/ && ch <= 122 /*z*/)
            return ch - 97 + 26;
        if (ch >= 48 /*0*/ && ch <= 57 /*9*/)
            return ch - 48 + 26 + 26;
        if (ch == 43 /*+*/ || ch == 45 /*-*/)
            return 62;
        if (ch == 47 /*/*/ || ch == 95 /*_*/)
            return 63;
        if (ch == 61 /*=*/)
            return -1;
        else if (ch == 32 || ch == 9 || ch == 13 || ch == 10 || /\s/.test(String.fromCharCode(ch)))
            return -2; // whitespace
        else
            return -3; // invalid
    }
    function decodeBase64(b64, buf, start) {
        var phase = 0;
        var accum = 0;
        var pos = start | 0;
        for (var i = 0; i < b64.length; i++) {
            var ch = b64.charCodeAt(i);
            var co = b64Code(ch);
            if (phase >= 0) {
                if (co >= 0) {
                    phase = (phase + 1) % 4;
                    accum = (accum << 6) | co;
                    if (!phase) {
                        if (buf) {
                            buf[pos] = (accum >> 16) & 0xFF;
                            buf[pos + 1] = (accum >> 8) & 0xFF;
                            buf[pos + 2] = accum & 0xFF;
                        }
                        pos += 3;
                        accum = 0;
                    }
                }
                else if (co == -1)
                    phase = -1; // TODO: enforce block size before setting
                else if (co == -3)
                    throw new Error('The string to be decoded is not correctly encoded.');
            }
            else if (phase == -1) {
                if (co == -1)
                    phase = -2;
                else if (co != -2)
                    throw new Error('The string to be decoded is not correctly encoded.');
            }
            else if (phase == -2) {
                if (co != -2)
                    throw new Error('The string to be decoded is not correctly encoded.');
            }
        }
        if (phase == -1) {
            if (buf) {
                buf[pos] = (accum >> 10) & 0xFF;
                buf[pos + 1] = (accum >> 2) & 0xFF;
            }
            pos += 2;
        }
        else if (phase == -2) {
            if (buf) {
                buf[pos] = (accum >> 4) & 0xFF;
            }
            pos++;
        }
        else if (phase)
            throw new Error('The string to be decoded is not correctly encoded.');
        return pos;
    }
    function toString(encoding) {
        if (!encoding || encoding === 'utf8') {
            return decodeUTF8(this);
        }
        throw new Error('Parameters are too weird.');
    }
})();
/// <reference path="../../persistence/src/API.d.ts"/>
/// <reference path="../host/API.d.ts"/>
/// <reference path="../noapi/Buffer.ts"/>


    // running tests from HTML page
    var ui = document.createElement('div');
    ui.style.color = 'black';
    ui.innerHTML = '<h2> Tests for submodule... </h2>';
    window.onload = function() {
      runTests(generateTests());
    };

  }

  // # sourceURL=/submodule_script.js </script>
  /* <style>
  .prepared {
    opacity: 0.5;
  }
  .running {
    opacity: 1;
    color: cornflowerblue;
    font-weight: bold;
  }
  .success {
   opacity: 1;
  }
  .fail {
    opacity: 1;
    color: tomato;
  }
  .fail pre {
    font-size: 70%;
    margin: 0px; margin-left: 1em;
    padding: 0px;
  }
  </style><script id=tests_scripts> /* */

  

  function runTests(tests) {

    var testFilter = location.hash;
    if (testFilter && testFilter.charAt(0)==='#') testFilter = testFilter.slice(1);

    var summary = document.createElement('h2');
    summary.style.color = 'black';

    if ('textContent' in summary) summary.textContent = 'Tests (total '+tests.length+'):';
    else summary.innerText = tests.length+'Tests (total '+tests.length+'):';
    var successCount = 0;
    var failCount = 0;
    document.body.appendChild(summary);

    var testList = document.createElement('div');
    testList.style.color = 'black';

    var disabledTestList = document.createElement('div');
    disabledTestList.style.color = 'gold';

    var runIndex = 0;
    var testsToRun = [];
    for (var i = 0; i < tests.length; i++) {
      addTestRow(i);
    }

    document.body.appendChild(testList);
    document.body.appendChild(disabledTestList);

    setTimeout(function() {
      continueRunTests();
    }, 10);

    function continueRunTests() {

      var endTimeSlice = (Date.now ? Date.now() : +new Date()) + 300;

      // keep running if possible
      while (true){

        var stillWithinCycle = true;
        var completedSynchronously = false;

        // skip the disabled
        while (true) {
          if (runIndex === testsToRun.length) return;
          var t = testsToRun[runIndex];
          runIndex++;
          if (!t.disabled) break;
        }

        if (typeof console!=='undefined' && console && console.log) {
          console.log(t.testEntry.textContent || t.testEntry.innerText+'...');
        }

        var start = +new Date();
        t.testEntry.className = 'running';
        t.run(function(error) {
          var finish = +new Date();

          if (error) {
            if (typeof console!=='undefined' && console && console.error) {
              console.error('  ', error, (finish-start)/1000+'s.'+(' '+error.stack?error.stack:''));
            }
          }
          else {
            if (typeof console!=='undefined' && console && console.log) {
              console.log('  OK'+(finish-start)/1000+'s.');
            }
          }

          var tm = document.createElement('span');
          if ('textContent' in tm) tm.textContent = ' '+(finish-start)+'ms';
          else tm.innerText = ' '+(finish-start)+'ms';
          tm.style.fontSize = '80%';
          t.testEntry.appendChild(tm);
          if (!error) {
            t.testEntry.className = 'success';
            successCount++;
          }
          else {
            t.testEntry.className = 'fail';
            var errorOutput = document.createElement('pre');
            if ('textContent' in errorOutput) errorOutput.textContent = error;
            else errorOutput.innerText = error;
            t.testEntry.appendChild(errorOutput);
            failCount++;
          }

          var summaryText =
              'Tests ('+
              (failCount?'failed '+failCount:'no fails')+
              ', succeeded '+successCount+
              (testsToRun.length>failCount+successCount?', '+(testsToRun.length-failCount-successCount)+' to finish':'')+'):';

          if ('textContent' in summary) summary.textContent = summaryText;
          else summary.innerText = summaryText;

          if (stillWithinCycle) {
            completedSynchronously = true;
          }
          else {
            // async anyway, continue inline
          	continueRunTests();
          }
        });

        stillWithinCycle = false;
        if (completedSynchronously) {
          var now = Date.now ? Date.now() : +new Date();
          if (now>endTimeSlice) {
            setTimeout(continueRunTests, 1);
            return;
          }
        }
        else {
          return;
        }
      }
    }

    function addTestRow(i) {
      var t = tests[i];
      var testEntry = document.createElement('div');
      if (testFilter && t.name.toLowerCase().indexOf(testFilter.toLowerCase())<0) {
      	testEntry.className = 'disabled';
        t.disabled = true;
        disabledTestList.appendChild(testEntry);
      }
      else{
      	testEntry.className = 'prepared';
        testsToRun.push(t);
      	testList.appendChild(testEntry);
      }

      if ('textContent' in testEntry) testEntry.textContent = t.name;
      else testEntry.innerText = t.name;
      t.testEntry = testEntry;
    }
  }


  function assert(condition, message) {
    if (!condition) throw new Error(message||'Failure '+condition);
  }

  assert.equal = (function(){
    function equal(expected, actual, message) {
      if (expected!=actual) throw new Error(message||'Unmatch: '+expected+' != '+actual);
    }
    return equal;
  })();

  function generateTests() {

    var allTests = [];
    var _dummy = {};

    for (var k in tests) if (!(k in _dummy) && tests[k] && /^[a-z\_]/.test(k)) {
      collectTests(k, tests[k]);
    }

    return allTests;


    function collectTests(prefix, obj) {
      if (!obj) return;
      for (var k in obj) if (!(k in _dummy) && obj[k]) {
        if (/^[A-Z]/.test(k) && typeof obj[k] === 'function') {
          // TODO: should we construct here?
        }
        else if (/^[a-z]/.test(k)) {
          if (typeof obj[k]==='function') {
            if (k==='generateTests') {
              var moreTests = obj.generateTests();
              collectTests(prefix, moreTests);
            }
            else {
              addTest(prefix+'.'+k, obj, k);
            }
          }
          else if (typeof obj[k]==='object' && /^[a-z]/.test(k)) {
            collectTests(prefix+'.'+k, obj[k]);
          }
        }
      }
    }

    function addTest(fullname, thisObj, key) {
      var args = functionArgs(thisObj[key]);
      if (args && /callback/.test(args)) {
        allTests.push({
          name: fullname,
          run: function(callback) {
            try {
              thisObj[key](callback);
            }
            catch (error) {
              callback(error);
            }
          }
        });
      }
      else {
        allTests.push({
          name: fullname,
          run: function(callback) {
            try {
              thisObj[key]();
            }
            catch (error) {
              callback(error);
              return;
            }

            callback(null);
          }
        });
      }
    }

  }

  function functionBody(fn, replacements) {
    // first skip until (
    // then skip until )
    // then skip until {
    // then take everything until the last }
    var match =
        /^[^\(]*\([^\)]*\)[^\{]*\{([\s\S]*)\}[^\}]*$/.exec(fn+'');
        // /^[^\(]*\([^\)]*\)[^\{]*\{([ \t]*\n)([\s\S]*)([ \t]*\n[ \t]*)\}[^\}]*$/.exec(fn+'');
    if (!match) return null;

    var bodyText = match[1];
    if (!replacements) return bodyText;
    else return substitute(bodyText, replacements);
  }
function functionArgs(fn) {
    var match = /^[^\(]*\(\s*([^\)]*)\s*\)/.exec(fn+'');
    return match?match[1]:null;
  }
function jsString(str) {
    if (!str) {
      if (typeof str==='string') return '""';
      else if (typeof str==='undefined') return 'undefined';
      else return 'null';
    }

    var _JSON = typeof JSON!=='undefined'? JSON : typeof window === 'undefined' ? null : window.JSON;
    var result = '"';
    var stretchStart = 0;
    for (var i = 0; i < str.length; i++) {
      var code = str.charCodeAt(i);
      var fix;
      switch (code) {
        case 10: fix = i==str.length-1 ? '\\n' : '\\n"+\n  "'; break;
        case 13: fix = '\\r'; break;
        case 92: fix = '\\\\'; break;
        case 34: fix = '\\\"'; break;
        case 9: fix = '\\t'; break;
        default:
          if (code < 32 || // transcribe control codes
              ((code&0xFF00)===0xFD00) || ((code&0xFF00)==0xFF00)) { // transcribe potentially corrupt Unicode
            fix = '\\u'+(0x10000 + code).toString(16).slice(1);
            break;
          }
          continue;
      }

      if (stretchStart!==i) {
      	result += str.slice(stretchStart, i) + fix;
      }
      else {
        result += fix;
      }

      stretchStart = i+1;
    }

    if (stretchStart)
      result += str.slice(stretchStart)+'"';
    else
      result = '"'+str+'"';

    return result;
  }
function jsStringLong(str) {
    if (str===null) return 'null';
    else if (typeof str==='undefined') return 'undefined';
    var wordCounts = {};
    var wordArray = [];
    str.replace(/[a-zA-Z0-9_]+/g, function(w) {
      var key = '*'+w;
      if (wordCounts[key]) {
        wordCounts[key]++;
      }
      else {
        wordCounts[key] = 1;
        wordArray.push(w);
      }
    });
    wordArray.sort(function(w1, w2) {
      var n1 = wordCounts['*'+w1];
      var n2 = wordCounts['*'+w2];
      return n1 > n2 ? -1 : n2 > 1 ? +1 : 0;
    });
    var replaceTable = {};
    for (var i = 0; i < wordArray.length; i++) {
      replaceTable['*'+wordArray[i]] = toLetterNumber(i);
    }

    var compressed = str.replace(/(\s+)|([a-zA-Z0-9_]+)/g, function(match, whitespace, word) {
      if (word) return replaceTable['*'+word];
      return whitespace.
        replace(/ +/g, function(spaces) {
          if(spaces.length<2) return spaces;
          else return 'Z'+spaces.length;
        }).
        replace(/\n/g, 'Z');
    });

    var wordarr = [];
    var lineLen = 0;
    for (var i = 0; i < wordArray.length; i++) {
      var nextWord = wordArray[i];
      if (lineLen) {
        wordarr[wordarr.length-1] += ','+nextWord;
      }
      else {
        if (i) nextWord = '"+\n"'+nextWord;
        wordarr.push(nextWord);
      }

      lineLen+=nextWord.length+1;
      if (lineLen>100)
        lineLen = 0;
    }

    return [
      '(function(d,c,s,r,m,nn,n) { var k = 0;',
      'return c.replace(/([a-zA-Y]+)|(Z[0-9]*)/g, function(x,t,w) {',
        'if (w=="Z") return "\\n";',
        'else if (w&&w.charCodeAt(0)=='+('Z').charCodeAt(0)+') return s[m=parseInt(w.slice(1))] || (s[m] = Array(m+1).join(" "));',
        'if (r.hasOwnProperty(w)) return r[w];',
        'nn=0,m=1;',
        'for(var i=0;i<t.length;i++){',
          'var n=t.charCodeAt(i);',
          'nn+=m*(n-(n>'+(('a').charCodeAt(0)-1)+' ? '+('a').charCodeAt(0)+':'+(('A').charCodeAt(0)-26)+'));',
          'm*='+(25+26)+';',
        '}',
        'if (nn<100 && !r[nn]) return r[nn] = d[nn];', // cache word lookups for 100 most frequent words
        'else return d[nn];',
      '});\n',
      '}(("'+wordarr.join(',')+'").split(","),"'+compressed.replace(/\\/g, '\\\\').replace(/\"/g, '\\"').replace(/\r/g, '\\r')+'",[],{}))'
    ].join('\n');

    function toLetterNumber(num) {
      if (!num) return 'a';
      var base = 26+25; // a-z A-Y (leave out uppercase Z)
      var result = [];
      while (num) {
        var n = num % base;
        if (n<26)
          result.push(String.fromCharCode('a'.charCodeAt(0)+n));
        else
          result.push(String.fromCharCode('A'.charCodeAt(0)+n-26));
        num = (num / base)|0;
      }
      return result.join('');
    }
  }


  // # sourceURL=/tests_scripts.js </script>
