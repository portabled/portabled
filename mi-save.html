<!doctype html>
<title>mini shell </title>

<script data-legit=mi>
  window.onerror = function onerror() {

  var msg = [];
  for (var i = 0; i < arguments.length; i++) {
    var a = arguments[i];
    if (a && (typeof a === 'object')) {

      if (a.stack) {
        msg.push(a.stack);
      }
      else {
        var msg1 = [];
        for (var k in a) {
          var r = a[k];
          if (typeof r === 'function' || (typeof r === 'object' && !r)) continue;
          msg1.push(k+':'+r);
        }
        msg.push(msg1.join(', '));
      }
    }
    else {
      msg.push(a===null ? 'null' : a);
    }

  }

  alert(msg.join('\n'));

}
//# sourceURL=boot/onerror.js
</script>
<script data-legit=mi>
  earlyBoot();
  function getText(obj) {

  if (typeof obj === 'function') {
    var result = /\/\*(\*(?!\/)|[^*])*\*\//m.exec(obj+'')[0];
    if (result) result = result.slice(2, result.length-2);
    return result;
  }
  else if (/^SCRIPT$/i.test(obj.tagName)) {
    if ('text' in obj)
      return obj.text;
    else
      return obj.innerHTML;
  }
  else if (/^STYLE$/i.test(obj.tagName)) {
    if ('text' in obj)
      return obj.text;
    else if (obj.styleSheet)
      return obj.styleSheet.cssText;
    else
      return obj.innerHTML;
  }
  else if ('textContent' in obj) {
    return obj.textContent;
  }
  else if (/^INPUT$/i.test(obj.tagName)) {
    return obj.value;
  }
  else {
    var result = obj.innerText;
    if (result) {
      // IE fixes
      result = result.replace(/\<BR\s*\>/g, '\n').replace(/\r\n/g, '\n');
    }
    return result || '';
  }
}

function setText(obj, text) {

  if (/^SCRIPT$/i.test(obj.tagName)) {
    if ('text' in obj)
      obj.text = text;
    else
      obj.innerHTML = text;
  }
  else if (/^STYLE$/i.test(obj.tagName)) {
    if ('text' in obj)
      obj.text = text;
    else if (obj.styleSheet)
      obj.styleSheet.cssText = text;
    else
      obj.innerHTML = text;
  }
  else if ('textContent' in obj) {
    obj.textContent = text;
  }
  else if (/^INPUT$/i.test(obj.tagName)) {
    obj.value = text;
  }
  else {
    obj.innerText = text;
  }
}

elem.on = function (obj, eventName, handler) {
  if (obj.addEventListener) {
    obj.addEventListener(eventName, handler, false);
  }
  else if (obj.attachEvent) {
    obj.attachEvent(eventName, handler);
  }
  else {
    obj['on'+eventName] = handler;
  }
};

elem.off = function (obj, eventName, handler) {
  if (obj.removeEventListener) {
    obj.removeEventListener(eventName, handler, false);
  }
  else if (obj.detachEvent) {
    obj.detachEvent(eventName, handler);
  }
  else {
    if (obj['on'+eventName] === handler)
      obj['on' + eventName] = null;
  }
};

function elem(tag, style, parent) {
  var e = tag.tagName ? tag : this.document.createElement(tag);

  if (!parent && style && style.tagName) {
    parent = style;
    style = null;
  }

  if (style) {
    if (typeof style === 'string') {
      setText(e, style);
    }
    else {
      for (var k in style) if (style.hasOwnProperty(k)) {
        if (k === 'text') {
          setText(e, style[k]);
        }
        else if (k === 'className') {
          e.className = style[k];
        }
        else if (!(k in e.style) && k in e) {
          e[k] = style[k];
        }
        else {

          if (style[k] && typeof style[k] === 'object' && typeof style[k].length === 'number') {
            // array: iterate and apply values
            var applyValues = style[k];
						for (var i = 0; i < applyValues.length; i++) {
              try { e.style[k] = applyValues[i]; }
              catch (e) { }
            }
          }
          else {
            // not array
            try {
              e.style[k] = style[k];
            }
            catch (err) {
              try {
                if (typeof console !== 'undefined' && typeof console.error === 'function')
                  console.error(e.tagName+'.style.'+k+'='+style[k]+': '+err.message);
              }
              catch (whatevs) {
                alert(e.tagName+'.style.'+k+'='+style[k]+': '+err.message);
              }
            }
          }
        }
      }
    }
  }

  if (parent) {
    try {
      parent.appendChild(e);
    }
    catch (error) {
      throw new Error(error.message+' adding '+e.tagName+' to '+parent.tagName);
    }
  }

  return e;
}

function createFrame(style) {

  if (!style)
    style = {
      position: 'absolute',
      left: 0, top: 0,
      width: '100%', height: '100%',
      border: 'none',
      src: 'about:blank'
    };

  var ifr = this.elem('iframe', style, this.document.body);

  var ifrwin = ifr.contentWindow || ifr.window;
  var ifrdoc = ifrwin.document;

  if (ifrdoc.open) ifrdoc.open();
  ifrdoc.write(
    '<!'+'doctype html'+'>'+
    '<'+'html'+'>'+
    '<'+'head'+'><'+'style'+'>'+
    'body,html{margin:0;padding:0;border:none;height:100%;}'+
    '*,*:before,*:after{box-sizing:inherit;}'+
    'html{box-sizing:border-box;}'+
    '</'+'style'+'>\n'+
    // IE6/7/8 bug: global scope and window are not identical
    (ifrwin.Function?'':'<'+'script'+'>window.Function=Function</'+'script'+'>')+
    '<'+'body'+'><'+'body'+'>'+
  	'</'+'html'+'>');
  if (ifrdoc.close) ifrdoc.close();

  ifrwin.elem = elem;

  if (window.onerror)
    ifrwin.onerror = delegate_onerror;

  return {
    document: ifrdoc,
    global: ifrwin,
    iframe: ifr
  };

  function delegate_onerror(a,b,c,d,e,f,g,h) {
    window.onerror(a,b,c,d,e,f,g,h);
  }
}

function loadMod(options) {

  var style = options.style;
  if (!options.ui) {
    style = { display: 'none' };
  }
  else if (typeof style === 'string') {
    style = { className: style, display: 'none' };
  }

  var frame = this.createFrame(style);
  var frameFunction = frame.global.Function;

  if (options.scope) {
    var scope = typeof options.scope === 'function' ? (options.scope)(frame.global) : options.scope;
    for (var k in scope) if (scope.hasOwnProperty(k)) {
      frame.global[k] = scope[k];
    }
  }

  if (options.eval) {

    var exportsInScope = scope && 'exports' in scope;
    var evalArgNames = exportsInScope ? [] : ['exports'];
    var evalArgs = exportsInScope ? [] : [{}];
    if (scope) {
      for (var k in scope) if (scope.hasOwnProperty(k)) {
        evalArgNames.push(k);
        evalArgs.push(scope[k]);
      }
    }

    if (!options.ui) {
      var allowedGlobals = {
        setTimeout: 1, setInterval: 1, clearTimeout: 1, clearInterval: 1,
        eval: 1,
        console: 1,
        undefined: 1,
        Array: 1, Date: 1, Function: 1, String: 1, Boolean: 1, Number: 1,
        Infinity: 1, NaN: 1, isNaN: 1, isFinite: 1, parseInt: 1, parseFloat: 1,
        escape: 1, unescape: 1,

        Int32Array: 1, Int8Array: 1, Int16Array: 1,
        UInt32Array: 1, UInt8Array: 1, UInt8ClampedArray: 1, UInt16Array: 1,
        Float32Array: 1, Float64Array: 1, ArrayBuffer: 1,

        Math: 1, JSON: 1, RegExp: 1,
        Error: 1, SyntaxError: 1, EvalError: 1, RangeError: 1, ReferenceError: 1,

        toString: 1, toJSON: 1, toValue: 1,

        Map: 1
      };

      var hiddenKeys = {};

      // normal properties
      for (var k in frame.global) {
        if (scope && scope.hasOwnProperty(k)) continue;
        if (allowedGlobals.hasOwnProperty(k)) continue;
        evalArgNames.push(k);
        hiddenKeys[k] = 1;
      }

      // non-enumerable properties directly on global
      if (Object.getOwnPropertyNames) {
        var props = Object.getOwnPropertyNames(frame.global);
        for (var i = 0; i < props.length; i++) {
          if (scope && scope.hasOwnProperty(props[i])) continue;
          if (allowedGlobals.hasOwnProperty(props[i])) continue;
          if (hiddenKeys.hasOwnProperty(props[i])) continue;
          evalArgNames.push(props[i]);
        }

        // non-enumerable properties on global's prototype
        if (frame.global.constructor
          && frame.global.constructor.prototype
          && frame.global.constructor.prototype != Object
          && frame.global.constructor.prototype != Object.prototype) {
          props = Object.getOwnPropertyNames(frame.global.constructor.prototype);
          for (var i = 0; i < props.length; i++) {
            if (scope && scope.hasOwnProperty(props[i])) continue;
            if (allowedGlobals.hasOwnProperty(props[i])) continue;
            if (hiddenKeys.hasOwnProperty(props[i])) continue;
            evalArgNames.push(props[i]);
          }
        }
      }
    }

    evalArgNames.push(
      options.path ? options.eval + '\nreturn exports; //# sourceURL=' + options.path : options.eval);

    var evalFn = frameFunction.apply(frame.global, evalArgNames);

    var modExports = evalFn.apply(frame.global, evalArgs);

    return {
      document: frame.document,
      global: frame.global,
      iframe: frame.iframe,
      exports: modExports
    };
  }

  return frame;

}
  function earlyBoot() {

  var earlyBootStart = new Date().valueOf();

  document.write(
    '<'+'style'+' data-legit=mi>'+
    '*{display:none;background:white;color:white;}'+
    'html,body{display:block;}'+
    '</'+'style'+'>'+
    (document.body ? '' : '<body>'));

  elem(document.body, {
    height: '100%',
  	margin: 0,
    padding: 0,
    overflow: 'hidden'
  });
  elem(document.body.parentElement, {
    overflow: 'hidden'
  });

  var allStyleElements = document.getElementsByTagName('style');
  var addedStyle = allStyleElements[allStyleElements.length-1];

  var bootFrame = createFrame();
  bootFrame.iframe.style.zIndex = 2000;
  bootFrame.iframe.style.display = 'block';

  bootFrame.global.elem = elem;

  var bootAPI = bootUI(bootFrame.document, bootFrame.global, function elemProxy(a,b,c) { return bootFrame.global.elem(a,b,c); });
  bootFrame.api = bootAPI;
  bootFrame.startTime = earlyBootStart;

  var uniqueKey = deriveUniqueKey(location);

  var shellLoaderInstance = null;
	var shellLoadInterval = setInterval(function() {
    if (!shellLoadInterval) return; // protect against old Opera's super-async habits
    shellLoaderInstance = shellLoaderInstance ? shellLoaderInstance.continueLoading() : shellLoader ? shellLoader(uniqueKey, document, bootFrame) : null;
  }, 100);

  window.onload = function() {

    clearInterval(shellLoadInterval);
    shellLoadInterval = 0;

    removeSpyElements();
    bootFrame.iframe.style.zIndex = 1000;
    if (addedStyle.parentElement)
    	addedStyle.parentElement.removeChild(addedStyle);
    bootFrame.iframe.style.display = '';

    (shellLoaderInstance || shellLoader(uniqueKey, document, bootFrame)).finishLoading();

  };

  function deriveUniqueKey(locationSeed) {
    var key = (locationSeed + '').split('?')[0].split('#')[0].toLowerCase();

    var posIndexTrail = key.search(/\/index\.html$/);
    if (posIndexTrail>0) key = key.slice(0, posIndexTrail);

    if (key.charAt(0) === '/')
      key = key.slice(1);
    if (key.slice(-1) === '/')
      key = key.slice(0, key.length - 1);

    return smallHash(key) + '-' + smallHash(key.slice(1) + 'a');

    function smallHash(key) {
      for (var h=0, i=0; i < key.length; i++) {
        h = Math.pow(31, h + 31 / key.charCodeAt(i));
        h -= h | 0;
      }
      return (h * 2000000000) | 0;
    }

  }

  function removeSpyElements() {

    removeElements('iframe', function(ifr) { return ifr !== bootFrame.iframe; });
    removeElements('style', function(sty) { return sty.getAttribute('data-legit') !== 'mi'; });
    removeElements('script', function(sty) { return sty.getAttribute('data-legit') !== 'mi'; });

    function removeElements(tagName, predicateToRemove) {
    	var list = document.getElementsByTagName(tagName);
      for (var i = 0; i < list.length; i++) {
        var elem = list[i] || list.item(i);
        if (predicateToRemove(elem)) {
          elem.parentElement.removeChild(elem);
          i--;
        }
      }
    }
  }

}
  function bootUI(document, window, elem) {

  elem(document.body, {
    background: 'black'
  });
  elem('div', {
    background: 'rgb(3,11,61)',
    height: '90%'
  }, document.body);

  var header = elem('h2', { text: 'Loading...' }, document.body);

  return {
    loaded: function() {
      setText(header, 'Loaded.');
    }
  };
}
//# sourceURL=boot/*.js
</script>
<script data-legit=mi>
function shellLoader(uniqueKey, document, boot) {
    var driveMount = persistence.bootMount(uniqueKey, document);
    return continueLoading();
    function continueLoading() {
        driveMount.continueLoading();
        return { continueLoading: continueLoading, finishLoading: finishLoading };
    }
    function finishLoading() {
        driveMount.finishLoading(function (drive) {
            var uiframe = createFrame();
            uiframe.iframe.style.opacity = '0';
            var wasResized = false;
            var resizeHandlers = [];
            elem.on(window, 'resize', global_resize);
            elem.on(document.body, 'resize', global_resize);
            shell_elem.on = elem.on;
            shell_elem.off = elem.off;
            loadMod({
                path: '/shell/start.js',
                eval: drive.read('/shell/start.js'),
                ui: false,
                scope: {
                    require: shell_require,
                    document: uiframe.document,
                    window: uiframe.global,
                    console: console,
                    elem: shell_elem
                }
            });
            function shell_require(moduleName) {
                switch (moduleName) {
                    case 'ui': return uiframe;
                    case 'drive': return drive;
                    case 'resize': return { on: onresize, off: offresize };
                }
                if ((moduleName + '').charAt(0) === '.') {
                    moduleName = '/shell/' + moduleName.slice(2);
                }
                var code = drive.read(moduleName);
                if (code) {
                    var mod = loadMod({
                        eval: code,
                        path: persistence.normalizePath(moduleName),
                        ui: false,
                        scope: { require: shell_require }
                    });
                    return mod.exports;
                }
            }
            function shell_elem(x, y, z) { return uiframe.global.elem(x, y, z); }
            function onresize(handler) {
                if (typeof handler !== 'function')
                    return;
                resizeHandlers.push(handler);
            }
            function offresize(handler) {
                if (typeof handler !== 'function')
                    return;
                for (var i = 0; i < resizeHandlers.length; i++) {
                    if (resizeHandlers[i] === handler) {
                        resizeHandlers.splice(i, 1);
                    }
                }
            }
            function global_resize() {
                if (wasResized)
                    return;
                wasResized = true;
                if (requestAnimationFrame) {
                    requestAnimationFrame(global_resize_delayed);
                }
                else {
                    setTimeout(global_resize_delayed, 1);
                }
            }
            function global_resize_delayed() {
                var metrics = {
                    windowWidth: window.innerWidth || document.body.parentElement.clientWidth || document.body.clientWidth,
                    windowHeight: window.innerHeight || document.body.parentElement.clientHeight || document.body.clientHeight
                };
                wasResized = false;
                for (var i = 0; i < resizeHandlers.length; i++) {
                    var f = resizeHandlers[i];
                    if (f)
                        f(metrics);
                }
            }
            var start = new Date().valueOf();
            var fadeintTime = Math.min(500, (new Date().valueOf() - boot.startTime) * 0.9);
            var animateFadeIn = setInterval(function () {
                var passed = new Date().valueOf() - start;
                var opacity = Math.min(passed, fadeintTime) / fadeintTime;
                boot.iframe.style.opacity = (1 - opacity).toString();
                uiframe.iframe.style.opacity = '1';
                if (passed >= fadeintTime) {
                    clearInterval(animateFadeIn);
                    if (boot.iframe.parentElement)
                        boot.iframe.parentElement.removeChild(boot.iframe);
                }
            }, 10);
            if (typeof console !== 'undefined' && console.log)
                console.log(window['dbgDrive'] = drive);
        });
    }
}
var persistence;
(function (persistence) {
    function getIndexedDB() {
        try {
            return typeof indexedDB === 'undefined' || typeof indexedDB.open !== 'function' ? null : indexedDB;
        }
        catch (error) {
            return null;
        }
    }
    var attached;
    (function (attached) {
        var indexedDB;
        (function (indexedDB) {
            indexedDB.name = 'indexedDB';
            function detect(uniqueKey, callback) {
                try {
                    detectCore(uniqueKey, callback);
                }
                catch (error) {
                    callback(null);
                }
            }
            indexedDB.detect = detect;
            function detectCore(uniqueKey, callback) {
                var indexedDBInstance = getIndexedDB();
                if (!indexedDBInstance) {
                    callback(null);
                    return;
                }
                var dbName = uniqueKey || 'portabled';
                var openRequest = indexedDBInstance.open(dbName, 1);
                openRequest.onerror = function (errorEvent) { return callback(null); };
                openRequest.onupgradeneeded = createDBAndTables;
                openRequest.onsuccess = function (event) {
                    var db = openRequest.result;
                    try {
                        var transaction = db.transaction(['files', 'metadata']);
                        // files mentioned here, but not really used to detect
                        // broken multi-store transaction implementation in Safari
                        transaction.onerror = function (errorEvent) { return callback(null); };
                        var metadataStore = transaction.objectStore('metadata');
                        var filesStore = transaction.objectStore('files');
                        var editedUTCRequest = metadataStore.get('editedUTC');
                    }
                    catch (getStoreError) {
                        callback(null);
                        return;
                    }
                    if (!editedUTCRequest) {
                        callback(null);
                        return;
                    }
                    editedUTCRequest.onerror = function (errorEvent) {
                        var detached = new IndexedDBDetached(db, null);
                        callback(detached);
                    };
                    editedUTCRequest.onsuccess = function (event) {
                        var result = editedUTCRequest.result;
                        var detached = new IndexedDBDetached(db, result && typeof result.value === 'number' ? result.value : null);
                        callback(detached);
                    };
                };
                function createDBAndTables() {
                    var db = openRequest.result;
                    var filesStore = db.createObjectStore('files', { keyPath: 'path' });
                    var metadataStore = db.createObjectStore('metadata', { keyPath: 'property' });
                }
            }
            var IndexedDBDetached = (function () {
                function IndexedDBDetached(_db, timestamp) {
                    this._db = _db;
                    this.timestamp = timestamp;
                }
                IndexedDBDetached.prototype.applyTo = function (mainDrive, callback) {
                    var _this = this;
                    var transaction = this._db.transaction(['files', 'metadata'], 'readwrite');
                    var metadataStore = transaction.objectStore('metadata');
                    var filesStore = transaction.objectStore('files');
                    var countRequest = filesStore.count();
                    countRequest.onerror = function (errorEvent) {
                        console.error('Could not count files store.');
                        callback(null);
                    };
                    countRequest.onsuccess = function (event) {
                        var storeCount = countRequest.result;
                        var cursorRequest = filesStore.openCursor();
                        cursorRequest.onerror = function (errorEvent) { return callback(null); };
                        // to cleanup any files which content is the same on the main drive
                        var deleteList = [];
                        var anyLeft = false;
                        var processedCount = 0;
                        cursorRequest.onsuccess = function (event) {
                            var cursor = cursorRequest.result;
                            if (!cursor) {
                                // cleaning up files whose content is duplicating the main drive
                                if (anyLeft) {
                                    for (var i = 0; i < deleteList.length; i++) {
                                        filesStore['delete'](deleteList[i]);
                                    }
                                }
                                else {
                                    filesStore.clear();
                                    metadataStore.clear();
                                }
                                callback(new IndexedDBShadow(_this._db, _this.timestamp));
                                return;
                            }
                            if (callback.progress)
                                callback.progress(processedCount, storeCount);
                            processedCount++;
                            var result = cursor.value;
                            if (result && result.path) {
                                var existingContent = mainDrive.read(result.path);
                                if (existingContent === result.content) {
                                    deleteList.push(result.path);
                                }
                                else {
                                    mainDrive.timestamp = _this.timestamp;
                                    mainDrive.write(result.path, result.content);
                                    anyLeft = true;
                                }
                            }
                            cursor['continue']();
                        }; // cursorRequest.onsuccess
                    }; // countRequest.onsuccess
                };
                IndexedDBDetached.prototype.purge = function (callback) {
                    var transaction = this._db.transaction(['files', 'metadata'], 'readwrite');
                    var filesStore = transaction.objectStore('files');
                    filesStore.clear();
                    var metadataStore = transaction.objectStore('metadata');
                    metadataStore.clear();
                    callback(new IndexedDBShadow(this._db, -1));
                };
                return IndexedDBDetached;
            })();
            var IndexedDBShadow = (function () {
                function IndexedDBShadow(_db, timestamp) {
                    this._db = _db;
                    this.timestamp = timestamp;
                }
                IndexedDBShadow.prototype.write = function (file, content) {
                    var transaction = this._db.transaction(['files', 'metadata'], 'readwrite');
                    var filesStore = transaction.objectStore('files');
                    var metadataStore = transaction.objectStore('metadata');
                    // no file deletion here: we need to keep account of deletions too!
                    var fileData = {
                        path: file,
                        content: content,
                        state: null
                    };
                    var putFile = filesStore.put(fileData);
                    var md = {
                        property: 'editedUTC',
                        value: Date.now()
                    };
                    metadataStore.put(md);
                };
                return IndexedDBShadow;
            })();
        })(indexedDB = attached.indexedDB || (attached.indexedDB = {}));
    })(attached = persistence.attached || (persistence.attached = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function getLocalStorage() {
        return typeof localStorage === 'undefined' || typeof localStorage.length !== 'number' ? null : localStorage;
    }
    // is it OK&
    var attached;
    (function (attached) {
        var localStorage;
        (function (localStorage) {
            localStorage.name = 'localStorage';
            function detect(uniqueKey, callback) {
                var localStorageInstance = getLocalStorage();
                if (!localStorageInstance) {
                    callback(null);
                    return;
                }
                var access = new LocalStorageAccess(localStorageInstance, uniqueKey);
                var dt = new LocalStorageDetached(access);
                callback(dt);
            }
            localStorage.detect = detect;
            var LocalStorageAccess = (function () {
                function LocalStorageAccess(_localStorage, _prefix) {
                    this._localStorage = _localStorage;
                    this._prefix = _prefix;
                    this._cache = {};
                }
                LocalStorageAccess.prototype.get = function (key) {
                    var k = this._expandKey(key);
                    var r = this._localStorage.getItem(k);
                    return r;
                };
                LocalStorageAccess.prototype.set = function (key, value) {
                    var k = this._expandKey(key);
                    return this._localStorage.setItem(k, value);
                };
                LocalStorageAccess.prototype.remove = function (key) {
                    var k = this._expandKey(key);
                    return this._localStorage.removeItem(k);
                };
                LocalStorageAccess.prototype.keys = function () {
                    var result = [];
                    var len = this._localStorage.length;
                    for (var i = 0; i < len; i++) {
                        var str = this._localStorage.key(i);
                        if (str.length > this._prefix.length && str.slice(0, this._prefix.length) === this._prefix)
                            result.push(str.slice(this._prefix.length));
                    }
                    return result;
                };
                LocalStorageAccess.prototype._expandKey = function (key) {
                    var k;
                    if (!key) {
                        k = this._prefix;
                    }
                    else {
                        k = this._cache[key];
                        if (!k)
                            this._cache[key] = k = this._prefix + key;
                    }
                    return k;
                };
                return LocalStorageAccess;
            })();
            var LocalStorageDetached = (function () {
                function LocalStorageDetached(_access) {
                    this._access = _access;
                    this.timestamp = 0;
                    var timestampStr = this._access.get('*timestamp');
                    if (timestampStr && timestampStr.charAt(0) >= '0' && timestampStr.charAt(0) <= '9') {
                        try {
                            this.timestamp = parseInt(timestampStr);
                        }
                        catch (parseError) {
                        }
                    }
                }
                LocalStorageDetached.prototype.applyTo = function (mainDrive, callback) {
                    var keys = this._access.keys();
                    for (var i = 0; i < keys.length; i++) {
                        var k = keys[i];
                        if (k.charAt(0) === '/') {
                            var value = this._access.get(k);
                            mainDrive.write(k, value);
                        }
                    }
                    var shadow = new LocalStorageShadow(this._access, mainDrive.timestamp);
                    callback(shadow);
                };
                LocalStorageDetached.prototype.purge = function (callback) {
                    var keys = this._access.keys();
                    for (var i = 0; i < keys.length; i++) {
                        var k = keys[i];
                        if (k.charAt(0) === '/') {
                            var value = this._access.remove(k);
                        }
                    }
                    var shadow = new LocalStorageShadow(this._access, this.timestamp);
                    callback(shadow);
                };
                return LocalStorageDetached;
            })();
            var LocalStorageShadow = (function () {
                function LocalStorageShadow(_access, timestamp) {
                    this._access = _access;
                    this.timestamp = timestamp;
                }
                LocalStorageShadow.prototype.write = function (file, content) {
                    this._access.set(file, content);
                    this._access.set('*timestamp', this.timestamp);
                };
                return LocalStorageShadow;
            })();
        })(localStorage = attached.localStorage || (attached.localStorage = {}));
    })(attached = persistence.attached || (persistence.attached = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function getOpenDatabase() {
        return typeof openDatabase !== 'function' ? null : openDatabase;
    }
    var attached;
    (function (attached) {
        var webSQL;
        (function (webSQL) {
            webSQL.name = 'webSQL';
            function detect(uniqueKey, callback) {
                var openDatabaseInstance = getOpenDatabase();
                if (!openDatabaseInstance) {
                    callback(null);
                    return;
                }
                var dbName = uniqueKey || 'portabled';
                var db = openDatabase(dbName, 1, 'Portabled virtual filesystem data', 1024 * 1024); // size
                // upgradeCallback?
                db.readTransaction(function (transaction) {
                    transaction.executeSql('SELECT value from "*metadata" WHERE name=\'editedUTC\'', [], function (transaction, result) {
                        var editedValue = null;
                        if (result.rows && result.rows.length === 1) {
                            var editedValueStr = result.rows.item(0).value;
                            if (typeof editedValueStr === 'string') {
                                try {
                                    editedValue = parseInt(editedValueStr);
                                }
                                catch (error) {
                                }
                            }
                            else if (typeof editedValueStr === 'number') {
                                editedValue = editedValueStr;
                            }
                        }
                        callback(new WebSQLDetached(db, editedValue || 0, true));
                    }, function (transaction, sqlError) {
                        // no data
                        callback(new WebSQLDetached(db, 0, false));
                    });
                }, function (sqlError) {
                    // failed to load
                    callback(null);
                });
            }
            webSQL.detect = detect;
            var WebSQLDetached = (function () {
                function WebSQLDetached(_db, timestamp, _metadataTableIsValid) {
                    this._db = _db;
                    this.timestamp = timestamp;
                    this._metadataTableIsValid = _metadataTableIsValid;
                }
                WebSQLDetached.prototype.applyTo = function (mainDrive, callback) {
                    var _this = this;
                    this._db.readTransaction(function (transaction) { return listAllTables(transaction, function (tables) {
                        var ftab = getFilenamesFromTables(tables);
                        _this._applyToWithFiles(transaction, ftab, mainDrive, callback);
                    }, function (sqlError) {
                        reportSQLError('Failed to list tables for the webSQL database.', sqlError);
                        callback(new WebSQLShadow(_this._db, _this.timestamp, _this._metadataTableIsValid));
                    }); }, function (sqlError) {
                        reportSQLError('Failed to open read transaction for the webSQL database.', sqlError);
                        callback(new WebSQLShadow(_this._db, _this.timestamp, _this._metadataTableIsValid));
                    });
                };
                WebSQLDetached.prototype.purge = function (callback) {
                    var _this = this;
                    this._db.transaction(function (transaction) { return listAllTables(transaction, function (tables) {
                        _this._purgeWithTables(transaction, tables, callback);
                    }, function (sqlError) {
                        reportSQLError('Failed to list tables for the webSQL database.', sqlError);
                        callback(new WebSQLShadow(_this._db, 0, false));
                    }); }, function (sqlError) {
                        reportSQLError('Failed to open read-write transaction for the webSQL database.', sqlError);
                        callback(new WebSQLShadow(_this._db, 0, false));
                    });
                };
                WebSQLDetached.prototype._applyToWithFiles = function (transaction, ftab, mainDrive, callback) {
                    var _this = this;
                    if (!ftab.length) {
                        callback(new WebSQLShadow(this._db, this.timestamp, this._metadataTableIsValid));
                        return;
                    }
                    var reportedFileCount = 0;
                    var completeOne = function () {
                        reportedFileCount++;
                        if (reportedFileCount === ftab.length) {
                            callback(new WebSQLShadow(_this._db, _this.timestamp, _this._metadataTableIsValid));
                        }
                    };
                    var applyFile = function (file, table) {
                        transaction.executeSql('SELECT * FROM "' + table + '"', [], function (transaction, result) {
                            if (result.rows.length) {
                                var row = result.rows.item(0);
                                if (row.value === null)
                                    mainDrive.write(file, null);
                                else if (typeof row.value === 'string')
                                    mainDrive.write(file, fromSqlText(row.value));
                            }
                            completeOne();
                        }, function (sqlError) {
                            completeOne();
                        });
                    };
                    for (var i = 0; i < ftab.length; i++) {
                        applyFile(ftab[i].file, ftab[i].table);
                    }
                };
                WebSQLDetached.prototype._purgeWithTables = function (transaction, tables, callback) {
                    var _this = this;
                    if (!tables.length) {
                        callback(new WebSQLShadow(this._db, 0, false));
                        return;
                    }
                    var droppedCount = 0;
                    var completeOne = function () {
                        droppedCount++;
                        if (droppedCount === tables.length) {
                            callback(new WebSQLShadow(_this._db, 0, false));
                        }
                    };
                    for (var i = 0; i < tables.length; i++) {
                        transaction.executeSql('DROP TABLE "' + tables[i] + '"', [], function (transaction, result) {
                            completeOne();
                        }, function (transaction, sqlError) {
                            reportSQLError('Failed to drop table for the webSQL database.', sqlError);
                            completeOne();
                        });
                    }
                };
                return WebSQLDetached;
            })();
            var WebSQLShadow = (function () {
                function WebSQLShadow(_db, timestamp, _metadataTableIsValid) {
                    var _this = this;
                    this._db = _db;
                    this.timestamp = timestamp;
                    this._metadataTableIsValid = _metadataTableIsValid;
                    this._cachedUpdateStatementsByFile = {};
                    this._closures = {
                        updateMetadata: function (transaction) { return _this._updateMetadata(transaction); }
                    };
                }
                WebSQLShadow.prototype.write = function (file, content) {
                    if (content || typeof content === 'string') {
                        this._updateCore(file, content);
                    }
                    else {
                        this._dropFileTable(file);
                    }
                };
                WebSQLShadow.prototype._updateCore = function (file, content) {
                    var _this = this;
                    var updateSQL = this._cachedUpdateStatementsByFile[file];
                    if (!updateSQL) {
                        var tableName = mangleDatabaseObjectName(file);
                        updateSQL = this._createUpdateStatement(file, tableName);
                    }
                    this._db.transaction(function (transaction) {
                        transaction.executeSql(updateSQL, ['content', content], _this._closures.updateMetadata, function (transaction, sqlError) { return _this._createTableAndUpdate(transaction, file, tableName, updateSQL, content); });
                    }, function (sqlError) {
                        reportSQLError('Transaction failure updating file "' + file + '".', sqlError);
                    });
                };
                WebSQLShadow.prototype._createTableAndUpdate = function (transaction, file, tableName, updateSQL, content) {
                    var _this = this;
                    if (!tableName)
                        tableName = mangleDatabaseObjectName(file);
                    transaction.executeSql('CREATE TABLE "' + tableName + '" (name PRIMARY KEY, value)', [], function (transaction, result) {
                        transaction.executeSql(updateSQL, ['content', content], _this._closures.updateMetadata, function (transaction, sqlError) {
                            reportSQLError('Failed to update table "' + tableName + '" for file "' + file + '" after creation.', sqlError);
                        });
                    }, function (transaction, sqlError) {
                        reportSQLError('Failed to create a table "' + tableName + '" for file "' + file + '".', sqlError);
                    });
                };
                WebSQLShadow.prototype._dropFileTable = function (file) {
                    var _this = this;
                    var tableName = mangleDatabaseObjectName(file);
                    this._db.transaction(function (transaction) {
                        transaction.executeSql('DROP TABLE "' + tableName + '"', [], _this._closures.updateMetadata, function (transaction, sqlError) {
                            reportSQLError('Failed to drop table "' + tableName + '" for file "' + file + '".', sqlError);
                        });
                    }, function (sqlError) {
                        reportSQLError('Transaction failure dropping table "' + tableName + '" for file "' + file + '".', sqlError);
                    });
                };
                WebSQLShadow.prototype._updateMetadata = function (transaction) {
                    var updateMetadataSQL = 'INSERT OR REPLACE INTO "*metadata" VALUES (?,?)';
                    transaction.executeSql(updateMetadataSQL, ['editedUTC', this.timestamp], function (transaction, result) { }, function (transaction, error) {
                        transaction.executeSql('CREATE TABLE "*metadata" (name PRIMARY KEY, value)', [], function (transaction, result) {
                            transaction.executeSql(updateMetadataSQL, [], function () { }, function () { });
                        }, function (transaction, sqlError) {
                            reportSQLError('Failed to update metadata table after creation.', sqlError);
                        });
                    });
                };
                WebSQLShadow.prototype._createUpdateStatement = function (file, tableName) {
                    return this._cachedUpdateStatementsByFile[file] =
                        'INSERT OR REPLACE INTO "' + tableName + '" VALUES (?,?)';
                };
                return WebSQLShadow;
            })();
            function mangleDatabaseObjectName(name) {
                // no need to polyfill btoa, if webSQL exists
                if (name.toLowerCase() === name)
                    return name;
                else
                    return '=' + btoa(name);
            }
            function unmangleDatabaseObjectName(name) {
                if (!name || name.charAt(0) === '*')
                    return null;
                if (name.charAt(0) !== '=')
                    return name;
                try {
                    return atob(name.slice(1));
                }
                catch (error) {
                    return name;
                }
            }
            function listAllTables(transaction, callback, errorCallback) {
                transaction.executeSql('SELECT tbl_name  from sqlite_master WHERE type=\'table\'', [], function (transaction, result) {
                    var tables = [];
                    for (var i = 0; i < result.rows.length; i++) {
                        var row = result.rows.item(i);
                        var table = row.tbl_name;
                        if (!table || (table[0] !== '*' && table.charAt(0) !== '=' && table.charAt(0) !== '/'))
                            continue;
                        tables.push(row.tbl_name);
                    }
                    callback(tables);
                }, function (transaction, sqlError) { return errorCallback(sqlError); });
            }
            webSQL.listAllTables = listAllTables;
            function getFilenamesFromTables(tables) {
                var filenames = [];
                for (var i = 0; i < tables.length; i++) {
                    var file = unmangleDatabaseObjectName(tables[i]);
                    if (file)
                        filenames.push({ table: tables[i], file: file });
                }
                return filenames;
            }
            function toSqlText(text) {
                if (text.indexOf('\u00FF') < 0 && text.indexOf('\u0000') < 0)
                    return text;
                return text.replace(/\u00FF/g, '\u00FFf').replace(/\u0000/g, '\u00FF0');
            }
            function fromSqlText(sqlText) {
                if (sqlText.indexOf('\u00FF') < 0 && sqlText.indexOf('\u0000') < 0)
                    return sqlText;
                return sqlText.replace(/\u00FFf/g, '\u00FF').replace(/\u00FF0/g, '\u0000');
            }
            function reportSQLError(message, sqlError) {
                if (typeof console !== 'undefined' && typeof console.error === 'function') {
                    if (sqlError)
                        console.error(message, sqlError);
                    else
                        console.error(sqlError);
                }
            }
        })(webSQL = attached.webSQL || (attached.webSQL = {}));
    })(attached = persistence.attached || (persistence.attached = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function bestEncode(content, escapePath) {
        if (content.length > 1024 * 16) {
        }
        if (typeof content !== 'string')
            return { content: encodeArrayOrSimilarAsJSON(content), encoding: 'json' };
        var needsEscaping;
        if (escapePath) {
            // zero-char, newlines, leading/trailing spaces, quote and apostrophe
            needsEscaping = /\u0000|\r|\n|^\s|\s$|\"|\'/.test(content);
        }
        else {
            needsEscaping = /\u0000|\r/.test(content);
        }
        if (needsEscaping) {
            // ZERO character is officially unsafe in HTML,
            // CR is contentious in IE (which converts any CR or LF into CRLF)
            return { content: encodeUnusualStringAsJSON(content), encoding: 'json' };
        }
        else {
            return { content: content, encoding: 'LF' };
        }
    }
    persistence.bestEncode = bestEncode;
    function encodeUnusualStringAsJSON(content) {
        if (typeof JSON !== 'undefined' && typeof JSON.stringify === 'function') {
            var simpleJSON = JSON.stringify(content);
            var sanitizedJSON = simpleJSON.
                replace(/\u0000/g, '\\u0000').
                replace(/\r/g, '\\r').
                replace(/\n/g, '\\n');
            return sanitizedJSON;
        }
        else {
            var result = content.replace(/\"\u0000|\u0001|\u0002|\u0003|\u0004|\u0005|\u0006|\u0007|\u0008|\u0009|\u00010|\u00011|\u00012|\u00013|\u00014|\u00015|\u0016|\u0017|\u0018|\u0019|\u0020|\u0021|\u0022|\u0023|\u0024|\u0025|\u0026|\u0027|\u0028|\u0029|\u0030|\u0031/g, function (chr) {
                return chr === '\t' ? '\\t' :
                    chr === '\r' ? '\\r' :
                        chr === '\n' ? '\\n' :
                            chr === '\"' ? '\\"' :
                                chr < '\u0010' ? '\\u000' + chr.charCodeAt(0).toString(16) :
                                    '\\u00' + chr.charCodeAt(0).toString(16);
            });
            return result;
        }
    }
    function encodeArrayOrSimilarAsJSON(content) {
        var type = content instanceof Array ? null : content.constructor.name || content.type;
        if (typeof JSON !== 'undefined' && typeof JSON.stringify === 'function') {
            if (type) {
                var wrapped = { type: type, content: content };
                var wrappedJSON = JSON.stringify(wrapped);
                return wrappedJSON;
            }
            else {
                var contentJSON = JSON.stringify(content);
                return contentJSON;
            }
        }
        else {
            var jsonArr = [];
            if (type) {
                jsonArr.push('{"type": "');
                jsonArr.push(content.type || content.prototype.constructor.name);
                jsonArr.push('", "content": [');
            }
            else {
                jsonArr.push('[');
            }
            for (var i = 0; i < content.length; i++) {
                if (i)
                    jsonArr.push(',');
                jsonArr.push(content[i]);
            }
            if (type)
                jsonArr.push(']}');
            else
                jsonArr.push(']');
            return jsonArr.join('');
        }
    }
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    // TODO: pass in progress callback
    function bootMount(uniqueKey, document) {
        var continueParse;
        var ondomdriveloaded;
        var domDriveLoaded;
        var storedFinishCallback;
        persistence.mountDrive(function (callback) {
            if (domDriveLoaded)
                callback(domDriveLoaded);
            else
                ondomdriveloaded = callback;
        }, uniqueKey, [persistence.attached.indexedDB, persistence.attached.webSQL, persistence.attached.localStorage], function (mountedDrive) {
            storedFinishCallback(mountedDrive);
        });
        return continueLoading();
        function continueLoading() {
            continueDOMLoading();
            // TODO: record progress
            return { continueLoading: continueLoading, finishLoading: finishLoading };
        }
        function finishLoading(finishCallback) {
            storedFinishCallback = finishCallback;
            continueDOMLoading();
            domDriveLoaded = continueParse.finishParsing();
            if (ondomdriveloaded) {
                ondomdriveloaded(domDriveLoaded);
            }
        }
        function continueDOMLoading() {
            continueParse = continueParse ? continueParse.continueParsing() : persistence.dom.parseDOMStorage(document);
        }
    }
    persistence.bootMount = bootMount;
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        var CommentHeader = (function () {
            function CommentHeader(node) {
                this.node = node;
                var headerLine;
                var content;
                if (typeof node.substringData === 'function'
                    && typeof node.length === 'number') {
                    var chunkSize = 128;
                    if (node.length >= chunkSize) {
                        // TODO: cut chunks off the start and look for newlines
                        var headerChunks = [];
                        while (headerChunks.length * chunkSize < node.length) {
                            var nextChunk = node.substringData(headerChunks.length * chunkSize, chunkSize);
                            var posEOL = nextChunk.search(/\r|\n/);
                            if (posEOL < 0) {
                                headerChunks.push(nextChunk);
                                continue;
                            }
                            this.header = headerChunks.join('') + nextChunk.slice(0, posEOL);
                            this.contentOffset = this.header.length + 1; // if header is separated by a single CR or LF
                            if (posEOL === nextChunk.length - 1) {
                                if (nextChunk.charAt(nextChunk.length - 1) === '\r'
                                    && node.substringData((headerChunks.length + 1) * chunkSize, 1) === '\n')
                                    this.contentOffset++;
                            }
                            else if (nextChunk.slice(posEOL, posEOL + 2) === '\r\n') {
                                this.contentOffset++;
                            }
                            this.contentLength = node.length - this.contentOffset;
                            return;
                        }
                        this.header = headerChunks.join('');
                        this.contentOffset = this.header.length;
                        this.contentLength = node.length - content.length;
                        return;
                    }
                }
                var wholeCommentText = node.nodeValue;
                var posEOL = wholeCommentText.search(/\r|\n/);
                if (posEOL < 0) {
                    this.header = wholeCommentText;
                    this.contentOffset = wholeCommentText.length;
                    this.contentLength = wholeCommentText.length - this.contentOffset;
                    return;
                }
                this.contentOffset = wholeCommentText.slice(posEOL, posEOL + 2) === '\r\n' ?
                    posEOL + 2 :
                    posEOL + 1; // ends with singular CR or LF
                this.header = wholeCommentText.slice(0, posEOL),
                    this.contentLength = wholeCommentText.length - this.contentOffset;
            }
            return CommentHeader;
        })();
        dom.CommentHeader = CommentHeader;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        var DOMDrive = (function () {
            function DOMDrive(_totals, files, _document) {
                this._totals = _totals;
                this._document = _document;
                this._byPath = {};
                this.timestamp = this._totals ? this._totals.timestamp : 0;
                for (var i = 0; i < files.length; i++) {
                    this._byPath[files[i].path] = files[i];
                }
            }
            DOMDrive.prototype.files = function () {
                if (typeof Object.keys === 'string') {
                    var result = Object.keys(this._byPath);
                }
                else {
                    var result = [];
                    for (var k in this._byPath)
                        if (this._byPath.hasOwnProperty(k)) {
                            result.push(k);
                        }
                }
                result.sort();
                return result;
            };
            DOMDrive.prototype.read = function (file) {
                var file = persistence.normalizePath(file);
                var f = this._byPath[file];
                if (!f)
                    return null;
                else
                    return f.read();
            };
            DOMDrive.prototype.write = function (file, content) {
                var totalDelta = 0;
                var file = persistence.normalizePath(file);
                var f = this._byPath[file];
                if (content === null) {
                    // removal
                    if (f) {
                        totalDelta -= f.contentLength;
                        f.node.parentElement.removeChild(f.node);
                        delete this._byPath[file];
                    }
                }
                else {
                    // addition
                    if (f) {
                        var lengthBefore = f.contentLength;
                        f.write(content);
                        totalDelta += f.contentLength - lengthBefore;
                    }
                    else {
                        var comment = document.createComment('');
                        var f = new dom.DOMFile(comment, file, null, 0, 0);
                        f.write(content);
                        this._document.body.appendChild(f.node);
                        totalDelta += f.contentLength;
                    }
                }
                this._totals.timestamp = this.timestamp;
                this._totals.updateNode();
            };
            return DOMDrive;
        })();
        dom.DOMDrive = DOMDrive;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        var DOMFile = (function () {
            function DOMFile(node, path, _encoding, _contentOffset, contentLength) {
                this.node = node;
                this.path = path;
                this._encoding = _encoding;
                this._contentOffset = _contentOffset;
                this.contentLength = contentLength;
                this._encodedPath = null;
            }
            DOMFile.tryParse = function (cmheader) {
                //    /file/path/continue
                //    "/file/path/continue"
                //    /file/path/continue   [encoding]
                var parseFmt = /^\s*((\/|\"\/)(\s|\S)*[^\]])\s*(\[((\s|\S)*)\])?\s*$/;
                var parsed = parseFmt.exec(cmheader.header);
                if (!parsed)
                    return null; // does not match the format
                var filePath = parsed[1];
                var encodingName = parsed[5];
                if (filePath.charAt(0) === '"') {
                    if (filePath.charAt(filePath.length - 1) !== '"')
                        return null; // unpaired leading quote
                    try {
                        if (typeof JSON !== 'undefined' && typeof JSON.parse === 'function')
                            filePath = JSON.parse(filePath);
                        else
                            filePath = eval(filePath); // security doesn't seem to be compromised, input is coming from the same file
                    }
                    catch (parseError) {
                        return null; // quoted path but wrong format (JSON expected)
                    }
                }
                else {
                    if (encodingName) {
                        // regex above won't strip trailing whitespace from filePath if encoding is specified
                        // (because whitespace matches 'non-bracket' class too)
                        filePath = filePath.slice(0, filePath.search(/\S(\s*)$/) + 1);
                    }
                }
                var encoding = persistence.encodings[encodingName || 'LF'];
                // invalid encoding considered a bogus comment, skipped
                if (encoding)
                    return new DOMFile(cmheader.node, filePath, encoding, cmheader.contentOffset, cmheader.contentLength);
                return null;
            };
            DOMFile.prototype.read = function () {
                // proper HTML5 has substringDate to read only a chunk
                // (that saves on string memory allocations
                // comparing to fetching the whole text including the file name)
                var contentText = typeof this.node.substringData === 'function' ?
                    this.node.substringData(this._contentOffset, 1000000000) :
                    this.node.nodeValue.slice(this._contentOffset);
                // XML end-comment is escaped when stored in DOM,
                // unescape it back
                var restoredText = contentText.replace(/\-\-\*(\**)\>/g, '--*$1>');
                // decode
                var decodedText = this._encoding(restoredText);
                // update just in case it's been off
                this.contentLength = decodedText.length;
                return decodedText;
            };
            DOMFile.prototype.write = function (content) {
                var encoded = persistence.bestEncode(content);
                var protectedText = encoded.content.replace(/\-\-(\**)\>/g, '--*$1>');
                if (!this._encodedPath) {
                    // most cases path is path,
                    // but if enything is weird, it's going to be quoted
                    // (actually encoded with JSON format)
                    var encp = persistence.bestEncode(this.path, true /*escapePath*/);
                    this._encodedPath = encp.content;
                }
                var leadText = ' ' + this._encodedPath + (encoded.encoding === 'LF' ? '' : ' [' + encoded.encoding + ']') + '\n';
                this.node.nodeValue = leadText + encoded.content;
                this.contentLength = content.length;
            };
            return DOMFile;
        })();
        dom.DOMFile = DOMFile;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        var monthsPrettyCase = ('Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec').split('|');
        var monthsUpperCase = ('Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec').toUpperCase().split('|');
        var DOMTotals = (function () {
            function DOMTotals(timestamp, totalSize, _node) {
                this.timestamp = timestamp;
                this.totalSize = totalSize;
                this._node = _node;
            }
            DOMTotals.tryParse = function (cmheader) {
                // TODO: preserve unknowns when parsing
                var parts = cmheader.header.split(',');
                var anythingParsed = false;
                var totalSize = 0;
                var timestamp = 0;
                for (var i = 0; i < parts.length; i++) {
                    // total 234Kb
                    // total 23
                    // total 6Mb
                    var totalFmt = /^\s*total\s+(\d*)\s*([KkMm])?b?\s*$/;
                    var totalMatch = totalFmt.exec(parts[i]);
                    if (totalMatch) {
                        try {
                            var total = parseInt(totalMatch[1]);
                            if ((totalMatch[2] + '').toUpperCase() === 'K')
                                total *= 1024;
                            else if ((totalMatch[2] + '').toUpperCase() === 'M')
                                total *= 1024 * 1024;
                            totalSize = total;
                            anythingParsed = true;
                        }
                        catch (totalParseError) { }
                        continue;
                    }
                    var savedFmt = /^\s*saved\s+(\d+)\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+)\s+(\d+)\:(\d+)(\:(\d+(\.(\d+))?))\s*(GMT\s*[\-\+]?\d+\:?\d*)?\s*$/i;
                    var savedMatch = savedFmt.exec(parts[i]);
                    if (savedMatch) {
                        // 25 Apr 2015 22:52:01.231
                        try {
                            var savedDay = parseInt(savedMatch[1]);
                            var savedMonth = monthsUpperCase.indexOf(savedMatch[2].toUpperCase());
                            var savedYear = parseInt(savedMatch[3]);
                            if (savedYear < 100)
                                savedYear += 2000; // no 19xx notation anymore :-(
                            var savedHour = parseInt(savedMatch[4]);
                            var savedMinute = parseInt(savedMatch[5]);
                            var savedSecond = savedMatch[7] ? parseFloat(savedMatch[7]) : 0;
                            timestamp = new Date(savedYear, savedMonth, savedDay, savedHour, savedMinute, savedSecond | 0).valueOf();
                            timestamp += (savedSecond - (savedSecond | 0)) * 1000; // milliseconds
                            var savedGMTStr = savedMatch[10];
                            if (savedGMTStr) {
                                var gmtColonPos = savedGMTStr.indexOf(':');
                                if (gmtColonPos > 0) {
                                    var gmtH = parseInt(savedGMTStr.slice(0, gmtColonPos));
                                    timestamp += gmtH * 60 /*min*/ * 60 /*sec*/ * 1000 /*msec*/;
                                    var gmtM = parseInt(savedGMTStr.slice(gmtColonPos + 1));
                                    timestamp += gmtM * 60 /*sec*/ * 1000 /*msec*/;
                                }
                            }
                            anythingParsed = true;
                        }
                        catch (savedParseError) { }
                    }
                }
                if (anythingParsed)
                    return new DOMTotals(timestamp, totalSize, cmheader.node);
                else
                    return null;
            };
            DOMTotals.prototype.updateNode = function () {
                // TODO: update the node content
                // total 4Kb, saved 25 Apr 2015 22:52:01.231
                var newTotals = 'total ' + (this.totalSize < 1024 * 2 ? this.totalSize + '' :
                    this.totalSize < 1024 * 1024 * 2 ? ((this.totalSize / 1024) | 0) + 'Kb' :
                        ((this.totalSize / (1024 * 1024)) | 0) + 'Mb') + ', ' +
                    'saved ';
                var saveDate = new Date(this.timestamp);
                newTotals +=
                    saveDate.getDate() + ' ' +
                        monthsPrettyCase[saveDate.getMonth()] + ' ' +
                        saveDate.getFullYear() + ' ' +
                        num2(saveDate.getHours()) + ':' +
                        num2(saveDate.getMinutes()) + ':' +
                        num2(saveDate.getSeconds()) + '.' +
                        this.timestamp.toString().slice(-3);
                var saveDateLocalStr = saveDate.toString();
                var gmtMatch = (/(GMT\s*[\-\+]\d+(\:\d+)?)/i).exec(saveDateLocalStr);
                if (gmtMatch)
                    newTotals += ' ' + gmtMatch[1];
                this._node.nodeValue = newTotals;
                function num2(n) {
                    return n <= 9 ? '0' + n : '' + n;
                }
            };
            return DOMTotals;
        })();
        dom.DOMTotals = DOMTotals;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var dom;
    (function (dom) {
        function parseDOMStorage(document) {
            var loadedFiles = [];
            var loadedTotals;
            var lastNode;
            var loadedSize = 0;
            return continueParsing();
            function continueParsing() {
                continueParsingDOM(false);
                return {
                    continueParsing: continueParsing,
                    finishParsing: finishParsing,
                    loadedSize: loadedSize,
                    totalSize: loadedTotals ? loadedTotals.totalSize : 0,
                    loadedFileCount: loadedFiles.length
                };
            }
            function finishParsing() {
                continueParsingDOM(true);
                if (loadedTotals) {
                    loadedTotals.totalSize = loadedSize;
                    loadedTotals.updateNode();
                }
                var drive = new dom.DOMDrive(loadedTotals, loadedFiles, document);
                return drive;
            }
            function continueParsingDOM(finish) {
                if (document.body) {
                    if (!lastNode)
                        lastNode = document.body.firstChild;
                    while (true) {
                        if (!lastNode)
                            return;
                        else if (!finish && lastNode == document.body.lastChild)
                            return;
                        if (lastNode.nodeType === 8) {
                            processNode(lastNode);
                        }
                        lastNode = lastNode.nextSibling;
                    }
                }
            }
            function processNode(node) {
                var cmheader = new dom.CommentHeader(node);
                var file = dom.DOMFile.tryParse(cmheader);
                if (file) {
                    loadedFiles.push(file);
                    loadedSize += file.contentLength;
                    return true;
                }
                var totals = dom.DOMTotals.tryParse(cmheader);
                if (totals)
                    loadedTotals = totals;
            }
        }
        dom.parseDOMStorage = parseDOMStorage;
    })(dom = persistence.dom || (persistence.dom = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function CR(text) {
            return text.
                replace(/\r\n|\n/g, '\r').
                replace(/\-\-\*(\**)\>/g, '--$1>');
        }
        encodings.CR = CR;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function CRLF(text) {
            return text.
                replace(/\r|\n/g, '\r\n').
                replace(/\-\-\*(\**)\>/g, '--$1>');
        }
        encodings.CRLF = CRLF;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function LF(text) {
            return text.
                replace(/\r\n|\r/g, '\n').
                replace(/\-\-\*(\**)\>/g, '--$1>');
        }
        encodings.LF = LF;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function base64(text) {
            // TODO: convert from base64 to text
            // TODO: invent a prefix to signify binary data
            throw new Error('Base64 encoding is not implemented yet.');
        }
        encodings.base64 = base64;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function eval(text) {
            return (0, window['eval'])(text);
        }
        encodings.eval = eval;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    var encodings;
    (function (encodings) {
        function json(text) {
            var result = typeof JSON === 'undefined' ? encodings.eval(text) : JSON.parse(text);
            if (result && typeof result !== 'string' && result.type) {
                var ctor = window[result.type];
                result = new ctor(result);
            }
            return result;
        }
        encodings.json = json;
    })(encodings = persistence.encodings || (persistence.encodings = {}));
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function mountDrive(loadDOMDrive, uniqueKey, optionalModules, callback) {
        var driveIndex = 0;
        loadNextOptional();
        function loadNextOptional() {
            while (driveIndex < optionalModules.length &&
                (!optionalModules[driveIndex] || typeof optionalModules[driveIndex].detect !== 'function')) {
                driveIndex++;
            }
            if (driveIndex >= optionalModules.length) {
                loadDOMDrive(function (dom) { return callback(new MountedDrive(dom, null)); });
                return;
            }
            var op = optionalModules[driveIndex];
            op.detect(uniqueKey, function (detached) {
                if (!detached) {
                    driveIndex++;
                    loadNextOptional();
                    return;
                }
                loadDOMDrive(function (dom) {
                    if (detached.timestamp > dom.timestamp) {
                        var callbackWithShadow = function (loadedDrive) {
                            dom.timestamp = detached.timestamp;
                            callback(new MountedDrive(dom, loadedDrive));
                        };
                        if (callback.progress)
                            callbackWithShadow.progress = callback.progress;
                        loadDOMDrive(function (dom) { return detached.applyTo(dom, callbackWithShadow); });
                    }
                    else {
                        var callbackWithShadow = function (loadedDrive) {
                            callback(new MountedDrive(dom, loadedDrive));
                        };
                        if (callback.progress)
                            callbackWithShadow.progress = callback.progress;
                        detached.purge(callbackWithShadow);
                    }
                });
            });
        }
    }
    persistence.mountDrive = mountDrive;
    var MountedDrive = (function () {
        function MountedDrive(_dom, _shadow) {
            this._dom = _dom;
            this._shadow = _shadow;
            this.timestamp = 0;
            this.timestamp = this._dom.timestamp;
        }
        MountedDrive.prototype.files = function () {
            return this._dom.files();
        };
        MountedDrive.prototype.read = function (file) {
            return this._dom.read(file);
        };
        MountedDrive.prototype.write = function (file, content) {
            this._dom.timestamp = this.timestamp;
            this._dom.write(file, content);
            if (this._shadow) {
                this._shadow.timestamp = this.timestamp;
                this._shadow.write(file, content);
            }
        };
        return MountedDrive;
    })();
})(persistence || (persistence = {}));
var persistence;
(function (persistence) {
    function normalizePath(path) {
        if (!path)
            return '/'; // empty paths converted to root
        while (' \n\t\r'.indexOf(path.charAt(0)) >= 0)
            path = path.slice(1);
        while ('\n\t\r\\'.indexOf(path.charAt(path.length - 1)) >= 0)
            path = path.slice(0, path.length - 1);
        if (path.charAt(0) !== '/')
            path = '/' + path;
        path = path.replace(/\/\/*/g, '/'); // replacing duplicate slashes with single
        return path;
    }
    persistence.normalizePath = normalizePath;
})(persistence || (persistence = {}));

//# sourceURL=typescriptBuild.ts
</script>

<!-- total 56Mb, saved 25 Apr 2015 22:52:01.231 -->

<!-- /LF-file.txt
123
456-->

<!-- /src/LF-file.txt [LF]
123
456-->

<!-- /src1/LF-file.txt
123
456-->

<!-- /CRLF-file [CRLF]
123
          4-->

<!-- /eval-file.txt [eval]
"new ok" + String.fromCharCode(Math.random()*16000)+" and what\r\n or "+String.fromCharCode(1)+"?"-->

<!-- /json-file.txt [json]
"new ok \u2222 and what\r\n or \u0001?\n\n\n"-->

<!-- /runme.js
console.log(123)-->



<!-- /shell/start.js
var CommanderShell = (function () {
    function CommanderShell(_host, _drive) {
        var _this = this;
        this._host = _host;
        this._drive = _drive;
        this._metrics = null;
        this._onsizechangedTimeout = 0;
        elem(this._host, {
            background: 'black',
            color: 'silver'
        });
        this._metricElem = elem('div', {
            position: 'absolute',
            opacity: 0,
            left: '-200px', top: '-200px',
            wdith: 'auto', height: 'auto',
            text: 'M'
        }, document.body);
        this._terminal = new terminal.Terminal(this._host);
        this._twoPanels = new panels.TwoPanels(this._host, '/', '/src', this._drive);
        var resizeMod = require('resize');
        resizeMod.on(function (winMetrics) {
            _this.measure();
            _this.arrange(winMetrics);
        });
        this.measure();
        this.arrange({
            windowWidth: document.body.offsetWidth,
            windowHeight: document.body.offsetHeight
        });
        elem.on(this._host, 'keydown', function (e) { return _this._keydown(e); });
    }
    CommanderShell.prototype.measure = function () {
        this._metrics = {
            hostWidth: 0,
            hostHeight: 0,
            emWidth: this._metricElem.offsetWidth,
            emHeight: this._metricElem.offsetHeight
        };
        this._twoPanels.measure();
        this._terminal.measure();
    };
    CommanderShell.prototype.arrange = function (winMetrics) {
        this._metrics.hostWidth = winMetrics.windowWidth;
        this._metrics.hostHeight = winMetrics.windowHeight;
        this._twoPanels.arrange(this._metrics);
        this._terminal.arrange(this._metrics);
    };
    CommanderShell.prototype._keydown = function (e) {
        if (e.keyCode === 27 && !e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
            this._twoPanels.toggle();
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
    };
    return CommanderShell;
})();
var panels;
(function (panels) {
    var Panel = (function () {
        function Panel(_host, _path, _directoryService) {
            this._host = _host;
            this._path = _path;
            this._directoryService = _directoryService;
            this._redrawRequested = 0;
            this._metrics = null;
            this._scrollContent = elem('div', {
                text: 'Loading...'
            }, this._host);
            this._queueRedraw();
        }
        Panel.prototype.currentPath = function () {
            return this._path;
        };
        Panel.prototype.selectedPath = function () {
            return this._selectedPath;
        };
        Panel.prototype.arrange = function (metrics) {
            this._metrics = metrics;
            this._queueRedraw();
        };
        Panel.prototype._queueRedraw = function () {
            var _this = this;
            if (this._redrawRequested)
                return;
            this._redrawRequested = setTimeout(function () { return _this._redrawNow(); }, 1);
        };
        Panel.prototype._redrawNow = function () {
            this._redrawRequested = 0;
            this._scrollContent.innerHTML = '';
            var entries = this._directoryService(this._path);
            if (entries) {
                entries.sort(function (e1, e2) {
                    var flagCompare = (e1.flags & Panel.EntryFlags.Directory) ?
                        ((e2.flags & Panel.EntryFlags.Directory) ? 0 : -1) :
                        ((e2.flags & Panel.EntryFlags.Directory) ? +1 : 0);
                    if (flagCompare)
                        return flagCompare;
                    var nameCompare = e1.name > e2.name ? 1 : e1.name < e2.name ? -1 : 0;
                    return nameCompare;
                });
                if (this._path !== '/') {
                    var parentPath = this._path.slice(0, this._path.lastIndexOf('/'));
                    entries.unshift({
                        name: '..',
                        path: parentPath,
                        flags: Panel.EntryFlags.Directory
                    });
                }
                var selectedPathIndex = -1;
                for (var i = 0; i < entries.length; i++) {
                    if (selectedPathIndex < 0) {
                        selectedPathIndex = 0;
                        this._selectedPath = entries.length > 0 ? entries[i].path : null;
                    }
                }
                for (var i = 0; i < entries.length; i++) {
                    this._renderEntry(entries[i], i === selectedPathIndex);
                    if (entries[i].path === this._selectedPath) {
                        selectedPathIndex = i;
                    }
                }
            }
        };
        Panel.prototype._renderEntry = function (entry, selected) {
            elem('div', {
                height: this._metrics.windowMetrics.emHeight,
                text: entry.name,
                fontWeight: (entry.flags & Panel.EntryFlags.Directory) ? 'bold' : 'normal',
                color: (entry.flags & Panel.EntryFlags.Directory) ? 'white' : selected ? 'black' : 'darkcyan',
                background: selected ? 'darkcyan' : null
            }, this._scrollContent);
        };
        return Panel;
    })();
    panels.Panel = Panel;
    var Panel;
    (function (Panel) {
        (function (EntryFlags) {
            EntryFlags[EntryFlags["Directory"] = 1] = "Directory";
        })(Panel.EntryFlags || (Panel.EntryFlags = {}));
        var EntryFlags = Panel.EntryFlags;
    })(Panel = panels.Panel || (panels.Panel = {}));
})(panels || (panels = {}));
var panels;
(function (panels) {
    var panelHMargin = 10;
    var panelVMargin = 5;
    var TwoPanels = (function () {
        function TwoPanels(_host, leftPath, rightPath, _drive) {
            this._host = _host;
            this._drive = _drive;
            this._scrollHost = elem('div', {
                position: ['absolute', 'fixed'],
                left: 0, top: 0, width: 0, height: 0,
                overflow: 'auto',
                overflowY: 'hidden',
                background: ['black', 'transparent']
            }, this._host);
            this._scrollContent = elem('div', {
                width: 0, height: 0,
                overflow: 'hidden'
            }, this._scrollHost);
            this._leftPanelHost = elem('div', {
                float: 'left',
                width: 0, height: 0,
                overflow: 'auto',
                overflowX: 'hidden',
                background: ['navy', 'rgba(4, 12, 64, 0.95)'],
                padding: panelHMargin + 'px',
                paddingTop: panelVMargin + 'px',
                paddingBottom: panelVMargin + 'px'
            }, this._scrollContent);
            this._rightPanelHost = elem('div', {
                float: 'right',
                width: 0, height: 0,
                overflow: 'auto',
                overflowX: 'hidden',
                background: ['navy', 'rgba(4, 12, 64, 0.95)'],
                padding: panelHMargin + 'px',
                paddingTop: panelVMargin + 'px',
                paddingBottom: panelVMargin + 'px'
            }, this._scrollContent);
            var directoryService = panels.driveDirectoryService(this._drive);
            this._leftPanel = new panels.Panel(this._leftPanelHost, leftPath, directoryService);
            this._rightPanel = new panels.Panel(this._rightPanelHost, rightPath, directoryService);
            /*
            TODO: ensure focus stays with the text input at the bottom
            elem.on(this._leftPanel, 'mousedown', e=> {
              if (e.preventDefault)
                e.preventDefault();
              return false;
            }); */
        }
        TwoPanels.prototype.measure = function () {
        };
        TwoPanels.prototype.arrange = function (metrics) {
            var contentWidth = 0;
            if (metrics.hostWidth < metrics.emWidth * 25 && metrics.hostWidth < metrics.hostHeight * 0.8) {
                // flippable layout
                contentWidth = Math.max(metrics.hostWidth / 2, metrics.hostWidth * 2 - metrics.emWidth * 3);
            }
            else {
                // full layout
                contentWidth = metrics.hostWidth;
            }
            var bottomGap = Math.min(metrics.hostHeight / 3, metrics.emHeight * 3);
            this._scrollHost.style.width = metrics.hostWidth + 'px';
            var panelsHeight = metrics.hostHeight - bottomGap;
            this._scrollHost.style.height = panelsHeight + 'px';
            this._scrollContent.style.width = contentWidth + 'px';
            this._scrollContent.style.height = panelsHeight + 'px';
            var panelWidth = (contentWidth / 2 - 0.5) | 0;
            this._leftPanelHost.style.height = panelsHeight + 'px';
            this._leftPanelHost.style.width = panelWidth + 'px';
            this._rightPanelHost.style.height = panelsHeight + 'px';
            this._rightPanelHost.style.width = panelWidth + 'px';
            this._leftPanel.arrange({
                windowMetrics: metrics,
                hostWidth: panelWidth - panelHMargin * 2,
                hostHeight: panelsHeight - panelVMargin * 2
            });
            this._rightPanel.arrange({
                windowMetrics: metrics,
                hostWidth: panelWidth - panelHMargin * 2,
                hostHeight: panelsHeight - panelVMargin * 2
            });
        };
        TwoPanels.prototype.toggle = function () {
            this._scrollHost.style.display = this._scrollHost.style.display !== 'none' ? 'none' : 'block';
        };
        TwoPanels.prototype.keydown = function (e) {
        };
        return TwoPanels;
    })();
    panels.TwoPanels = TwoPanels;
})(panels || (panels = {}));
var panels;
(function (panels) {
    function driveDirectoryService(drive) {
        return function (path) {
            var pathPrefix = path === '/' ? path : path + '/';
            var result = [];
            var resByName = {};
            var files = drive.files();
            for (var i = 0; i < files.length; i++) {
                var fi = files[i];
                if (fi.length < pathPrefix.length + 1)
                    continue;
                if (fi.slice(0, pathPrefix.length) !== pathPrefix)
                    continue;
                var name;
                var entryPath = fi;
                var isDirectory = false;
                var nextSlashPos = fi.indexOf('/', pathPrefix.length);
                if (nextSlashPos < 0) {
                    name = fi.slice(pathPrefix.length);
                }
                else {
                    name = fi.slice(pathPrefix.length, nextSlashPos);
                    entryPath = fi.slice(0, nextSlashPos);
                    isDirectory = true;
                }
                if (resByName.hasOwnProperty(name))
                    continue;
                var entry = { path: entryPath, name: name, flags: isDirectory ? panels.Panel.EntryFlags.Directory : 0 };
                result.push(entry);
                resByName[name] = entry;
            }
            return result;
        };
    }
    panels.driveDirectoryService = driveDirectoryService;
})(panels || (panels = {}));
//setTimeout(() => start(require('drive')), 10);
setTimeout(function () { return showCommander(require('drive')); }, 10);
function showCommander(drive) {
    /*var s = require('ui');
    s.global.alert('Hello!');
    try {
      throw new Error('ok');
    }
    catch (err) {
      s.global.alert('proceed');
    }*/
    var commander = new CommanderShell(document.body, drive);
}
function start(drive) {
    var files = drive.files();
    var h1title = elem('h1', { text: files.length + ' files loaded' }, document.body);
    elem('div', { text: 'modified ' + new Date(drive.timestamp) }, document.body);
    for (var i = 0; i < files.length; i++) {
        var fileText = drive.read(files[i]);
        var coolLoadedTitle = elem('h3', { text: files[i] + ' [' + fileText.length + ']' }, document.body);
        var encodedText = fileText.replace(/\r|\n|\r\n/g, function (chunk) { return chunk === '\r\n' ? '[CRLF]\n' : chunk === '\r' ? '[CR]' : '[LF]\n'; });
        var content = elem('pre', { text: encodedText }, document.body);
    }
    h1title.onclick = exportAllHTML;
    function exportAllHTML() {
        var filename = saveFileName();
        exportBlob(filename, ['<!doctype html>\n', document.documentElement.outerHTML]);
    }
    function saveFileName() {
        if (window.location.protocol.toLowerCase() === 'blob:')
            return 'nportabled.html';
        var urlParts = window.location.pathname.split('/');
        var currentFileName = decodeURI(urlParts[urlParts.length - 1]);
        var lastDot = currentFileName.indexOf('.');
        if (lastDot > 0) {
            currentFileName = currentFileName.slice(0, lastDot) + '.html';
        }
        else {
            currentFileName += '.html';
        }
        return currentFileName;
    }
    function exportBlob(filename, textChunks) {
        try {
            var blob = new window.Blob(textChunks, { type: 'application/octet-stream' });
        }
        catch (blobError) {
            exportDocumentWrite(filename, textChunks.join(''));
            return;
        }
        exportBlobHTML5(filename, blob);
    }
    function exportBlobHTML5(filename, blob) {
        var url = window.URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.setAttribute('download', filename);
        try {
            // safer save method, supposed to work with FireFox
            var evt = document.createEvent("MouseEvents");
            evt.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            a.dispatchEvent(evt);
        }
        catch (e) {
            a.click();
        }
    }
    function exportDocumentWrite(filename, content) {
        var win = document.createElement('iframe');
        win.style.width = '100px';
        win.style.height = '100px';
        win.style.display = 'none';
        document.body.appendChild(win);
        setTimeout(function () {
            var doc = win.contentDocument || win.document;
            doc.open();
            doc.write(content);
            doc.close();
            doc.execCommand('SaveAs', null, filename);
            setTimeout(function () {
                win.parentElement.removeChild(win);
                (win);
            }, 1000);
        }, 200);
    }
}
var terminal;
(function (terminal) {
    var Terminal = (function () {
        function Terminal(_host) {
            this._host = _host;
            this._promptWidth = 0;
            this._historyContentHeight = 0;
            this._history = elem('div', {
                position: 'fixed',
                left: 0, bottom: 0,
                width: '100%', height: 0,
                overflow: 'auto'
            }, this._host);
            this._historyContent = elem('pre', {
                padding: 0, margin: 0,
                text: 'Hello world from mini-shell\n\nVersion 0.7m\nMay 2015\nOleg Mihailik\n\nPlease be careful.'
            }, this._history);
            this._prompt = elem('div', {
                position: 'fixed',
                left: 0, bottom: 0,
                height: '1em',
                text: '>'
            }, this._host);
            this._input = elem('textarea', {
                position: 'fixed',
                left: '0', bottom: 0,
                width: 0, height: '1em',
                font: 'inherit',
                border: 'none',
                background: 'transparent',
                color: ['inherit', 'silver'],
                outline: 'none',
                resize: 'none',
                overflow: 'hidden',
                autofocus: true
            }, this._host);
        }
        Terminal.prototype.measure = function () {
            this._promptWidth = this._prompt.offsetWidth;
            this._historyContentHeight = this._historyContent.offsetHeight;
        };
        Terminal.prototype.arrange = function (metrics) {
            this._history.style.bottom = metrics.emHeight + 'px';
            if (metrics.hostHeight - metrics.emHeight > this._historyContentHeight) {
                this._history.style.height = this._historyContentHeight + 'px';
            }
            else {
                this._history.style.height = (metrics.hostHeight - metrics.emHeight) + 'px';
                this._history.scrollTop = this._historyContentHeight - (metrics.hostHeight - metrics.emHeight);
            }
            this._input.style.left = this._promptWidth + 'px';
            this._input.style.width = (metrics.hostWidth - this._promptWidth) + 'px';
        };
        return Terminal;
    })();
    terminal.Terminal = Terminal;
})(terminal || (terminal = {}));
-->

<!-- /1.txt
OK -->

<!-- /4.txt
OK -->

<!-- /2.txt
OK -->

<!-- /3.txt
OK -->